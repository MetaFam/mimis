import{r as Ct,f as Vt,s as Yt}from"./DSTOT4fw.js";import{v as Ht,a as Et,n as Ut,b as jt,c as bt,d as nt,F as It,e as wt,m as st,g as Mt,f as Pt,h as J,i as U,j as vt,k as Ft,l as Dt,o as Kt,p as xt,q as rt,r as mt,s as zt,t as ot,u as Zt,w as _t,x as Gt,y as H}from"./Ci5bNVgp.js";/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const St=BigInt(0),gt=BigInt(1);function ct(n,e){const t=e.negate();return n?t:e}function qt(n,e){if(!Number.isSafeInteger(n)||n<=0||n>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+n)}function ft(n,e){qt(n,e);const t=Math.ceil(e/n)+1,i=2**(n-1),l=2**n,d=bt(n),u=BigInt(n);return{windows:t,windowSize:i,mask:d,maxNumber:l,shiftBy:u}}function Ot(n,e,t){const{windowSize:i,mask:l,maxNumber:d,shiftBy:u}=t;let E=Number(n&l),f=n>>u;E>i&&(E-=d,f+=gt);const S=e*i,m=S+Math.abs(E)-1,z=E===0,F=E<0,k=e%2!==0;return{nextN:f,offset:m,isZero:z,isNeg:F,isNegF:k,offsetF:S}}function Wt(n,e){if(!Array.isArray(n))throw new Error("array expected");n.forEach((t,i)=>{if(!(t instanceof e))throw new Error("invalid point at index "+i)})}function Xt(n,e){if(!Array.isArray(n))throw new Error("array of scalars expected");n.forEach((t,i)=>{if(!e.isValid(t))throw new Error("invalid scalar at index "+i)})}const lt=new WeakMap,Tt=new WeakMap;function dt(n){return Tt.get(n)||1}function $t(n,e){return{constTimeNegate:ct,hasPrecomputes(t){return dt(t)!==1},unsafeLadder(t,i,l=n.ZERO){let d=t;for(;i>St;)i&gt&&(l=l.add(d)),d=d.double(),i>>=gt;return l},precomputeWindow(t,i){const{windows:l,windowSize:d}=ft(i,e),u=[];let E=t,f=E;for(let S=0;S<l;S++){f=E,u.push(f);for(let m=1;m<d;m++)f=f.add(E),u.push(f);E=f.double()}return u},wNAF(t,i,l){let d=n.ZERO,u=n.BASE;const E=ft(t,e);for(let f=0;f<E.windows;f++){const{nextN:S,offset:m,isZero:z,isNeg:F,isNegF:k,offsetF:T}=Ot(l,f,E);l=S,z?u=u.add(ct(k,i[T])):d=d.add(ct(F,i[m]))}return{p:d,f:u}},wNAFUnsafe(t,i,l,d=n.ZERO){const u=ft(t,e);for(let E=0;E<u.windows&&l!==St;E++){const{nextN:f,offset:S,isZero:m,isNeg:z}=Ot(l,E,u);if(l=f,!m){const F=i[S];d=d.add(z?F.negate():F)}}return d},getPrecomputes(t,i,l){let d=lt.get(i);return d||(d=this.precomputeWindow(i,t),t!==1&&lt.set(i,l(d))),d},wNAFCached(t,i,l){const d=dt(t);return this.wNAF(d,this.getPrecomputes(d,t,l),i)},wNAFCachedUnsafe(t,i,l,d){const u=dt(t);return u===1?this.unsafeLadder(t,i,d):this.wNAFUnsafe(u,this.getPrecomputes(u,t,l),i,d)},setWindowSize(t,i){qt(i,e),Tt.set(t,i),lt.delete(t)}}}function Qt(n,e,t,i){Wt(t,n),Xt(i,e);const l=t.length,d=i.length;if(l!==d)throw new Error("arrays of points and scalars must have equal length");const u=n.ZERO,E=jt(BigInt(l));let f=1;E>12?f=E-3:E>4?f=E-2:E>0&&(f=2);const S=bt(f),m=new Array(Number(S)+1).fill(u),z=Math.floor((e.BITS-1)/f)*f;let F=u;for(let k=z;k>=0;k-=f){m.fill(u);for(let h=0;h<d;h++){const Y=i[h],Z=Number(Y>>BigInt(k)&S);m[Z]=m[Z].add(t[h])}let T=u;for(let h=m.length-1,Y=u;h>0;h--)Y=Y.add(m[h]),T=T.add(Y);if(F=F.add(T),k!==0)for(let h=0;h<f;h++)F=F.double()}return F}function Lt(n){return Ht(n.Fp),Et(n,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Ut(n.n,n.nBitLength),...n,p:n.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Rt(n){n.lowS!==void 0&&rt("lowS",n.lowS),n.prehash!==void 0&&rt("prehash",n.prehash)}function Jt(n){const e=Lt(n);Et(e,{a:"field",b:"field"},{allowInfinityPoint:"boolean",allowedPrivateKeyLengths:"array",clearCofactor:"function",fromBytes:"function",isTorsionFree:"function",toBytes:"function",wrapPrivateKey:"boolean"});const{endo:t,Fp:i,a:l}=e;if(t){if(!i.eql(l,i.ZERO))throw new Error("invalid endo: CURVE.a must be 0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function')}return Object.freeze({...e})}class te extends Error{constructor(e=""){super(e)}}const D={Err:te,_tlv:{encode:(n,e)=>{const{Err:t}=D;if(n<0||n>256)throw new t("tlv.encode: wrong tag");if(e.length&1)throw new t("tlv.encode: unpadded data");const i=e.length/2,l=ot(i);if(l.length/2&128)throw new t("tlv.encode: long form length too big");const d=i>127?ot(l.length/2|128):"";return ot(n)+d+l+e},decode(n,e){const{Err:t}=D;let i=0;if(n<0||n>256)throw new t("tlv.encode: wrong tag");if(e.length<2||e[i++]!==n)throw new t("tlv.decode: wrong tlv");const l=e[i++],d=!!(l&128);let u=0;if(!d)u=l;else{const f=l&127;if(!f)throw new t("tlv.decode(long): indefinite length not supported");if(f>4)throw new t("tlv.decode(long): byte length is too big");const S=e.subarray(i,i+f);if(S.length!==f)throw new t("tlv.decode: length bytes not complete");if(S[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(const m of S)u=u<<8|m;if(i+=f,u<128)throw new t("tlv.decode(long): not minimal encoding")}const E=e.subarray(i,i+u);if(E.length!==u)throw new t("tlv.decode: wrong value length");return{v:E,l:e.subarray(i+u)}}},_int:{encode(n){const{Err:e}=D;if(n<K)throw new e("integer: negative integers are not allowed");let t=ot(n);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return t},decode(n){const{Err:e}=D;if(n[0]&128)throw new e("invalid signature integer: negative");if(n[0]===0&&!(n[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return nt(n)}},toSig(n){const{Err:e,_int:t,_tlv:i}=D,l=U("signature",n),{v:d,l:u}=i.decode(48,l);if(u.length)throw new e("invalid signature: left bytes after parsing");const{v:E,l:f}=i.decode(2,d),{v:S,l:m}=i.decode(2,f);if(m.length)throw new e("invalid signature: left bytes after parsing");return{r:t.decode(E),s:t.decode(S)}},hexFromSig(n){const{_tlv:e,_int:t}=D,i=e.encode(2,t.encode(n.r)),l=e.encode(2,t.encode(n.s)),d=i+l;return e.encode(48,d)}};function ut(n,e){return mt(Zt(n,e))}const K=BigInt(0),q=BigInt(1);BigInt(2);const ht=BigInt(3),ee=BigInt(4);function ne(n){const e=Jt(n),{Fp:t}=e,i=It(e.n,e.nBitLength),l=e.toBytes||((v,r,a)=>{const w=r.toAffine();return wt(Uint8Array.from([4]),t.toBytes(w.x),t.toBytes(w.y))}),d=e.fromBytes||(v=>{const r=v.subarray(1),a=t.fromBytes(r.subarray(0,t.BYTES)),w=t.fromBytes(r.subarray(t.BYTES,2*t.BYTES));return{x:a,y:w}});function u(v){const{a:r,b:a}=e,w=t.sqr(v),b=t.mul(w,v);return t.add(t.add(b,t.mul(v,r)),a)}function E(v,r){const a=t.sqr(r),w=u(v);return t.eql(a,w)}if(!E(e.Gx,e.Gy))throw new Error("bad curve params: generator point");const f=t.mul(t.pow(e.a,ht),ee),S=t.mul(t.sqr(e.b),BigInt(27));if(t.is0(t.add(f,S)))throw new Error("bad curve params: a or b");function m(v){return zt(v,q,e.n)}function z(v){const{allowedPrivateKeyLengths:r,nByteLength:a,wrapPrivateKey:w,n:b}=e;if(r&&typeof v!="bigint"){if(Ft(v)&&(v=mt(v)),typeof v!="string"||!r.includes(v.length))throw new Error("invalid private key");v=v.padStart(a*2,"0")}let R;try{R=typeof v=="bigint"?v:nt(U("private key",v,a))}catch{throw new Error("invalid private key, expected hex or "+a+" bytes, got "+typeof v)}return w&&(R=st(R,b)),J("private key",R,q,b),R}function F(v){if(!(v instanceof h))throw new Error("ProjectivePoint expected")}const k=xt((v,r)=>{const{px:a,py:w,pz:b}=v;if(t.eql(b,t.ONE))return{x:a,y:w};const R=v.is0();r==null&&(r=R?t.ONE:t.inv(b));const N=t.mul(a,r),A=t.mul(w,r),g=t.mul(b,r);if(R)return{x:t.ZERO,y:t.ZERO};if(!t.eql(g,t.ONE))throw new Error("invZ was invalid");return{x:N,y:A}}),T=xt(v=>{if(v.is0()){if(e.allowInfinityPoint&&!t.is0(v.py))return;throw new Error("bad point: ZERO")}const{x:r,y:a}=v.toAffine();if(!t.isValid(r)||!t.isValid(a))throw new Error("bad point: x or y not FE");if(!E(r,a))throw new Error("bad point: equation left != right");if(!v.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class h{constructor(r,a,w){if(r==null||!t.isValid(r))throw new Error("x required");if(a==null||!t.isValid(a)||t.is0(a))throw new Error("y required");if(w==null||!t.isValid(w))throw new Error("z required");this.px=r,this.py=a,this.pz=w,Object.freeze(this)}static fromAffine(r){const{x:a,y:w}=r||{};if(!r||!t.isValid(a)||!t.isValid(w))throw new Error("invalid affine point");if(r instanceof h)throw new Error("projective point not allowed");const b=R=>t.eql(R,t.ZERO);return b(a)&&b(w)?h.ZERO:new h(a,w,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(r){const a=Kt(t,r.map(w=>w.pz));return r.map((w,b)=>w.toAffine(a[b])).map(h.fromAffine)}static fromHex(r){const a=h.fromAffine(d(U("pointHex",r)));return a.assertValidity(),a}static fromPrivateKey(r){return h.BASE.multiply(z(r))}static msm(r,a){return Qt(h,i,r,a)}_setWindowSize(r){M.setWindowSize(this,r)}assertValidity(){T(this)}hasEvenY(){const{y:r}=this.toAffine();if(t.isOdd)return!t.isOdd(r);throw new Error("Field doesn't support isOdd")}equals(r){F(r);const{px:a,py:w,pz:b}=this,{px:R,py:N,pz:A}=r,g=t.eql(t.mul(a,A),t.mul(R,b)),O=t.eql(t.mul(w,A),t.mul(N,b));return g&&O}negate(){return new h(this.px,t.neg(this.py),this.pz)}double(){const{a:r,b:a}=e,w=t.mul(a,ht),{px:b,py:R,pz:N}=this;let A=t.ZERO,g=t.ZERO,O=t.ZERO,p=t.mul(b,b),L=t.mul(R,R),s=t.mul(N,N),o=t.mul(b,R);return o=t.add(o,o),O=t.mul(b,N),O=t.add(O,O),A=t.mul(r,O),g=t.mul(w,s),g=t.add(A,g),A=t.sub(L,g),g=t.add(L,g),g=t.mul(A,g),A=t.mul(o,A),O=t.mul(w,O),s=t.mul(r,s),o=t.sub(p,s),o=t.mul(r,o),o=t.add(o,O),O=t.add(p,p),p=t.add(O,p),p=t.add(p,s),p=t.mul(p,o),g=t.add(g,p),s=t.mul(R,N),s=t.add(s,s),p=t.mul(s,o),A=t.sub(A,p),O=t.mul(s,L),O=t.add(O,O),O=t.add(O,O),new h(A,g,O)}add(r){F(r);const{px:a,py:w,pz:b}=this,{px:R,py:N,pz:A}=r;let g=t.ZERO,O=t.ZERO,p=t.ZERO;const L=e.a,s=t.mul(e.b,ht);let o=t.mul(a,R),c=t.mul(w,N),x=t.mul(b,A),y=t.add(a,w),B=t.add(R,N);y=t.mul(y,B),B=t.add(o,c),y=t.sub(y,B),B=t.add(a,b);let I=t.add(R,A);return B=t.mul(B,I),I=t.add(o,x),B=t.sub(B,I),I=t.add(w,b),g=t.add(N,A),I=t.mul(I,g),g=t.add(c,x),I=t.sub(I,g),p=t.mul(L,B),g=t.mul(s,x),p=t.add(g,p),g=t.sub(c,p),p=t.add(c,p),O=t.mul(g,p),c=t.add(o,o),c=t.add(c,o),x=t.mul(L,x),B=t.mul(s,B),c=t.add(c,x),x=t.sub(o,x),x=t.mul(L,x),B=t.add(B,x),o=t.mul(c,B),O=t.add(O,o),o=t.mul(I,B),g=t.mul(y,g),g=t.sub(g,o),o=t.mul(y,c),p=t.mul(I,p),p=t.add(p,o),new h(g,O,p)}subtract(r){return this.add(r.negate())}is0(){return this.equals(h.ZERO)}wNAF(r){return M.wNAFCached(this,r,h.normalizeZ)}multiplyUnsafe(r){const{endo:a,n:w}=e;J("scalar",r,K,w);const b=h.ZERO;if(r===K)return b;if(this.is0()||r===q)return this;if(!a||M.hasPrecomputes(this))return M.wNAFCachedUnsafe(this,r,h.normalizeZ);let{k1neg:R,k1:N,k2neg:A,k2:g}=a.splitScalar(r),O=b,p=b,L=this;for(;N>K||g>K;)N&q&&(O=O.add(L)),g&q&&(p=p.add(L)),L=L.double(),N>>=q,g>>=q;return R&&(O=O.negate()),A&&(p=p.negate()),p=new h(t.mul(p.px,a.beta),p.py,p.pz),O.add(p)}multiply(r){const{endo:a,n:w}=e;J("scalar",r,q,w);let b,R;if(a){const{k1neg:N,k1:A,k2neg:g,k2:O}=a.splitScalar(r);let{p,f:L}=this.wNAF(A),{p:s,f:o}=this.wNAF(O);p=M.constTimeNegate(N,p),s=M.constTimeNegate(g,s),s=new h(t.mul(s.px,a.beta),s.py,s.pz),b=p.add(s),R=L.add(o)}else{const{p:N,f:A}=this.wNAF(r);b=N,R=A}return h.normalizeZ([b,R])[0]}multiplyAndAddUnsafe(r,a,w){const b=h.BASE,R=(A,g)=>g===K||g===q||!A.equals(b)?A.multiplyUnsafe(g):A.multiply(g),N=R(this,a).add(R(r,w));return N.is0()?void 0:N}toAffine(r){return k(this,r)}isTorsionFree(){const{h:r,isTorsionFree:a}=e;if(r===q)return!0;if(a)return a(h,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:r,clearCofactor:a}=e;return r===q?this:a?a(h,this):this.multiplyUnsafe(e.h)}toRawBytes(r=!0){return rt("isCompressed",r),this.assertValidity(),l(h,this,r)}toHex(r=!0){return rt("isCompressed",r),mt(this.toRawBytes(r))}}h.BASE=new h(e.Gx,e.Gy,t.ONE),h.ZERO=new h(t.ZERO,t.ONE,t.ZERO);const{endo:Y,nBitLength:Z}=e,M=$t(h,Y?Math.ceil(Z/2):Z);return{CURVE:e,ProjectivePoint:h,normPrivateKeyToScalar:z,weierstrassEquation:u,isWithinCurveOrder:m}}function re(n){const e=Lt(n);return Et(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function oe(n){const e=re(n),{Fp:t,n:i,nByteLength:l,nBitLength:d}=e,u=t.BYTES+1,E=2*t.BYTES+1;function f(s){return st(s,i)}function S(s){return _t(s,i)}const{ProjectivePoint:m,normPrivateKeyToScalar:z,weierstrassEquation:F,isWithinCurveOrder:k}=ne({...e,toBytes(s,o,c){const x=o.toAffine(),y=t.toBytes(x.x),B=wt;return rt("isCompressed",c),c?B(Uint8Array.from([o.hasEvenY()?2:3]),y):B(Uint8Array.from([4]),y,t.toBytes(x.y))},fromBytes(s){const o=s.length,c=s[0],x=s.subarray(1);if(o===u&&(c===2||c===3)){const y=nt(x);if(!zt(y,q,t.ORDER))throw new Error("Point is not on curve");const B=F(y);let I;try{I=t.sqrt(B)}catch(j){const V=j instanceof Error?": "+j.message:"";throw new Error("Point is not on curve"+V)}const C=(I&q)===q;return(c&1)===1!==C&&(I=t.neg(I)),{x:y,y:I}}else if(o===E&&c===4){const y=t.fromBytes(x.subarray(0,t.BYTES)),B=t.fromBytes(x.subarray(t.BYTES,2*t.BYTES));return{x:y,y:B}}else{const y=u,B=E;throw new Error("invalid Point, expected length of "+y+", or uncompressed "+B+", got "+o)}}});function T(s){const o=i>>q;return s>o}function h(s){return T(s)?f(-s):s}const Y=(s,o,c)=>nt(s.slice(o,c));class Z{constructor(o,c,x){J("r",o,q,i),J("s",c,q,i),this.r=o,this.s=c,x!=null&&(this.recovery=x),Object.freeze(this)}static fromCompact(o){const c=l;return o=U("compactSignature",o,c*2),new Z(Y(o,0,c),Y(o,c,2*c))}static fromDER(o){const{r:c,s:x}=D.toSig(U("DER",o));return new Z(c,x)}assertValidity(){}addRecoveryBit(o){return new Z(this.r,this.s,o)}recoverPublicKey(o){const{r:c,s:x,recovery:y}=this,B=b(U("msgHash",o));if(y==null||![0,1,2,3].includes(y))throw new Error("recovery id invalid");const I=y===2||y===3?c+e.n:c;if(I>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const C=(y&1)===0?"02":"03",P=m.fromHex(C+ut(I,t.BYTES)),j=S(I),V=f(-B*j),X=f(x*j),_=m.BASE.multiplyAndAddUnsafe(P,V,X);if(!_)throw new Error("point at infinify");return _.assertValidity(),_}hasHighS(){return T(this.s)}normalizeS(){return this.hasHighS()?new Z(this.r,f(-this.s),this.recovery):this}toDERRawBytes(){return vt(this.toDERHex())}toDERHex(){return D.hexFromSig(this)}toCompactRawBytes(){return vt(this.toCompactHex())}toCompactHex(){const o=l;return ut(this.r,o)+ut(this.s,o)}}const M={isValidPrivateKey(s){try{return z(s),!0}catch{return!1}},normPrivateKeyToScalar:z,randomPrivateKey:()=>{const s=Mt(e.n);return Pt(e.randomBytes(s),e.n)},precompute(s=8,o=m.BASE){return o._setWindowSize(s),o.multiply(BigInt(3)),o}};function v(s,o=!0){return m.fromPrivateKey(s).toRawBytes(o)}function r(s){if(typeof s=="bigint")return!1;if(s instanceof m)return!0;const c=U("key",s).length,x=t.BYTES,y=x+1,B=2*x+1;if(!(e.allowedPrivateKeyLengths||l===y))return c===y||c===B}function a(s,o,c=!0){if(r(s)===!0)throw new Error("first arg must be private key");if(r(o)===!1)throw new Error("second arg must be public key");return m.fromHex(o).multiply(z(s)).toRawBytes(c)}const w=e.bits2int||function(s){if(s.length>8192)throw new Error("input is too large");const o=nt(s),c=s.length*8-d;return c>0?o>>BigInt(c):o},b=e.bits2int_modN||function(s){return f(w(s))},R=bt(d);function N(s){return J("num < 2^"+d,s,K,R),Zt(s,l)}function A(s,o,c=g){if(["recovered","canonical"].some(G=>G in c))throw new Error("sign() legacy options not supported");const{hash:x,randomBytes:y}=e;let{lowS:B,prehash:I,extraEntropy:C}=c;B==null&&(B=!0),s=U("msgHash",s),Rt(c),I&&(s=U("prehashed msgHash",x(s)));const P=b(s),j=z(o),V=[N(j),N(P)];if(C!=null&&C!==!1){const G=C===!0?y(t.BYTES):C;V.push(U("extraEntropy",G))}const X=wt(...V),_=P;function it(G){const $=w(G);if(!k($))return;const at=S($),tt=m.BASE.multiply($).toAffine(),W=f(tt.x);if(W===K)return;const et=f(at*f(_+W*j));if(et===K)return;let Q=(tt.x===W?0:2)|Number(tt.y&q),Bt=et;return B&&T(et)&&(Bt=h(et),Q^=1),new Z(W,Bt,Q)}return{seed:X,k2sig:it}}const g={lowS:e.lowS,prehash:!1},O={lowS:e.lowS,prehash:!1};function p(s,o,c=g){const{seed:x,k2sig:y}=A(s,o,c),B=e;return Dt(B.hash.outputLen,B.nByteLength,B.hmac)(x,y)}m.BASE._setWindowSize(8);function L(s,o,c,x=O){const y=s;o=U("msgHash",o),c=U("publicKey",c);const{lowS:B,prehash:I,format:C}=x;if(Rt(x),"strict"in x)throw new Error("options.strict was renamed to lowS");if(C!==void 0&&C!=="compact"&&C!=="der")throw new Error("format must be compact or der");const P=typeof y=="string"||Ft(y),j=!P&&!C&&typeof y=="object"&&y!==null&&typeof y.r=="bigint"&&typeof y.s=="bigint";if(!P&&!j)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let V,X;try{if(j&&(V=new Z(y.r,y.s)),P){try{C!=="compact"&&(V=Z.fromDER(y))}catch(Q){if(!(Q instanceof D.Err))throw Q}!V&&C!=="der"&&(V=Z.fromCompact(y))}X=m.fromHex(c)}catch{return!1}if(!V||B&&V.hasHighS())return!1;I&&(o=e.hash(o));const{r:_,s:it}=V,G=b(o),$=S(it),at=f(G*$),tt=f(_*$),W=m.BASE.multiplyAndAddUnsafe(X,at,tt)?.toAffine();return W?f(W.x)===_:!1}return{CURVE:e,getPublicKey:v,getSharedSecret:a,sign:p,verify:L,ProjectivePoint:m,Signature:Z,utils:M}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function se(n){return{hash:n,hmac:(e,...t)=>Gt(n,e,Vt(...t)),randomBytes:Ct}}function ie(n,e){const t=i=>oe({...n,...se(i)});return{...t(e),create:t}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const kt=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),At=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),ae=BigInt(0),ce=BigInt(1),pt=BigInt(2),Nt=(n,e)=>(n+e/pt)/e;function fe(n){const e=kt,t=BigInt(3),i=BigInt(6),l=BigInt(11),d=BigInt(22),u=BigInt(23),E=BigInt(44),f=BigInt(88),S=n*n*n%e,m=S*S*n%e,z=H(m,t,e)*m%e,F=H(z,t,e)*m%e,k=H(F,pt,e)*S%e,T=H(k,l,e)*k%e,h=H(T,d,e)*T%e,Y=H(h,E,e)*h%e,Z=H(Y,f,e)*Y%e,M=H(Z,E,e)*h%e,v=H(M,t,e)*m%e,r=H(v,u,e)*T%e,a=H(r,i,e)*S%e,w=H(a,pt,e);if(!yt.eql(yt.sqr(w),n))throw new Error("Cannot find square root");return w}const yt=It(kt,void 0,void 0,{sqrt:fe}),ue=ie({a:ae,b:BigInt(7),Fp:yt,n:At,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:n=>{const e=At,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),i=-ce*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),l=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),d=t,u=BigInt("0x100000000000000000000000000000000"),E=Nt(d*n,e),f=Nt(-i*n,e);let S=st(n-E*t-f*l,e),m=st(-E*i-f*d,e);const z=S>u,F=m>u;if(z&&(S=e-S),F&&(m=e-m),S>u||m>u)throw new Error("splitScalar: Endomorphism failed, k="+n);return{k1neg:z,k1:S,k2neg:F,k2:m}}}},Yt);export{ue as secp256k1};
