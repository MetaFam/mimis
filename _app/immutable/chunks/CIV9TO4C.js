import{h as Vt}from"./BEBaXJsP.js";import{n as Nt,a as qt,b as ct,c as At,d as lt,_ as mt,e as Ht,f as at,g as V,m as yt,h as Ct,i as it,j as Yt}from"./FwuuY7KI.js";import{D as $t,c as X,a as pt,b as wt,h as Ut,E as kt,i as Dt}from"./C1TpcBhl.js";/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const M=BigInt(0),O=BigInt(1),k=BigInt(2),Gt=BigInt(3),It=BigInt(4),_t=BigInt(5),Zt=BigInt(8);function H(e,n){const t=e%n;return t>=M?t:n+t}function Be(e,n,t){let r=e;for(;n-- >M;)r*=r,r%=t;return r}function Et(e,n){if(e===M)throw new Error("invert: expected non-zero number");if(n<=M)throw new Error("invert: expected positive modulus, got "+n);let t=H(e,n),r=n,i=M,c=O;for(;t!==M;){const d=r/t,f=r%t,v=i-c*d;r=t,t=f,i=c,c=v}if(r!==O)throw new Error("invert: does not exist");return H(i,n)}function zt(e,n){const t=(e.ORDER+O)/It,r=e.pow(n,t);if(!e.eql(e.sqr(r),n))throw new Error("Cannot find square root");return r}function Ft(e,n){const t=(e.ORDER-_t)/Zt,r=e.mul(n,k),i=e.pow(r,t),c=e.mul(n,i),o=e.mul(e.mul(c,k),i),d=e.mul(c,e.sub(o,e.ONE));if(!e.eql(e.sqr(d),n))throw new Error("Cannot find square root");return d}function Xt(e){if(e<BigInt(3))throw new Error("sqrt is not defined for small field");let n=e-O,t=0;for(;n%k===M;)n/=k,t++;let r=k;const i=gt(e);for(;bt(i,r)===1;)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(t===1)return zt;let c=i.pow(r,n);const o=(n+O)/k;return function(f,v){if(f.is0(v))return v;if(bt(f,v)!==1)throw new Error("Cannot find square root");let a=t,B=f.mul(f.ONE,c),x=f.pow(v,n),I=f.pow(v,o);for(;!f.eql(x,f.ONE);){if(f.is0(x))return f.ZERO;let L=1,_=f.sqr(x);for(;!f.eql(_,f.ONE);)if(L++,_=f.sqr(_),L===a)throw new Error("Cannot find square root");const K=O<<BigInt(a-L-1),C=f.pow(B,K);a=L,B=f.sqr(C),x=f.mul(x,B),I=f.mul(I,C)}return I}}function Pt(e){return e%It===Gt?zt:e%Zt===_t?Ft:Xt(e)}const xe=(e,n)=>(H(e,n)&O)===O,Wt=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Qt(e){const n={ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"},t=Wt.reduce((r,i)=>(r[i]="function",r),n);return mt(e,t),e}function Jt(e,n,t){if(t<M)throw new Error("invalid exponent, negatives unsupported");if(t===M)return e.ONE;if(t===O)return n;let r=e.ONE,i=n;for(;t>M;)t&O&&(r=e.mul(r,i)),i=e.sqr(i),t>>=O;return r}function Rt(e,n,t=!1){const r=new Array(n.length).fill(t?e.ZERO:void 0),i=n.reduce((o,d,f)=>e.is0(d)?o:(r[f]=o,e.mul(o,d)),e.ONE),c=e.inv(i);return n.reduceRight((o,d,f)=>e.is0(d)?o:(r[f]=e.mul(o,r[f]),e.mul(o,d)),c),r}function bt(e,n){const t=(e.ORDER-O)/k,r=e.pow(n,t),i=e.eql(r,e.ONE),c=e.eql(r,e.ZERO),o=e.eql(r,e.neg(e.ONE));if(!i&&!c&&!o)throw new Error("invalid Legendre symbol result");return i?1:c?0:-1}function te(e,n){n!==void 0&&$t(n);const t=n!==void 0?n:e.toString(2).length,r=Math.ceil(t/8);return{nBitLength:t,nByteLength:r}}function gt(e,n,t=!1,r={}){if(e<=M)throw new Error("invalid field: expected ORDER > 0, got "+e);let i,c;if(typeof n=="object"&&n!=null){if(r.sqrt||t)throw new Error("cannot specify opts in two arguments");const a=n;a.BITS&&(i=a.BITS),a.sqrt&&(c=a.sqrt),typeof a.isLE=="boolean"&&(t=a.isLE)}else typeof n=="number"&&(i=n),r.sqrt&&(c=r.sqrt);const{nBitLength:o,nByteLength:d}=te(e,i);if(d>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let f;const v=Object.freeze({ORDER:e,isLE:t,BITS:o,BYTES:d,MASK:ct(o),ZERO:M,ONE:O,create:a=>H(a,e),isValid:a=>{if(typeof a!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof a);return M<=a&&a<e},is0:a=>a===M,isValidNot0:a=>!v.is0(a)&&v.isValid(a),isOdd:a=>(a&O)===O,neg:a=>H(-a,e),eql:(a,B)=>a===B,sqr:a=>H(a*a,e),add:(a,B)=>H(a+B,e),sub:(a,B)=>H(a-B,e),mul:(a,B)=>H(a*B,e),pow:(a,B)=>Jt(v,a,B),div:(a,B)=>H(a*Et(B,e),e),sqrN:a=>a*a,addN:(a,B)=>a+B,subN:(a,B)=>a-B,mulN:(a,B)=>a*B,inv:a=>Et(a,e),sqrt:c||(a=>(f||(f=Pt(e)),f(v,a))),toBytes:a=>t?Nt(a,d):qt(a,d),fromBytes:a=>{if(a.length!==d)throw new Error("Field.fromBytes: expected "+d+" bytes, got "+a.length);return t?At(a):lt(a)},invertBatch:a=>Rt(v,a),cmov:(a,B,x)=>x?B:a});return Object.freeze(v)}function Ot(e){if(typeof e!="bigint")throw new Error("field order must be bigint");const n=e.toString(2).length;return Math.ceil(n/8)}function Tt(e){const n=Ot(e);return n+Math.ceil(n/2)}function ee(e,n,t=!1){const r=e.length,i=Ot(n),c=Tt(n);if(r<16||r<c||r>1024)throw new Error("expected "+c+"-1024 bytes of input, got "+r);const o=t?At(e):lt(e),d=H(o,n-O)+O;return t?Nt(d,i):qt(d,i)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const P=BigInt(0),D=BigInt(1);function J(e,n){const t=n.negate();return e?t:n}function ne(e,n,t){const r=n==="pz"?o=>o.pz:o=>o.ez,i=Rt(e.Fp,t.map(r));return t.map((o,d)=>o.toAffine(i[d])).map(e.fromAffine)}function Lt(e,n){if(!Number.isSafeInteger(e)||e<=0||e>n)throw new Error("invalid window size, expected [1.."+n+"], got W="+e)}function ut(e,n){Lt(e,n);const t=Math.ceil(n/e)+1,r=2**(e-1),i=2**e,c=ct(e),o=BigInt(e);return{windows:t,windowSize:r,mask:c,maxNumber:i,shiftBy:o}}function vt(e,n,t){const{windowSize:r,mask:i,maxNumber:c,shiftBy:o}=t;let d=Number(e&i),f=e>>o;d>r&&(d-=c,f+=D);const v=n*r,a=v+Math.abs(d)-1,B=d===0,x=d<0,I=n%2!==0;return{nextN:f,offset:a,isZero:B,isNeg:x,isNegF:I,offsetF:v}}function re(e,n){if(!Array.isArray(e))throw new Error("array expected");e.forEach((t,r)=>{if(!(t instanceof n))throw new Error("invalid point at index "+r)})}function oe(e,n){if(!Array.isArray(e))throw new Error("array of scalars expected");e.forEach((t,r)=>{if(!n.isValid(t))throw new Error("invalid scalar at index "+r)})}const dt=new WeakMap,jt=new WeakMap;function ht(e){return jt.get(e)||1}function Bt(e){if(e!==P)throw new Error("invalid wNAF")}function ie(e,n){return{constTimeNegate:J,hasPrecomputes(t){return ht(t)!==1},unsafeLadder(t,r,i=e.ZERO){let c=t;for(;r>P;)r&D&&(i=i.add(c)),c=c.double(),r>>=D;return i},precomputeWindow(t,r){const{windows:i,windowSize:c}=ut(r,n),o=[];let d=t,f=d;for(let v=0;v<i;v++){f=d,o.push(f);for(let a=1;a<c;a++)f=f.add(d),o.push(f);d=f.double()}return o},wNAF(t,r,i){let c=e.ZERO,o=e.BASE;const d=ut(t,n);for(let f=0;f<d.windows;f++){const{nextN:v,offset:a,isZero:B,isNeg:x,isNegF:I,offsetF:L}=vt(i,f,d);i=v,B?o=o.add(J(I,r[L])):c=c.add(J(x,r[a]))}return Bt(i),{p:c,f:o}},wNAFUnsafe(t,r,i,c=e.ZERO){const o=ut(t,n);for(let d=0;d<o.windows&&i!==P;d++){const{nextN:f,offset:v,isZero:a,isNeg:B}=vt(i,d,o);if(i=f,!a){const x=r[v];c=c.add(B?x.negate():x)}}return Bt(i),c},getPrecomputes(t,r,i){let c=dt.get(r);return c||(c=this.precomputeWindow(r,t),t!==1&&(typeof i=="function"&&(c=i(c)),dt.set(r,c))),c},wNAFCached(t,r,i){const c=ht(t);return this.wNAF(c,this.getPrecomputes(c,t,i),r)},wNAFCachedUnsafe(t,r,i,c){const o=ht(t);return o===1?this.unsafeLadder(t,r,c):this.wNAFUnsafe(o,this.getPrecomputes(o,t,i),r,c)},setWindowSize(t,r){Lt(r,n),jt.set(t,r),dt.delete(t)}}}function se(e,n,t,r){let i=n,c=e.ZERO,o=e.ZERO;for(;t>P||r>P;)t&D&&(c=c.add(i)),r&D&&(o=o.add(i)),i=i.double(),t>>=D,r>>=D;return{p1:c,p2:o}}function ae(e,n,t,r){re(t,e),oe(r,n);const i=t.length,c=r.length;if(i!==c)throw new Error("arrays of points and scalars must have equal length");const o=e.ZERO,d=Ht(BigInt(i));let f=1;d>12?f=d-3:d>4?f=d-2:d>0&&(f=2);const v=ct(f),a=new Array(Number(v)+1).fill(o),B=Math.floor((n.BITS-1)/f)*f;let x=o;for(let I=B;I>=0;I-=f){a.fill(o);for(let _=0;_<c;_++){const K=r[_],C=Number(K>>BigInt(I)&v);a[C]=a[C].add(t[_])}let L=o;for(let _=a.length-1,K=o;_>0;_--)K=K.add(a[_]),L=L.add(K);if(x=x.add(L),I!==0)for(let _=0;_<f;_++)x=x.double()}return x}function xt(e,n){if(n){if(n.ORDER!==e)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return Qt(n),n}else return gt(e)}function ce(e,n,t={}){if(!n||typeof n!="object")throw new Error(`expected valid ${e} CURVE object`);for(const d of["p","n","h"]){const f=n[d];if(!(typeof f=="bigint"&&f>P))throw new Error(`CURVE.${d} must be positive bigint`)}const r=xt(n.p,t.Fp),i=xt(n.n,t.Fn),o=["Gx","Gy","a",e==="weierstrass"?"b":"d"];for(const d of o)if(!r.isValid(n[d]))throw new Error(`CURVE.${d} must be valid field element of CURVE.Fp`);return{Fp:r,Fn:i}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function St(e){e.lowS!==void 0&&at("lowS",e.lowS),e.prehash!==void 0&&at("prehash",e.prehash)}class le extends Error{constructor(n=""){super(n)}}const Y={Err:le,_tlv:{encode:(e,n)=>{const{Err:t}=Y;if(e<0||e>256)throw new t("tlv.encode: wrong tag");if(n.length&1)throw new t("tlv.encode: unpadded data");const r=n.length/2,i=it(r);if(i.length/2&128)throw new t("tlv.encode: long form length too big");const c=r>127?it(i.length/2|128):"";return it(e)+c+i+n},decode(e,n){const{Err:t}=Y;let r=0;if(e<0||e>256)throw new t("tlv.encode: wrong tag");if(n.length<2||n[r++]!==e)throw new t("tlv.decode: wrong tlv");const i=n[r++],c=!!(i&128);let o=0;if(!c)o=i;else{const f=i&127;if(!f)throw new t("tlv.decode(long): indefinite length not supported");if(f>4)throw new t("tlv.decode(long): byte length is too big");const v=n.subarray(r,r+f);if(v.length!==f)throw new t("tlv.decode: length bytes not complete");if(v[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(const a of v)o=o<<8|a;if(r+=f,o<128)throw new t("tlv.decode(long): not minimal encoding")}const d=n.subarray(r,r+o);if(d.length!==o)throw new t("tlv.decode: wrong value length");return{v:d,l:n.subarray(r+o)}}},_int:{encode(e){const{Err:n}=Y;if(e<tt)throw new n("integer: negative integers are not allowed");let t=it(e);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new n("unexpected DER parsing assertion: unpadded hex");return t},decode(e){const{Err:n}=Y;if(e[0]&128)throw new n("invalid signature integer: negative");if(e[0]===0&&!(e[1]&128))throw new n("invalid signature integer: unnecessary leading zero");return lt(e)}},toSig(e){const{Err:n,_int:t,_tlv:r}=Y,i=V("signature",e),{v:c,l:o}=r.decode(48,i);if(o.length)throw new n("invalid signature: left bytes after parsing");const{v:d,l:f}=r.decode(2,c),{v,l:a}=r.decode(2,f);if(a.length)throw new n("invalid signature: left bytes after parsing");return{r:t.decode(d),s:t.decode(v)}},hexFromSig(e){const{_tlv:n,_int:t}=Y,r=n.encode(2,t.encode(e.r)),i=n.encode(2,t.encode(e.s)),c=r+i;return n.encode(48,c)}},tt=BigInt(0),et=BigInt(1),fe=BigInt(2),st=BigInt(3),ue=BigInt(4);function de(e,n,t){function r(i){const c=e.sqr(i),o=e.mul(c,i);return e.add(e.add(o,e.mul(i,n)),t)}return r}function Kt(e,n,t){const{BYTES:r}=e;function i(c){let o;if(typeof c=="bigint")o=c;else{let d=V("private key",c);if(n){if(!n.includes(d.length*2))throw new Error("invalid private key");const f=new Uint8Array(r);f.set(d,f.length-d.length),d=f}try{o=e.fromBytes(d)}catch{throw new Error(`invalid private key: expected ui8a of size ${r}, got ${typeof c}`)}}if(t&&(o=e.create(o)),!e.isValidNot0(o))throw new Error("invalid private key: out of range [1..N-1]");return o}return i}function he(e,n={}){const{Fp:t,Fn:r}=ce("weierstrass",e,n),{h:i,n:c}=e;mt(n,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:o}=n;if(o&&(!t.is0(e.a)||typeof o.beta!="bigint"||typeof o.splitScalar!="function"))throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');function d(){if(!t.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function f(A,s,h){const{x:l,y:u}=s.toAffine(),w=t.toBytes(l);if(at("isCompressed",h),h){d();const y=!t.isOdd(u);return X(Mt(y),w)}else return X(Uint8Array.of(4),w,t.toBytes(u))}function v(A){pt(A);const s=t.BYTES,h=s+1,l=2*s+1,u=A.length,w=A[0],y=A.subarray(1);if(u===h&&(w===2||w===3)){const m=t.fromBytes(y);if(!t.isValid(m))throw new Error("bad point: is not on curve, wrong x");const g=x(m);let E;try{E=t.sqrt(g)}catch(N){const b=N instanceof Error?": "+N.message:"";throw new Error("bad point: is not on curve, sqrt error"+b)}d();const p=t.isOdd(E);return(w&1)===1!==p&&(E=t.neg(E)),{x:m,y:E}}else if(u===l&&w===4){const m=t.fromBytes(y.subarray(s*0,s*1)),g=t.fromBytes(y.subarray(s*1,s*2));if(!I(m,g))throw new Error("bad point: is not on curve");return{x:m,y:g}}else throw new Error(`bad point: got length ${u}, expected compressed=${h} or uncompressed=${l}`)}const a=n.toBytes||f,B=n.fromBytes||v,x=de(t,e.a,e.b);function I(A,s){const h=t.sqr(s),l=x(A);return t.eql(h,l)}if(!I(e.Gx,e.Gy))throw new Error("bad curve params: generator point");const L=t.mul(t.pow(e.a,st),ue),_=t.mul(t.sqr(e.b),BigInt(27));if(t.is0(t.add(L,_)))throw new Error("bad curve params: a or b");function K(A,s,h=!1){if(!t.isValid(s)||h&&t.is0(s))throw new Error(`bad point coordinate ${A}`);return s}function C(A){if(!(A instanceof S))throw new Error("ProjectivePoint expected")}const nt=yt((A,s)=>{const{px:h,py:l,pz:u}=A;if(t.eql(u,t.ONE))return{x:h,y:l};const w=A.is0();s==null&&(s=w?t.ONE:t.inv(u));const y=t.mul(h,s),m=t.mul(l,s),g=t.mul(u,s);if(w)return{x:t.ZERO,y:t.ZERO};if(!t.eql(g,t.ONE))throw new Error("invZ was invalid");return{x:y,y:m}}),W=yt(A=>{if(A.is0()){if(n.allowInfinityPoint&&!t.is0(A.py))return;throw new Error("bad point: ZERO")}const{x:s,y:h}=A.toAffine();if(!t.isValid(s)||!t.isValid(h))throw new Error("bad point: x or y not field elements");if(!I(s,h))throw new Error("bad point: equation left != right");if(!A.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function rt(A,s,h,l,u){return h=new S(t.mul(h.px,A),h.py,h.pz),s=J(l,s),h=J(u,h),s.add(h)}class S{constructor(s,h,l){this.px=K("x",s),this.py=K("y",h,!0),this.pz=K("z",l),Object.freeze(this)}static fromAffine(s){const{x:h,y:l}=s||{};if(!s||!t.isValid(h)||!t.isValid(l))throw new Error("invalid affine point");if(s instanceof S)throw new Error("projective point not allowed");return t.is0(h)&&t.is0(l)?S.ZERO:new S(h,l,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(s){return ne(S,"pz",s)}static fromBytes(s){return pt(s),S.fromHex(s)}static fromHex(s){const h=S.fromAffine(B(V("pointHex",s)));return h.assertValidity(),h}static fromPrivateKey(s){const h=Kt(r,n.allowedPrivateKeyLengths,n.wrapPrivateKey);return S.BASE.multiply(h(s))}static msm(s,h){return ae(S,r,s,h)}precompute(s=8,h=!0){return $.setWindowSize(this,s),h||this.multiply(st),this}_setWindowSize(s){this.precompute(s)}assertValidity(){W(this)}hasEvenY(){const{y:s}=this.toAffine();if(!t.isOdd)throw new Error("Field doesn't support isOdd");return!t.isOdd(s)}equals(s){C(s);const{px:h,py:l,pz:u}=this,{px:w,py:y,pz:m}=s,g=t.eql(t.mul(h,m),t.mul(w,u)),E=t.eql(t.mul(l,m),t.mul(y,u));return g&&E}negate(){return new S(this.px,t.neg(this.py),this.pz)}double(){const{a:s,b:h}=e,l=t.mul(h,st),{px:u,py:w,pz:y}=this;let m=t.ZERO,g=t.ZERO,E=t.ZERO,p=t.mul(u,u),Z=t.mul(w,w),N=t.mul(y,y),b=t.mul(u,w);return b=t.add(b,b),E=t.mul(u,y),E=t.add(E,E),m=t.mul(s,E),g=t.mul(l,N),g=t.add(m,g),m=t.sub(Z,g),g=t.add(Z,g),g=t.mul(m,g),m=t.mul(b,m),E=t.mul(l,E),N=t.mul(s,N),b=t.sub(p,N),b=t.mul(s,b),b=t.add(b,E),E=t.add(p,p),p=t.add(E,p),p=t.add(p,N),p=t.mul(p,b),g=t.add(g,p),N=t.mul(w,y),N=t.add(N,N),p=t.mul(N,b),m=t.sub(m,p),E=t.mul(N,Z),E=t.add(E,E),E=t.add(E,E),new S(m,g,E)}add(s){C(s);const{px:h,py:l,pz:u}=this,{px:w,py:y,pz:m}=s;let g=t.ZERO,E=t.ZERO,p=t.ZERO;const Z=e.a,N=t.mul(e.b,st);let b=t.mul(h,w),z=t.mul(l,y),R=t.mul(u,m),T=t.add(h,l),q=t.add(w,y);T=t.mul(T,q),q=t.add(b,z),T=t.sub(T,q),q=t.add(h,u);let j=t.add(w,m);return q=t.mul(q,j),j=t.add(b,R),q=t.sub(q,j),j=t.add(l,u),g=t.add(y,m),j=t.mul(j,g),g=t.add(z,R),j=t.sub(j,g),p=t.mul(Z,q),g=t.mul(N,R),p=t.add(g,p),g=t.sub(z,p),p=t.add(z,p),E=t.mul(g,p),z=t.add(b,b),z=t.add(z,b),R=t.mul(Z,R),q=t.mul(N,q),z=t.add(z,R),R=t.sub(b,R),R=t.mul(Z,R),q=t.add(q,R),b=t.mul(z,q),E=t.add(E,b),b=t.mul(j,q),g=t.mul(T,g),g=t.sub(g,b),b=t.mul(T,z),p=t.mul(j,p),p=t.add(p,b),new S(g,E,p)}subtract(s){return this.add(s.negate())}is0(){return this.equals(S.ZERO)}multiply(s){const{endo:h}=n;if(!r.isValidNot0(s))throw new Error("invalid scalar: out of range");let l,u;const w=y=>$.wNAFCached(this,y,S.normalizeZ);if(h){const{k1neg:y,k1:m,k2neg:g,k2:E}=h.splitScalar(s),{p,f:Z}=w(m),{p:N,f:b}=w(E);u=Z.add(b),l=rt(h.beta,p,N,y,g)}else{const{p:y,f:m}=w(s);l=y,u=m}return S.normalizeZ([l,u])[0]}multiplyUnsafe(s){const{endo:h}=n,l=this;if(!r.isValid(s))throw new Error("invalid scalar: out of range");if(s===tt||l.is0())return S.ZERO;if(s===et)return l;if($.hasPrecomputes(this))return this.multiply(s);if(h){const{k1neg:u,k1:w,k2neg:y,k2:m}=h.splitScalar(s),{p1:g,p2:E}=se(S,l,w,m);return rt(h.beta,g,E,u,y)}else return $.wNAFCachedUnsafe(l,s)}multiplyAndAddUnsafe(s,h,l){const u=this.multiplyUnsafe(h).add(s.multiplyUnsafe(l));return u.is0()?void 0:u}toAffine(s){return nt(this,s)}isTorsionFree(){const{isTorsionFree:s}=n;return i===et?!0:s?s(S,this):$.wNAFCachedUnsafe(this,c).is0()}clearCofactor(){const{clearCofactor:s}=n;return i===et?this:s?s(S,this):this.multiplyUnsafe(i)}toBytes(s=!0){return at("isCompressed",s),this.assertValidity(),a(S,this,s)}toRawBytes(s=!0){return this.toBytes(s)}toHex(s=!0){return wt(this.toBytes(s))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}}S.BASE=new S(e.Gx,e.Gy,t.ONE),S.ZERO=new S(t.ZERO,t.ONE,t.ZERO),S.Fp=t,S.Fn=r;const ot=r.BITS,$=ie(S,n.endo?Math.ceil(ot/2):ot);return S}function Mt(e){return Uint8Array.of(e?2:3)}function we(e,n,t={}){mt(n,{hash:"function"},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const r=n.randomBytes||kt,i=n.hmac||((l,...u)=>Vt(n.hash,l,X(...u))),{Fp:c,Fn:o}=e,{ORDER:d,BITS:f}=o;function v(l){const u=d>>et;return l>u}function a(l){return v(l)?o.neg(l):l}function B(l,u){if(!o.isValidNot0(u))throw new Error(`invalid signature ${l}: out of range 1..CURVE.n`)}class x{constructor(u,w,y){B("r",u),B("s",w),this.r=u,this.s=w,y!=null&&(this.recovery=y),Object.freeze(this)}static fromCompact(u){const w=o.BYTES,y=V("compactSignature",u,w*2);return new x(o.fromBytes(y.subarray(0,w)),o.fromBytes(y.subarray(w,w*2)))}static fromDER(u){const{r:w,s:y}=Y.toSig(V("DER",u));return new x(w,y)}assertValidity(){}addRecoveryBit(u){return new x(this.r,this.s,u)}recoverPublicKey(u){const w=c.ORDER,{r:y,s:m,recovery:g}=this;if(g==null||![0,1,2,3].includes(g))throw new Error("recovery id invalid");if(d*fe<w&&g>1)throw new Error("recovery id is ambiguous for h>1 curve");const p=g===2||g===3?y+d:y;if(!c.isValid(p))throw new Error("recovery id 2 or 3 invalid");const Z=c.toBytes(p),N=e.fromHex(X(Mt((g&1)===0),Z)),b=o.inv(p),z=W(V("msgHash",u)),R=o.create(-z*b),T=o.create(m*b),q=e.BASE.multiplyUnsafe(R).add(N.multiplyUnsafe(T));if(q.is0())throw new Error("point at infinify");return q.assertValidity(),q}hasHighS(){return v(this.s)}normalizeS(){return this.hasHighS()?new x(this.r,o.neg(this.s),this.recovery):this}toBytes(u){if(u==="compact")return X(o.toBytes(this.r),o.toBytes(this.s));if(u==="der")return Ut(Y.hexFromSig(this));throw new Error("invalid format")}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return wt(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return wt(this.toBytes("compact"))}}const I=Kt(o,t.allowedPrivateKeyLengths,t.wrapPrivateKey),L={isValidPrivateKey(l){try{return I(l),!0}catch{return!1}},normPrivateKeyToScalar:I,randomPrivateKey:()=>{const l=d;return ee(r(Tt(l)),l)},precompute(l=8,u=e.BASE){return u.precompute(l,!1)}};function _(l,u=!0){return e.fromPrivateKey(l).toBytes(u)}function K(l){if(typeof l=="bigint")return!1;if(l instanceof e)return!0;const w=V("key",l).length,y=c.BYTES,m=y+1,g=2*y+1;if(!(t.allowedPrivateKeyLengths||o.BYTES===m))return w===m||w===g}function C(l,u,w=!0){if(K(l)===!0)throw new Error("first arg must be private key");if(K(u)===!1)throw new Error("second arg must be public key");return e.fromHex(u).multiply(I(l)).toBytes(w)}const nt=n.bits2int||function(l){if(l.length>8192)throw new Error("input is too large");const u=lt(l),w=l.length*8-f;return w>0?u>>BigInt(w):u},W=n.bits2int_modN||function(l){return o.create(nt(l))},rt=ct(f);function S(l){return Yt("num < 2^"+f,l,tt,rt),o.toBytes(l)}function ot(l,u,w=$){if(["recovered","canonical"].some(T=>T in w))throw new Error("sign() legacy options not supported");const{hash:y}=n;let{lowS:m,prehash:g,extraEntropy:E}=w;m==null&&(m=!0),l=V("msgHash",l),St(w),g&&(l=V("prehashed msgHash",y(l)));const p=W(l),Z=I(u),N=[S(Z),S(p)];if(E!=null&&E!==!1){const T=E===!0?r(c.BYTES):E;N.push(V("extraEntropy",T))}const b=X(...N),z=p;function R(T){const q=nt(T);if(!o.isValidNot0(q))return;const j=o.inv(q),Q=e.BASE.multiply(q).toAffine(),G=o.create(Q.x);if(G===tt)return;const U=o.create(j*o.create(z+G*Z));if(U===tt)return;let ft=(Q.x===G?0:2)|Number(Q.y&et),F=U;return m&&v(U)&&(F=a(U),ft^=1),new x(G,F,ft)}return{seed:b,k2sig:R}}const $={lowS:n.lowS,prehash:!1},A={lowS:n.lowS,prehash:!1};function s(l,u,w=$){const{seed:y,k2sig:m}=ot(l,u,w);return Ct(n.hash.outputLen,o.BYTES,i)(y,m)}e.BASE.precompute(8);function h(l,u,w,y=A){const m=l;u=V("msgHash",u),w=V("publicKey",w),St(y);const{lowS:g,prehash:E,format:p}=y;if("strict"in y)throw new Error("options.strict was renamed to lowS");if(p!==void 0&&!["compact","der","js"].includes(p))throw new Error('format must be "compact", "der" or "js"');const Z=typeof m=="string"||Dt(m),N=!Z&&!p&&typeof m=="object"&&m!==null&&typeof m.r=="bigint"&&typeof m.s=="bigint";if(!Z&&!N)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let b,z;try{if(N)if(p===void 0||p==="js")b=new x(m.r,m.s);else throw new Error("invalid format");if(Z){try{p!=="compact"&&(b=x.fromDER(m))}catch(F){if(!(F instanceof Y.Err))throw F}!b&&p!=="der"&&(b=x.fromCompact(m))}z=e.fromHex(w)}catch{return!1}if(!b||g&&b.hasHighS())return!1;E&&(u=n.hash(u));const{r:R,s:T}=b,q=W(u),j=o.inv(T),Q=o.create(q*j),G=o.create(R*j),U=e.BASE.multiplyUnsafe(Q).add(z.multiplyUnsafe(G));return U.is0()?!1:o.create(U.x)===R}return Object.freeze({getPublicKey:_,getSharedSecret:C,sign:s,verify:h,utils:L,Point:e,Signature:x})}function me(e){const n={a:e.a,b:e.b,p:e.Fp.ORDER,n:e.n,h:e.h,Gx:e.Gx,Gy:e.Gy},t=e.Fp,r=gt(n.n,e.nBitLength),i={Fp:t,Fn:r,allowedPrivateKeyLengths:e.allowedPrivateKeyLengths,allowInfinityPoint:e.allowInfinityPoint,endo:e.endo,wrapPrivateKey:e.wrapPrivateKey,isTorsionFree:e.isTorsionFree,clearCofactor:e.clearCofactor,fromBytes:e.fromBytes,toBytes:e.toBytes};return{CURVE:n,curveOpts:i}}function ge(e){const{CURVE:n,curveOpts:t}=me(e),r={hash:e.hash,hmac:e.hmac,randomBytes:e.randomBytes,lowS:e.lowS,bits2int:e.bits2int,bits2int_modN:e.bits2int_modN};return{CURVE:n,curveOpts:t,ecdsaOpts:r}}function ye(e,n){return Object.assign({},n,{ProjectivePoint:n.Point,CURVE:e})}function pe(e){const{CURVE:n,curveOpts:t,ecdsaOpts:r}=ge(e),i=he(n,t),c=we(i,r,t);return ye(e,c)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Se(e,n){const t=r=>pe({...e,hash:r});return{...t(n),create:t}}export{gt as F,ce as _,Be as a,Se as c,xe as i,H as m,ne as n,ae as p,ie as w};
