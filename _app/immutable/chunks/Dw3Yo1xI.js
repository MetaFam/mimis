import{G as ht}from"./Eljbaigh.js";import{c as mt}from"./JvJJwFQ_.js";import{ar as Ae,as as wt}from"./BeTPpg_-.js";import{h as yt}from"./CjBKZqzI.js";function gt(e,o){for(var t=0;t<o.length;t++){const s=o[t];if(typeof s!="string"&&!Array.isArray(s)){for(const c in s)if(c!=="default"&&!(c in e)){const a=Object.getOwnPropertyDescriptor(s,c);a&&Object.defineProperty(e,c,a.get?a:{enumerable:!0,get:()=>s[c]})}}}return Object.freeze(Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}))}var Je={};const bt=ht(mt);var je={},De={},he={},W={};Object.defineProperty(W,"__esModule",{value:!0});W.isNegativeLE=void 0;W.mod=de;W.pow=vt;W.pow2=pt;W.invert=Ze;W.tonelliShanks=rt;W.FpSqrt=ot;W.validateField=xt;W.FpPow=Ve;W.FpInvertBatch=st;W.FpDiv=qt;W.FpLegendre=Ce;W.FpIsSquare=Nt;W.nLength=Ke;W.Field=$e;W.FpSqrtOdd=Tt;W.FpSqrtEven=Ot;W.hashToPrivateScalar=Rt;W.getFieldBytesLength=Ye;W.getMinHashLength=it;W.mapHashToField=It;/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ue=Ae,le=BigInt(0),ee=BigInt(1),Ee=BigInt(2),Et=BigInt(3),Fe=BigInt(4),et=BigInt(5),tt=BigInt(8);function de(e,o){const t=e%o;return t>=le?t:o+t}function vt(e,o,t){return Ve($e(t),e,o)}function pt(e,o,t){let s=e;for(;o-- >le;)s*=s,s%=t;return s}function Ze(e,o){if(e===le)throw new Error("invert: expected non-zero number");if(o<=le)throw new Error("invert: expected positive modulus, got "+o);let t=de(e,o),s=o,c=le,a=ee;for(;t!==le;){const l=s/t,f=s%t,E=c-a*l;s=t,t=f,c=a,a=E}if(s!==ee)throw new Error("invert: does not exist");return de(c,o)}function nt(e,o){const t=(e.ORDER+ee)/Fe,s=e.pow(o,t);if(!e.eql(e.sqr(s),o))throw new Error("Cannot find square root");return s}function Bt(e,o){const t=(e.ORDER-et)/tt,s=e.mul(o,Ee),c=e.pow(s,t),a=e.mul(o,c),m=e.mul(e.mul(a,Ee),c),l=e.mul(a,e.sub(m,e.ONE));if(!e.eql(e.sqr(l),o))throw new Error("Cannot find square root");return l}function rt(e){if(e<BigInt(3))throw new Error("sqrt is not defined for small field");let o=e-ee,t=0;for(;o%Ee===le;)o/=Ee,t++;let s=Ee;const c=$e(e);for(;Ce(c,s)===1;)if(s++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(t===1)return nt;let a=c.pow(s,o);const m=(o+ee)/Ee;return function(f,E){if(f.is0(E))return E;if(Ce(f,E)!==1)throw new Error("Cannot find square root");let i=t,B=f.mul(f.ONE,a),M=f.pow(E,o),I=f.pow(E,m);for(;!f.eql(M,f.ONE);){if(f.is0(M))return f.ZERO;let H=1,K=f.sqr(M);for(;!f.eql(K,f.ONE);)if(H++,K=f.sqr(K),H===i)throw new Error("Cannot find square root");const te=ee<<BigInt(i-H-1),ie=f.pow(B,te);i=H,B=f.sqr(ie),M=f.mul(M,B),I=f.mul(I,ie)}return I}}function ot(e){return e%Fe===Et?nt:e%tt===et?Bt:rt(e)}const _t=(e,o)=>(de(e,o)&ee)===ee;W.isNegativeLE=_t;const St=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function xt(e){const o={ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"},t=St.reduce((s,c)=>(s[c]="function",s),o);return(0,ue._validateObject)(e,t),e}function Ve(e,o,t){if(t<le)throw new Error("invalid exponent, negatives unsupported");if(t===le)return e.ONE;if(t===ee)return o;let s=e.ONE,c=o;for(;t>le;)t&ee&&(s=e.mul(s,c)),c=e.sqr(c),t>>=ee;return s}function st(e,o,t=!1){const s=new Array(o.length).fill(t?e.ZERO:void 0),c=o.reduce((m,l,f)=>e.is0(l)?m:(s[f]=m,e.mul(m,l)),e.ONE),a=e.inv(c);return o.reduceRight((m,l,f)=>e.is0(l)?m:(s[f]=e.mul(m,s[f]),e.mul(m,l)),a),s}function qt(e,o,t){return e.mul(o,typeof t=="bigint"?Ze(t,e.ORDER):e.inv(t))}function Ce(e,o){const t=(e.ORDER-ee)/Ee,s=e.pow(o,t),c=e.eql(s,e.ONE),a=e.eql(s,e.ZERO),m=e.eql(s,e.neg(e.ONE));if(!c&&!a&&!m)throw new Error("invalid Legendre symbol result");return c?1:a?0:-1}function Nt(e,o){return Ce(e,o)===1}function Ke(e,o){o!==void 0&&(0,ue.anumber)(o);const t=o!==void 0?o:e.toString(2).length,s=Math.ceil(t/8);return{nBitLength:t,nByteLength:s}}function $e(e,o,t=!1,s={}){if(e<=le)throw new Error("invalid field: expected ORDER > 0, got "+e);let c,a;if(typeof o=="object"&&o!=null){if(s.sqrt||t)throw new Error("cannot specify opts in two arguments");const i=o;i.BITS&&(c=i.BITS),i.sqrt&&(a=i.sqrt),typeof i.isLE=="boolean"&&(t=i.isLE)}else typeof o=="number"&&(c=o),s.sqrt&&(a=s.sqrt);const{nBitLength:m,nByteLength:l}=Ke(e,c);if(l>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let f;const E=Object.freeze({ORDER:e,isLE:t,BITS:m,BYTES:l,MASK:(0,ue.bitMask)(m),ZERO:le,ONE:ee,create:i=>de(i,e),isValid:i=>{if(typeof i!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof i);return le<=i&&i<e},is0:i=>i===le,isValidNot0:i=>!E.is0(i)&&E.isValid(i),isOdd:i=>(i&ee)===ee,neg:i=>de(-i,e),eql:(i,B)=>i===B,sqr:i=>de(i*i,e),add:(i,B)=>de(i+B,e),sub:(i,B)=>de(i-B,e),mul:(i,B)=>de(i*B,e),pow:(i,B)=>Ve(E,i,B),div:(i,B)=>de(i*Ze(B,e),e),sqrN:i=>i*i,addN:(i,B)=>i+B,subN:(i,B)=>i-B,mulN:(i,B)=>i*B,inv:i=>Ze(i,e),sqrt:a||(i=>(f||(f=ot(e)),f(E,i))),toBytes:i=>t?(0,ue.numberToBytesLE)(i,l):(0,ue.numberToBytesBE)(i,l),fromBytes:i=>{if(i.length!==l)throw new Error("Field.fromBytes: expected "+l+" bytes, got "+i.length);return t?(0,ue.bytesToNumberLE)(i):(0,ue.bytesToNumberBE)(i)},invertBatch:i=>st(E,i),cmov:(i,B,M)=>M?B:i});return Object.freeze(E)}function Tt(e,o){if(!e.isOdd)throw new Error("Field doesn't have isOdd");const t=e.sqrt(o);return e.isOdd(t)?t:e.neg(t)}function Ot(e,o){if(!e.isOdd)throw new Error("Field doesn't have isOdd");const t=e.sqrt(o);return e.isOdd(t)?e.neg(t):t}function Rt(e,o,t=!1){e=(0,ue.ensureBytes)("privateHash",e);const s=e.length,c=Ke(o).nByteLength+8;if(c<24||s<c||s>1024)throw new Error("hashToPrivateScalar: expected "+c+"-1024 bytes of input, got "+s);const a=t?(0,ue.bytesToNumberLE)(e):(0,ue.bytesToNumberBE)(e);return de(a,o-ee)+ee}function Ye(e){if(typeof e!="bigint")throw new Error("field order must be bigint");const o=e.toString(2).length;return Math.ceil(o/8)}function it(e){const o=Ye(e);return o+Math.ceil(o/2)}function It(e,o,t=!1){const s=e.length,c=Ye(o),a=it(o);if(s<16||s<a||s>1024)throw new Error("expected "+a+"-1024 bytes of input, got "+s);const m=t?(0,ue.bytesToNumberLE)(e):(0,ue.bytesToNumberBE)(e),l=de(m,o-ee)+ee;return t?(0,ue.numberToBytesLE)(l,c):(0,ue.numberToBytesBE)(l,c)}Object.defineProperty(he,"__esModule",{value:!0});he.negateCt=Me;he.normalizeZ=At;he.wNAF=Lt;he.mulEndoUnsafe=Mt;he.pippenger=Zt;he.precomputeMSMUnsafe=Ct;he.validateBasic=jt;he._createCurveFields=kt;/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Oe=Ae,Re=W,xe=BigInt(0),ve=BigInt(1);function Me(e,o){const t=o.negate();return e?t:o}function At(e,o,t){const s=o==="pz"?m=>m.pz:m=>m.ez,c=(0,Re.FpInvertBatch)(e.Fp,t.map(s));return t.map((m,l)=>m.toAffine(c[l])).map(e.fromAffine)}function Ge(e,o){if(!Number.isSafeInteger(e)||e<=0||e>o)throw new Error("invalid window size, expected [1.."+o+"], got W="+e)}function Pe(e,o){Ge(e,o);const t=Math.ceil(o/e)+1,s=2**(e-1),c=2**e,a=(0,Oe.bitMask)(e),m=BigInt(e);return{windows:t,windowSize:s,mask:a,maxNumber:c,shiftBy:m}}function We(e,o,t){const{windowSize:s,mask:c,maxNumber:a,shiftBy:m}=t;let l=Number(e&c),f=e>>m;l>s&&(l-=a,f+=ve);const E=o*s,i=E+Math.abs(l)-1,B=l===0,M=l<0,I=o%2!==0;return{nextN:f,offset:i,isZero:B,isNeg:M,isNegF:I,offsetF:E}}function at(e,o){if(!Array.isArray(e))throw new Error("array expected");e.forEach((t,s)=>{if(!(t instanceof o))throw new Error("invalid point at index "+s)})}function ct(e,o){if(!Array.isArray(e))throw new Error("array of scalars expected");e.forEach((t,s)=>{if(!o.isValid(t))throw new Error("invalid scalar at index "+s)})}const ze=new WeakMap,ft=new WeakMap;function Ue(e){return ft.get(e)||1}function Xe(e){if(e!==xe)throw new Error("invalid wNAF")}function Lt(e,o){return{constTimeNegate:Me,hasPrecomputes(t){return Ue(t)!==1},unsafeLadder(t,s,c=e.ZERO){let a=t;for(;s>xe;)s&ve&&(c=c.add(a)),a=a.double(),s>>=ve;return c},precomputeWindow(t,s){const{windows:c,windowSize:a}=Pe(s,o),m=[];let l=t,f=l;for(let E=0;E<c;E++){f=l,m.push(f);for(let i=1;i<a;i++)f=f.add(l),m.push(f);l=f.double()}return m},wNAF(t,s,c){let a=e.ZERO,m=e.BASE;const l=Pe(t,o);for(let f=0;f<l.windows;f++){const{nextN:E,offset:i,isZero:B,isNeg:M,isNegF:I,offsetF:H}=We(c,f,l);c=E,B?m=m.add(Me(I,s[H])):a=a.add(Me(M,s[i]))}return Xe(c),{p:a,f:m}},wNAFUnsafe(t,s,c,a=e.ZERO){const m=Pe(t,o);for(let l=0;l<m.windows&&c!==xe;l++){const{nextN:f,offset:E,isZero:i,isNeg:B}=We(c,l,m);if(c=f,!i){const M=s[E];a=a.add(B?M.negate():M)}}return Xe(c),a},getPrecomputes(t,s,c){let a=ze.get(s);return a||(a=this.precomputeWindow(s,t),t!==1&&(typeof c=="function"&&(a=c(a)),ze.set(s,a))),a},wNAFCached(t,s,c){const a=Ue(t);return this.wNAF(a,this.getPrecomputes(a,t,c),s)},wNAFCachedUnsafe(t,s,c,a){const m=Ue(t);return m===1?this.unsafeLadder(t,s,a):this.wNAFUnsafe(m,this.getPrecomputes(m,t,c),s,a)},setWindowSize(t,s){Ge(s,o),ft.set(t,s),ze.delete(t)}}}function Mt(e,o,t,s){let c=o,a=e.ZERO,m=e.ZERO;for(;t>xe||s>xe;)t&ve&&(a=a.add(c)),s&ve&&(m=m.add(c)),c=c.double(),t>>=ve,s>>=ve;return{p1:a,p2:m}}function Zt(e,o,t,s){at(t,e),ct(s,o);const c=t.length,a=s.length;if(c!==a)throw new Error("arrays of points and scalars must have equal length");const m=e.ZERO,l=(0,Oe.bitLen)(BigInt(c));let f=1;l>12?f=l-3:l>4?f=l-2:l>0&&(f=2);const E=(0,Oe.bitMask)(f),i=new Array(Number(E)+1).fill(m),B=Math.floor((o.BITS-1)/f)*f;let M=m;for(let I=B;I>=0;I-=f){i.fill(m);for(let K=0;K<a;K++){const te=s[K],ie=Number(te>>BigInt(I)&E);i[ie]=i[ie].add(t[K])}let H=m;for(let K=i.length-1,te=m;K>0;K--)te=te.add(i[K]),H=H.add(te);if(M=M.add(H),I!==0)for(let K=0;K<f;K++)M=M.double()}return M}function Ct(e,o,t,s){Ge(s,o.BITS),at(t,e);const c=e.ZERO,a=2**s-1,m=Math.ceil(o.BITS/s),l=(0,Oe.bitMask)(s),f=t.map(E=>{const i=[];for(let B=0,M=E;B<a;B++)i.push(M),M=M.add(E);return i});return E=>{if(ct(E,o),E.length>t.length)throw new Error("array of scalars must be smaller than array of points");let i=c;for(let B=0;B<m;B++){if(i!==c)for(let I=0;I<s;I++)i=i.double();const M=BigInt(m*s-(B+1)*s);for(let I=0;I<E.length;I++){const H=E[I],K=Number(H>>M&l);K&&(i=i.add(f[I][K-1]))}}return i}}function jt(e){return(0,Re.validateField)(e.Fp),(0,Oe.validateObject)(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...(0,Re.nLength)(e.n,e.nBitLength),...e,p:e.Fp.ORDER})}function Qe(e,o){if(o){if(o.ORDER!==e)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return(0,Re.validateField)(o),o}else return(0,Re.Field)(e)}function kt(e,o,t={}){if(!o||typeof o!="object")throw new Error(`expected valid ${e} CURVE object`);for(const l of["p","n","h"]){const f=o[l];if(!(typeof f=="bigint"&&f>xe))throw new Error(`CURVE.${l} must be positive bigint`)}const s=Qe(o.p,t.Fp),c=Qe(o.n,t.Fn),m=["Gx","Gy","a",e==="weierstrass"?"b":"d"];for(const l of m)if(!s.isValid(o[l]))throw new Error(`CURVE.${l} must be valid field element of CURVE.Fp`);return{Fp:s,Fn:c}}(function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.DER=e.DERErr=void 0,e._legacyHelperEquat=M,e._legacyHelperNormPriv=I,e.weierstrassN=H,e.weierstrassPoints=K,e.ecdsa=ie,e.weierstrass=Ne,e.SWUFpSqrtRatio=Be,e.mapToCurveSimpleSWU=Le;/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const o=yt,t=Ae,s=he,c=W;function a(n){n.lowS!==void 0&&(0,t.abool)("lowS",n.lowS),n.prehash!==void 0&&(0,t.abool)("prehash",n.prehash)}class m extends Error{constructor(w=""){super(w)}}e.DERErr=m,e.DER={Err:m,_tlv:{encode:(n,w)=>{const{Err:r}=e.DER;if(n<0||n>256)throw new r("tlv.encode: wrong tag");if(w.length&1)throw new r("tlv.encode: unpadded data");const S=w.length/2,L=(0,t.numberToHexUnpadded)(S);if(L.length/2&128)throw new r("tlv.encode: long form length too big");const P=S>127?(0,t.numberToHexUnpadded)(L.length/2|128):"";return(0,t.numberToHexUnpadded)(n)+P+L+w},decode(n,w){const{Err:r}=e.DER;let S=0;if(n<0||n>256)throw new r("tlv.encode: wrong tag");if(w.length<2||w[S++]!==n)throw new r("tlv.decode: wrong tlv");const L=w[S++],P=!!(L&128);let b=0;if(!P)b=L;else{const d=L&127;if(!d)throw new r("tlv.decode(long): indefinite length not supported");if(d>4)throw new r("tlv.decode(long): byte length is too big");const N=w.subarray(S,S+d);if(N.length!==d)throw new r("tlv.decode: length bytes not complete");if(N[0]===0)throw new r("tlv.decode(long): zero leftmost byte");for(const Z of N)b=b<<8|Z;if(S+=d,b<128)throw new r("tlv.decode(long): not minimal encoding")}const y=w.subarray(S,S+b);if(y.length!==b)throw new r("tlv.decode: wrong value length");return{v:y,l:w.subarray(S+b)}}},_int:{encode(n){const{Err:w}=e.DER;if(n<l)throw new w("integer: negative integers are not allowed");let r=(0,t.numberToHexUnpadded)(n);if(Number.parseInt(r[0],16)&8&&(r="00"+r),r.length&1)throw new w("unexpected DER parsing assertion: unpadded hex");return r},decode(n){const{Err:w}=e.DER;if(n[0]&128)throw new w("invalid signature integer: negative");if(n[0]===0&&!(n[1]&128))throw new w("invalid signature integer: unnecessary leading zero");return(0,t.bytesToNumberBE)(n)}},toSig(n){const{Err:w,_int:r,_tlv:S}=e.DER,L=(0,t.ensureBytes)("signature",n),{v:P,l:b}=S.decode(48,L);if(b.length)throw new w("invalid signature: left bytes after parsing");const{v:y,l:d}=S.decode(2,P),{v:N,l:Z}=S.decode(2,d);if(Z.length)throw new w("invalid signature: left bytes after parsing");return{r:r.decode(y),s:r.decode(N)}},hexFromSig(n){const{_tlv:w,_int:r}=e.DER,S=w.encode(2,r.encode(n.r)),L=w.encode(2,r.encode(n.s)),P=S+L;return w.encode(48,P)}};const l=BigInt(0),f=BigInt(1),E=BigInt(2),i=BigInt(3),B=BigInt(4);function M(n,w,r){function S(L){const P=n.sqr(L),b=n.mul(P,L);return n.add(n.add(b,n.mul(L,w)),r)}return S}function I(n,w,r){const{BYTES:S}=n;function L(P){let b;if(typeof P=="bigint")b=P;else{let y=(0,t.ensureBytes)("private key",P);if(w){if(!w.includes(y.length*2))throw new Error("invalid private key");const d=new Uint8Array(S);d.set(y,d.length-y.length),y=d}try{b=n.fromBytes(y)}catch{throw new Error(`invalid private key: expected ui8a of size ${S}, got ${typeof P}`)}}if(r&&(b=n.create(b)),!n.isValidNot0(b))throw new Error("invalid private key: out of range [1..N-1]");return b}return L}function H(n,w={}){const{Fp:r,Fn:S}=(0,s._createCurveFields)("weierstrass",n,w),{h:L,n:P}=n;(0,t._validateObject)(w,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:b}=w;if(b&&(!r.is0(n.a)||typeof b.beta!="bigint"||typeof b.splitScalar!="function"))throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');function y(){if(!r.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function d(V,u,v){const{x:h,y:g}=u.toAffine(),p=r.toBytes(h);if((0,t.abool)("isCompressed",v),v){y();const q=!r.isOdd(g);return(0,t.concatBytes)(te(q),p)}else return(0,t.concatBytes)(Uint8Array.of(4),p,r.toBytes(g))}function N(V){(0,t.abytes)(V);const u=r.BYTES,v=u+1,h=2*u+1,g=V.length,p=V[0],q=V.subarray(1);if(g===v&&(p===2||p===3)){const _=r.fromBytes(q);if(!r.isValid(_))throw new Error("bad point: is not on curve, wrong x");const x=z(_);let R;try{R=r.sqrt(x)}catch(G){const A=G instanceof Error?": "+G.message:"";throw new Error("bad point: is not on curve, sqrt error"+A)}y();const T=r.isOdd(R);return(p&1)===1!==T&&(R=r.neg(R)),{x:_,y:R}}else if(g===h&&p===4){const _=r.fromBytes(q.subarray(u*0,u*1)),x=r.fromBytes(q.subarray(u*1,u*2));if(!D(_,x))throw new Error("bad point: is not on curve");return{x:_,y:x}}else throw new Error(`bad point: got length ${g}, expected compressed=${v} or uncompressed=${h}`)}const Z=w.toBytes||d,X=w.fromBytes||N,z=M(r,n.a,n.b);function D(V,u){const v=r.sqr(u),h=z(V);return r.eql(v,h)}if(!D(n.Gx,n.Gy))throw new Error("bad curve params: generator point");const k=r.mul(r.pow(n.a,i),B),J=r.mul(r.sqr(n.b),BigInt(27));if(r.is0(r.add(k,J)))throw new Error("bad curve params: a or b");function j(V,u,v=!1){if(!r.isValid(u)||v&&r.is0(u))throw new Error(`bad point coordinate ${V}`);return u}function C(V){if(!(V instanceof O))throw new Error("ProjectivePoint expected")}const U=(0,t.memoized)((V,u)=>{const{px:v,py:h,pz:g}=V;if(r.eql(g,r.ONE))return{x:v,y:h};const p=V.is0();u==null&&(u=p?r.ONE:r.inv(g));const q=r.mul(v,u),_=r.mul(h,u),x=r.mul(g,u);if(p)return{x:r.ZERO,y:r.ZERO};if(!r.eql(x,r.ONE))throw new Error("invZ was invalid");return{x:q,y:_}}),$=(0,t.memoized)(V=>{if(V.is0()){if(w.allowInfinityPoint&&!r.is0(V.py))return;throw new Error("bad point: ZERO")}const{x:u,y:v}=V.toAffine();if(!r.isValid(u)||!r.isValid(v))throw new Error("bad point: x or y not field elements");if(!D(u,v))throw new Error("bad point: equation left != right");if(!V.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function Y(V,u,v,h,g){return v=new O(r.mul(v.px,V),v.py,v.pz),u=(0,s.negateCt)(h,u),v=(0,s.negateCt)(g,v),u.add(v)}class O{constructor(u,v,h){this.px=j("x",u),this.py=j("y",v,!0),this.pz=j("z",h),Object.freeze(this)}static fromAffine(u){const{x:v,y:h}=u||{};if(!u||!r.isValid(v)||!r.isValid(h))throw new Error("invalid affine point");if(u instanceof O)throw new Error("projective point not allowed");return r.is0(v)&&r.is0(h)?O.ZERO:new O(v,h,r.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(u){return(0,s.normalizeZ)(O,"pz",u)}static fromBytes(u){return(0,t.abytes)(u),O.fromHex(u)}static fromHex(u){const v=O.fromAffine(X((0,t.ensureBytes)("pointHex",u)));return v.assertValidity(),v}static fromPrivateKey(u){const v=I(S,w.allowedPrivateKeyLengths,w.wrapPrivateKey);return O.BASE.multiply(v(u))}static msm(u,v){return(0,s.pippenger)(O,S,u,v)}precompute(u=8,v=!0){return ne.setWindowSize(this,u),v||this.multiply(i),this}_setWindowSize(u){this.precompute(u)}assertValidity(){$(this)}hasEvenY(){const{y:u}=this.toAffine();if(!r.isOdd)throw new Error("Field doesn't support isOdd");return!r.isOdd(u)}equals(u){C(u);const{px:v,py:h,pz:g}=this,{px:p,py:q,pz:_}=u,x=r.eql(r.mul(v,_),r.mul(p,g)),R=r.eql(r.mul(h,_),r.mul(q,g));return x&&R}negate(){return new O(this.px,r.neg(this.py),this.pz)}double(){const{a:u,b:v}=n,h=r.mul(v,i),{px:g,py:p,pz:q}=this;let _=r.ZERO,x=r.ZERO,R=r.ZERO,T=r.mul(g,g),F=r.mul(p,p),G=r.mul(q,q),A=r.mul(g,p);return A=r.add(A,A),R=r.mul(g,q),R=r.add(R,R),_=r.mul(u,R),x=r.mul(h,G),x=r.add(_,x),_=r.sub(F,x),x=r.add(F,x),x=r.mul(_,x),_=r.mul(A,_),R=r.mul(h,R),G=r.mul(u,G),A=r.sub(T,G),A=r.mul(u,A),A=r.add(A,R),R=r.add(T,T),T=r.add(R,T),T=r.add(T,G),T=r.mul(T,A),x=r.add(x,T),G=r.mul(p,q),G=r.add(G,G),T=r.mul(G,A),_=r.sub(_,T),R=r.mul(G,F),R=r.add(R,R),R=r.add(R,R),new O(_,x,R)}add(u){C(u);const{px:v,py:h,pz:g}=this,{px:p,py:q,pz:_}=u;let x=r.ZERO,R=r.ZERO,T=r.ZERO;const F=n.a,G=r.mul(n.b,i);let A=r.mul(v,p),re=r.mul(h,q),oe=r.mul(g,_),ae=r.add(v,h),Q=r.add(p,q);ae=r.mul(ae,Q),Q=r.add(A,re),ae=r.sub(ae,Q),Q=r.add(v,g);let ce=r.add(p,_);return Q=r.mul(Q,ce),ce=r.add(A,oe),Q=r.sub(Q,ce),ce=r.add(h,g),x=r.add(q,_),ce=r.mul(ce,x),x=r.add(re,oe),ce=r.sub(ce,x),T=r.mul(F,Q),x=r.mul(G,oe),T=r.add(x,T),x=r.sub(re,T),T=r.add(re,T),R=r.mul(x,T),re=r.add(A,A),re=r.add(re,A),oe=r.mul(F,oe),Q=r.mul(G,Q),re=r.add(re,oe),oe=r.sub(A,oe),oe=r.mul(F,oe),Q=r.add(Q,oe),A=r.mul(re,Q),R=r.add(R,A),A=r.mul(ce,Q),x=r.mul(ae,x),x=r.sub(x,A),A=r.mul(ae,re),T=r.mul(ce,T),T=r.add(T,A),new O(x,R,T)}subtract(u){return this.add(u.negate())}is0(){return this.equals(O.ZERO)}multiply(u){const{endo:v}=w;if(!S.isValidNot0(u))throw new Error("invalid scalar: out of range");let h,g;const p=q=>ne.wNAFCached(this,q,O.normalizeZ);if(v){const{k1neg:q,k1:_,k2neg:x,k2:R}=v.splitScalar(u),{p:T,f:F}=p(_),{p:G,f:A}=p(R);g=F.add(A),h=Y(v.beta,T,G,q,x)}else{const{p:q,f:_}=p(u);h=q,g=_}return O.normalizeZ([h,g])[0]}multiplyUnsafe(u){const{endo:v}=w,h=this;if(!S.isValid(u))throw new Error("invalid scalar: out of range");if(u===l||h.is0())return O.ZERO;if(u===f)return h;if(ne.hasPrecomputes(this))return this.multiply(u);if(v){const{k1neg:g,k1:p,k2neg:q,k2:_}=v.splitScalar(u),{p1:x,p2:R}=(0,s.mulEndoUnsafe)(O,h,p,_);return Y(v.beta,x,R,g,q)}else return ne.wNAFCachedUnsafe(h,u)}multiplyAndAddUnsafe(u,v,h){const g=this.multiplyUnsafe(v).add(u.multiplyUnsafe(h));return g.is0()?void 0:g}toAffine(u){return U(this,u)}isTorsionFree(){const{isTorsionFree:u}=w;return L===f?!0:u?u(O,this):ne.wNAFCachedUnsafe(this,P).is0()}clearCofactor(){const{clearCofactor:u}=w;return L===f?this:u?u(O,this):this.multiplyUnsafe(L)}toBytes(u=!0){return(0,t.abool)("isCompressed",u),this.assertValidity(),Z(O,this,u)}toRawBytes(u=!0){return this.toBytes(u)}toHex(u=!0){return(0,t.bytesToHex)(this.toBytes(u))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}}O.BASE=new O(n.Gx,n.Gy,r.ONE),O.ZERO=new O(r.ZERO,r.ONE,r.ZERO),O.Fp=r,O.Fn=S;const fe=S.BITS,ne=(0,s.wNAF)(O,w.endo?Math.ceil(fe/2):fe);return O}function K(n){const{CURVE:w,curveOpts:r}=me(n),S=H(w,r);return ge(n,S)}function te(n){return Uint8Array.of(n?2:3)}function ie(n,w,r={}){(0,t._validateObject)(w,{hash:"function"},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const S=w.randomBytes||t.randomBytes,L=w.hmac||((h,...g)=>(0,o.hmac)(w.hash,h,(0,t.concatBytes)(...g))),{Fp:P,Fn:b}=n,{ORDER:y,BITS:d}=b;function N(h){const g=y>>f;return h>g}function Z(h){return N(h)?b.neg(h):h}function X(h,g){if(!b.isValidNot0(g))throw new Error(`invalid signature ${h}: out of range 1..CURVE.n`)}class z{constructor(g,p,q){X("r",g),X("s",p),this.r=g,this.s=p,q!=null&&(this.recovery=q),Object.freeze(this)}static fromCompact(g){const p=b.BYTES,q=(0,t.ensureBytes)("compactSignature",g,p*2);return new z(b.fromBytes(q.subarray(0,p)),b.fromBytes(q.subarray(p,p*2)))}static fromDER(g){const{r:p,s:q}=e.DER.toSig((0,t.ensureBytes)("DER",g));return new z(p,q)}assertValidity(){}addRecoveryBit(g){return new z(this.r,this.s,g)}recoverPublicKey(g){const p=P.ORDER,{r:q,s:_,recovery:x}=this;if(x==null||![0,1,2,3].includes(x))throw new Error("recovery id invalid");if(y*E<p&&x>1)throw new Error("recovery id is ambiguous for h>1 curve");const T=x===2||x===3?q+y:q;if(!P.isValid(T))throw new Error("recovery id 2 or 3 invalid");const F=P.toBytes(T),G=n.fromHex((0,t.concatBytes)(te((x&1)===0),F)),A=b.inv(T),re=$((0,t.ensureBytes)("msgHash",g)),oe=b.create(-re*A),ae=b.create(_*A),Q=n.BASE.multiplyUnsafe(oe).add(G.multiplyUnsafe(ae));if(Q.is0())throw new Error("point at infinify");return Q.assertValidity(),Q}hasHighS(){return N(this.s)}normalizeS(){return this.hasHighS()?new z(this.r,b.neg(this.s),this.recovery):this}toBytes(g){if(g==="compact")return(0,t.concatBytes)(b.toBytes(this.r),b.toBytes(this.s));if(g==="der")return(0,t.hexToBytes)(e.DER.hexFromSig(this));throw new Error("invalid format")}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return(0,t.bytesToHex)(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return(0,t.bytesToHex)(this.toBytes("compact"))}}const D=I(b,r.allowedPrivateKeyLengths,r.wrapPrivateKey),k={isValidPrivateKey(h){try{return D(h),!0}catch{return!1}},normPrivateKeyToScalar:D,randomPrivateKey:()=>{const h=y;return(0,c.mapHashToField)(S((0,c.getMinHashLength)(h)),h)},precompute(h=8,g=n.BASE){return g.precompute(h,!1)}};function J(h,g=!0){return n.fromPrivateKey(h).toBytes(g)}function j(h){if(typeof h=="bigint")return!1;if(h instanceof n)return!0;const p=(0,t.ensureBytes)("key",h).length,q=P.BYTES,_=q+1,x=2*q+1;if(!(r.allowedPrivateKeyLengths||b.BYTES===_))return p===_||p===x}function C(h,g,p=!0){if(j(h)===!0)throw new Error("first arg must be private key");if(j(g)===!1)throw new Error("second arg must be public key");return n.fromHex(g).multiply(D(h)).toBytes(p)}const U=w.bits2int||function(h){if(h.length>8192)throw new Error("input is too large");const g=(0,t.bytesToNumberBE)(h),p=h.length*8-d;return p>0?g>>BigInt(p):g},$=w.bits2int_modN||function(h){return b.create(U(h))},Y=(0,t.bitMask)(d);function O(h){return(0,t.aInRange)("num < 2^"+d,h,l,Y),b.toBytes(h)}function fe(h,g,p=ne){if(["recovered","canonical"].some(ae=>ae in p))throw new Error("sign() legacy options not supported");const{hash:q}=w;let{lowS:_,prehash:x,extraEntropy:R}=p;_==null&&(_=!0),h=(0,t.ensureBytes)("msgHash",h),a(p),x&&(h=(0,t.ensureBytes)("prehashed msgHash",q(h)));const T=$(h),F=D(g),G=[O(F),O(T)];if(R!=null&&R!==!1){const ae=R===!0?S(P.BYTES):R;G.push((0,t.ensureBytes)("extraEntropy",ae))}const A=(0,t.concatBytes)(...G),re=T;function oe(ae){const Q=U(ae);if(!b.isValidNot0(Q))return;const ce=b.inv(Q),Te=n.BASE.multiply(Q).toAffine(),_e=b.create(Te.x);if(_e===l)return;const be=b.create(ce*b.create(re+_e*F));if(be===l)return;let ke=(Te.x===_e?0:2)|Number(Te.y&f),Se=be;return _&&N(be)&&(Se=Z(be),ke^=1),new z(_e,Se,ke)}return{seed:A,k2sig:oe}}const ne={lowS:w.lowS,prehash:!1},V={lowS:w.lowS,prehash:!1};function u(h,g,p=ne){const{seed:q,k2sig:_}=fe(h,g,p);return(0,t.createHmacDrbg)(w.hash.outputLen,b.BYTES,L)(q,_)}n.BASE.precompute(8);function v(h,g,p,q=V){const _=h;g=(0,t.ensureBytes)("msgHash",g),p=(0,t.ensureBytes)("publicKey",p),a(q);const{lowS:x,prehash:R,format:T}=q;if("strict"in q)throw new Error("options.strict was renamed to lowS");if(T!==void 0&&!["compact","der","js"].includes(T))throw new Error('format must be "compact", "der" or "js"');const F=typeof _=="string"||(0,t.isBytes)(_),G=!F&&!T&&typeof _=="object"&&_!==null&&typeof _.r=="bigint"&&typeof _.s=="bigint";if(!F&&!G)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let A,re;try{if(G)if(T===void 0||T==="js")A=new z(_.r,_.s);else throw new Error("invalid format");if(F){try{T!=="compact"&&(A=z.fromDER(_))}catch(Se){if(!(Se instanceof e.DER.Err))throw Se}!A&&T!=="der"&&(A=z.fromCompact(_))}re=n.fromHex(p)}catch{return!1}if(!A||x&&A.hasHighS())return!1;R&&(g=w.hash(g));const{r:oe,s:ae}=A,Q=$(g),ce=b.inv(ae),Te=b.create(Q*ce),_e=b.create(oe*ce),be=n.BASE.multiplyUnsafe(Te).add(re.multiplyUnsafe(_e));return be.is0()?!1:b.create(be.x)===oe}return Object.freeze({getPublicKey:J,getSharedSecret:C,sign:u,verify:v,utils:k,Point:n,Signature:z})}function me(n){const w={a:n.a,b:n.b,p:n.Fp.ORDER,n:n.n,h:n.h,Gx:n.Gx,Gy:n.Gy},r=n.Fp,S=(0,c.Field)(w.n,n.nBitLength),L={Fp:r,Fn:S,allowedPrivateKeyLengths:n.allowedPrivateKeyLengths,allowInfinityPoint:n.allowInfinityPoint,endo:n.endo,wrapPrivateKey:n.wrapPrivateKey,isTorsionFree:n.isTorsionFree,clearCofactor:n.clearCofactor,fromBytes:n.fromBytes,toBytes:n.toBytes};return{CURVE:w,curveOpts:L}}function ye(n){const{CURVE:w,curveOpts:r}=me(n),S={hash:n.hash,hmac:n.hmac,randomBytes:n.randomBytes,lowS:n.lowS,bits2int:n.bits2int,bits2int_modN:n.bits2int_modN};return{CURVE:w,curveOpts:r,ecdsaOpts:S}}function ge(n,w){const{Fp:r,Fn:S}=w;function L(y){return(0,t.inRange)(y,f,S.ORDER)}const P=M(r,n.a,n.b),b=I(S,n.allowedPrivateKeyLengths,n.wrapPrivateKey);return Object.assign({},{CURVE:n,Point:w,ProjectivePoint:w,normPrivateKeyToScalar:b,weierstrassEquation:P,isWithinCurveOrder:L})}function qe(n,w){return Object.assign({},w,{ProjectivePoint:w.Point,CURVE:n})}function Ne(n){const{CURVE:w,curveOpts:r,ecdsaOpts:S}=ye(n),L=H(w,r),P=ie(L,S,r);return qe(n,P)}function Be(n,w){const r=n.ORDER;let S=l;for(let k=r-f;k%E===l;k/=E)S+=f;const L=S,P=E<<L-f-f,b=P*E,y=(r-f)/b,d=(y-f)/E,N=b-f,Z=P,X=n.pow(w,y),z=n.pow(w,(y+f)/E);let D=(k,J)=>{let j=X,C=n.pow(J,N),U=n.sqr(C);U=n.mul(U,J);let $=n.mul(k,U);$=n.pow($,d),$=n.mul($,C),C=n.mul($,J),U=n.mul($,k);let Y=n.mul(U,C);$=n.pow(Y,Z);let O=n.eql($,n.ONE);C=n.mul(U,z),$=n.mul(Y,j),U=n.cmov(C,U,O),Y=n.cmov($,Y,O);for(let fe=L;fe>f;fe--){let ne=fe-E;ne=E<<ne-f;let V=n.pow(Y,ne);const u=n.eql(V,n.ONE);C=n.mul(U,j),j=n.mul(j,j),V=n.mul(Y,j),U=n.cmov(C,U,u),Y=n.cmov(V,Y,u)}return{isValid:O,value:U}};if(n.ORDER%B===i){const k=(n.ORDER-i)/B,J=n.sqrt(n.neg(w));D=(j,C)=>{let U=n.sqr(C);const $=n.mul(j,C);U=n.mul(U,$);let Y=n.pow(U,k);Y=n.mul(Y,$);const O=n.mul(Y,J),fe=n.mul(n.sqr(Y),C),ne=n.eql(fe,j);let V=n.cmov(O,Y,ne);return{isValid:ne,value:V}}}return D}function Le(n,w){(0,c.validateField)(n);const{A:r,B:S,Z:L}=w;if(!n.isValid(r)||!n.isValid(S)||!n.isValid(L))throw new Error("mapToCurveSimpleSWU: invalid opts");const P=Be(n,L);if(!n.isOdd)throw new Error("Field does not have .isOdd()");return b=>{let y,d,N,Z,X,z,D,k;y=n.sqr(b),y=n.mul(y,L),d=n.sqr(y),d=n.add(d,y),N=n.add(d,n.ONE),N=n.mul(N,S),Z=n.cmov(L,n.neg(d),!n.eql(d,n.ZERO)),Z=n.mul(Z,r),d=n.sqr(N),z=n.sqr(Z),X=n.mul(z,r),d=n.add(d,X),d=n.mul(d,N),z=n.mul(z,Z),X=n.mul(z,S),d=n.add(d,X),D=n.mul(y,N);const{isValid:J,value:j}=P(d,z);k=n.mul(y,b),k=n.mul(k,j),D=n.cmov(D,N,J),k=n.cmov(k,j,J);const C=n.isOdd(b)===n.isOdd(k);k=n.cmov(n.neg(k),k,C);const U=(0,c.FpInvertBatch)(n,[Z],!0)[0];return D=n.mul(D,U),{x:D,y:k}}}})(De);Object.defineProperty(je,"__esModule",{value:!0});je.getHash=zt;je.createCurve=Ut;/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Pt=De;function zt(e){return{hash:e}}function Ut(e,o){const t=s=>(0,Pt.weierstrass)({...e,hash:s});return{...t(o),create:t}}var pe={};Object.defineProperty(pe,"__esModule",{value:!0});pe.expand_message_xmd=lt;pe.expand_message_xof=dt;pe.hash_to_field=He;pe.isogenyMap=Vt;pe.createHasher=Kt;const se=Ae,ut=W,Ht=se.bytesToNumberBE;function we(e,o){if(Ie(e),Ie(o),e<0||e>=1<<8*o)throw new Error("invalid I2OSP input: "+e);const t=Array.from({length:o}).fill(0);for(let s=o-1;s>=0;s--)t[s]=e&255,e>>>=8;return new Uint8Array(t)}function Dt(e,o){const t=new Uint8Array(e.length);for(let s=0;s<e.length;s++)t[s]=e[s]^o[s];return t}function Ie(e){if(!Number.isSafeInteger(e))throw new Error("number expected")}function lt(e,o,t,s){(0,se.abytes)(e),(0,se.abytes)(o),Ie(t),o.length>255&&(o=s((0,se.concatBytes)((0,se.utf8ToBytes)("H2C-OVERSIZE-DST-"),o)));const{outputLen:c,blockLen:a}=s,m=Math.ceil(t/c);if(t>65535||m>255)throw new Error("expand_message_xmd: invalid lenInBytes");const l=(0,se.concatBytes)(o,we(o.length,1)),f=we(0,a),E=we(t,2),i=new Array(m),B=s((0,se.concatBytes)(f,e,E,we(0,1),l));i[0]=s((0,se.concatBytes)(B,we(1,1),l));for(let I=1;I<=m;I++){const H=[Dt(B,i[I-1]),we(I+1,1),l];i[I]=s((0,se.concatBytes)(...H))}return(0,se.concatBytes)(...i).slice(0,t)}function dt(e,o,t,s,c){if((0,se.abytes)(e),(0,se.abytes)(o),Ie(t),o.length>255){const a=Math.ceil(2*s/8);o=c.create({dkLen:a}).update((0,se.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(o).digest()}if(t>65535||o.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return c.create({dkLen:t}).update(e).update(we(t,2)).update(o).update(we(o.length,1)).digest()}function He(e,o,t){(0,se._validateObject)(t,{p:"bigint",m:"number",k:"number",hash:"function"});const{p:s,k:c,m:a,hash:m,expand:l,DST:f}=t;if(!(0,se.isBytes)(f)&&typeof f!="string")throw new Error("DST must be string or uint8array");if(!(0,se.isHash)(t.hash))throw new Error("expected valid hash");(0,se.abytes)(e),Ie(o);const E=typeof f=="string"?(0,se.utf8ToBytes)(f):f,i=s.toString(2).length,B=Math.ceil((i+c)/8),M=o*a*B;let I;if(l==="xmd")I=lt(e,E,M,m);else if(l==="xof")I=dt(e,E,M,c,m);else if(l==="_internal_pass")I=e;else throw new Error('expand must be "xmd" or "xof"');const H=new Array(o);for(let K=0;K<o;K++){const te=new Array(a);for(let ie=0;ie<a;ie++){const me=B*(ie+K*a),ye=I.subarray(me,me+B);te[ie]=(0,ut.mod)(Ht(ye),s)}H[K]=te}return H}function Vt(e,o){const t=o.map(s=>Array.from(s).reverse());return(s,c)=>{const[a,m,l,f]=t.map(B=>B.reduce((M,I)=>e.add(e.mul(M,s),I))),[E,i]=(0,ut.FpInvertBatch)(e,[m,f],!0);return s=e.mul(a,E),c=e.mul(c,e.mul(l,i)),{x:s,y:c}}}function Kt(e,o,t){if(typeof o!="function")throw new Error("mapToCurve() must be defined");function s(a){return e.fromAffine(o(a))}function c(a){const m=a.clearCofactor();return m.equals(e.ZERO)?e.ZERO:(m.assertValidity(),m)}return{defaults:t,hashToCurve(a,m){const l=t.DST?t.DST:{},f=Object.assign({},t,l,m),E=He(a,2,f),i=s(E[0]),B=s(E[1]);return c(i.add(B))},encodeToCurve(a,m){const l=t.encodeDST?t.encodeDST:{},f=Object.assign({},t,l,m),E=He(a,1,f);return c(s(E[0]))},mapToCurve(a){if(!Array.isArray(a))throw new Error("expected array of bigints");for(const m of a)if(typeof m!="bigint")throw new Error("expected array of bigints");return c(s(a))}}}(function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.encodeToCurve=e.hashToCurve=e.secp256k1_hasher=e.schnorr=e.secp256k1=void 0;/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const o=bt,t=wt,s=je,c=pe,a=W,m=De,l=Ae,f={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},E=BigInt(0),i=BigInt(1),B=BigInt(2),M=(y,d)=>(y+d/B)/d;function I(y){const d=f.p,N=BigInt(3),Z=BigInt(6),X=BigInt(11),z=BigInt(22),D=BigInt(23),k=BigInt(44),J=BigInt(88),j=y*y*y%d,C=j*j*y%d,U=(0,a.pow2)(C,N,d)*C%d,$=(0,a.pow2)(U,N,d)*C%d,Y=(0,a.pow2)($,B,d)*j%d,O=(0,a.pow2)(Y,X,d)*Y%d,fe=(0,a.pow2)(O,z,d)*O%d,ne=(0,a.pow2)(fe,k,d)*fe%d,V=(0,a.pow2)(ne,J,d)*ne%d,u=(0,a.pow2)(V,k,d)*fe%d,v=(0,a.pow2)(u,N,d)*C%d,h=(0,a.pow2)(v,D,d)*O%d,g=(0,a.pow2)(h,Z,d)*j%d,p=(0,a.pow2)(g,B,d);if(!H.eql(H.sqr(p),y))throw new Error("Cannot find square root");return p}const H=(0,a.Field)(f.p,void 0,void 0,{sqrt:I});e.secp256k1=(0,s.createCurve)({...f,Fp:H,lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:y=>{const d=f.n,N=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),Z=-i*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),X=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),z=N,D=BigInt("0x100000000000000000000000000000000"),k=M(z*y,d),J=M(-Z*y,d);let j=(0,a.mod)(y-k*N-J*X,d),C=(0,a.mod)(-k*Z-J*z,d);const U=j>D,$=C>D;if(U&&(j=d-j),$&&(C=d-C),j>D||C>D)throw new Error("splitScalar: Endomorphism failed, k="+y);return{k1neg:U,k1:j,k2neg:$,k2:C}}}},o.sha256);const K={};function te(y,...d){let N=K[y];if(N===void 0){const Z=(0,o.sha256)(Uint8Array.from(y,X=>X.charCodeAt(0)));N=(0,l.concatBytes)(Z,Z),K[y]=N}return(0,o.sha256)((0,l.concatBytes)(N,...d))}const ie=y=>y.toBytes(!0).slice(1),me=y=>(0,l.numberToBytesBE)(y,32),ye=y=>(0,a.mod)(y,f.p),ge=y=>(0,a.mod)(y,f.n),qe=e.secp256k1.Point,Ne=y=>y%B===E;function Be(y){let d=e.secp256k1.utils.normPrivateKeyToScalar(y),N=qe.fromPrivateKey(d);return{scalar:Ne(N.y)?d:ge(-d),bytes:ie(N)}}function Le(y){(0,l.aInRange)("x",y,i,f.p);const d=ye(y*y),N=ye(d*y+BigInt(7));let Z=I(N);Ne(Z)||(Z=ye(-Z));const X=qe.fromAffine({x:y,y:Z});return X.assertValidity(),X}const n=l.bytesToNumberBE;function w(...y){return ge(n(te("BIP0340/challenge",...y)))}function r(y){return Be(y).bytes}function S(y,d,N=(0,t.randomBytes)(32)){const Z=(0,l.ensureBytes)("message",y),{bytes:X,scalar:z}=Be(d),D=(0,l.ensureBytes)("auxRand",N,32),k=me(z^n(te("BIP0340/aux",D))),J=te("BIP0340/nonce",k,X,Z),j=ge(n(J));if(j===E)throw new Error("sign failed: k is zero");const{bytes:C,scalar:U}=Be(j),$=w(C,X,Z),Y=new Uint8Array(64);if(Y.set(C,0),Y.set(me(ge(U+$*z)),32),!L(Y,Z,X))throw new Error("sign: Invalid signature produced");return Y}function L(y,d,N){const Z=(0,l.ensureBytes)("signature",y,64),X=(0,l.ensureBytes)("message",d),z=(0,l.ensureBytes)("publicKey",N,32);try{const D=Le(n(z)),k=n(Z.subarray(0,32));if(!(0,l.inRange)(k,i,f.p))return!1;const J=n(Z.subarray(32,64));if(!(0,l.inRange)(J,i,f.n))return!1;const j=w(me(k),ie(D),X),C=qe.BASE.multiplyUnsafe(J).add(D.multiplyUnsafe(ge(-j))),{x:U,y:$}=C.toAffine();return!(C.is0()||!Ne($)||U!==k)}catch{return!1}}e.schnorr={getPublicKey:r,sign:S,verify:L,utils:{randomPrivateKey:e.secp256k1.utils.randomPrivateKey,lift_x:Le,pointToBytes:ie,numberToBytesBE:l.numberToBytesBE,bytesToNumberBE:l.bytesToNumberBE,taggedHash:te,mod:a.mod}};const P=(0,c.isogenyMap)(H,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(y=>y.map(d=>BigInt(d)))),b=(0,m.mapToCurveSimpleSWU)(H,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:H.create(BigInt("-11"))});e.secp256k1_hasher=(0,c.createHasher)(e.secp256k1.Point,y=>{const{x:d,y:N}=b(H.create(y[0]));return P(d,N)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:H.ORDER,m:1,k:128,expand:"xmd",hash:o.sha256}),e.hashToCurve=e.secp256k1_hasher.hashToCurve,e.encodeToCurve=e.secp256k1_hasher.encodeToCurve})(Je);const Xt=gt({__proto__:null},[Je]);export{Je as a,Xt as s};
