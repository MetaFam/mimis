import{h as d,i as m,a as S,b as w,c as v}from"./C1TpcBhl.js";import{s as A,S as I,a as U,b as O}from"./BEBaXJsP.js";/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const p=BigInt(0),l=BigInt(1);function z(t,e){if(typeof e!="boolean")throw new Error(t+" boolean expected, got "+e)}function T(t){const e=t.toString(16);return e.length&1?"0"+e:e}function E(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return t===""?p:BigInt("0x"+t)}function P(t){return E(w(t))}function R(t){return S(t),E(w(Uint8Array.from(t).reverse()))}function x(t,e){return d(t.toString(16).padStart(e*2,"0"))}function q(t,e){return x(t,e).reverse()}function D(t){return d(T(t))}function G(t,e,r){let o;if(typeof e=="string")try{o=d(e)}catch(n){throw new Error(t+" must be hex string or Uint8Array, cause: "+n)}else if(m(e))o=Uint8Array.from(e);else throw new Error(t+" must be hex string or Uint8Array");const i=o.length;if(typeof r=="number"&&i!==r)throw new Error(t+" of length "+r+" expected, got "+i);return o}function W(t,e){if(t.length!==e.length)return!1;let r=0;for(let o=0;o<t.length;o++)r|=t[o]^e[o];return r===0}const y=t=>typeof t=="bigint"&&p<=t;function H(t,e,r){return y(t)&&y(e)&&y(r)&&e<=t&&t<r}function C(t,e,r,o){if(!H(e,r,o))throw new Error("expected valid "+t+": "+r+" <= n < "+o+", got "+e)}function J(t){let e;for(e=0;t>p;t>>=l,e+=1);return e}function K(t,e){return t>>BigInt(e)&l}function L(t,e,r){return t|(r?l:p)<<BigInt(e)}const Q=t=>(l<<BigInt(t))-l;function X(t,e,r){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof r!="function")throw new Error("hmacFn must be a function");const o=s=>new Uint8Array(s),i=s=>Uint8Array.of(s);let n=o(t),u=o(t),a=0;const f=()=>{n.fill(1),u.fill(0),a=0},c=(...s)=>r(u,n,...s),h=(s=o(0))=>{u=c(i(0),s),n=c(),s.length!==0&&(u=c(i(1),s),n=c())},B=()=>{if(a++>=1e3)throw new Error("drbg: tried 1000 values");let s=0;const g=[];for(;s<e;){n=c();const b=n.slice();g.push(b),s+=n.length}return v(...g)};return(s,g)=>{f(),h(s);let b;for(;!(b=g(B()));)h();return f(),b}}const _={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||m(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function Y(t,e,r={}){const o=(i,n,u)=>{const a=_[n];if(typeof a!="function")throw new Error("invalid validator function");const f=t[i];if(!(u&&f===void 0)&&!a(f,t))throw new Error("param "+String(i)+" is invalid. Expected "+n+", got "+f)};for(const[i,n]of Object.entries(e))o(i,n,!1);for(const[i,n]of Object.entries(r))o(i,n,!0);return t}function Z(t){return typeof t=="function"&&Number.isSafeInteger(t.outputLen)}function tt(t,e,r={}){if(!t||typeof t!="object")throw new Error("expected valid options object");function o(i,n,u){const a=t[i];if(u&&a===void 0)return;const f=typeof a;if(f!==n||a===null)throw new Error(`param "${i}" is invalid: expected ${n}, got ${f}`)}Object.entries(e).forEach(([i,n])=>o(i,n,!1)),Object.entries(r).forEach(([i,n])=>o(i,n,!0))}const et=()=>{throw new Error("not implemented")};function nt(t){const e=new WeakMap;return(r,...o)=>{const i=e.get(r);if(i!==void 0)return i;const n=t(r,...o);return e.set(r,n),n}}const $=I,j=A,k=U,N=O,rt=Object.freeze(Object.defineProperty({__proto__:null,SHA224:k,SHA256:$,sha224:N,sha256:j},Symbol.toStringTag,{value:"Module"}));export{tt as _,x as a,Q as b,R as c,P as d,J as e,z as f,G as g,X as h,T as i,C as j,K as k,L as l,nt as m,q as n,W as o,E as p,H as q,Z as r,et as s,D as t,rt as u,Y as v,j as w};
