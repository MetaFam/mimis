import{a as G,H as J,b as X,t as D,c as R,d as S,e as F}from"./DSTOT4fw.js";/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const H=BigInt(0),x=BigInt(1);function q(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function A(t){if(!q(t))throw new Error("Uint8Array expected")}function mt(t,e){if(typeof e!="boolean")throw new Error(t+" boolean expected, got "+e)}function pt(t){const e=t.toString(16);return e.length&1?"0"+e:e}function O(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return t===""?H:BigInt("0x"+t)}const k=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",tt=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function M(t){if(A(t),k)return t.toHex();let e="";for(let o=0;o<t.length;o++)e+=tt[t[o]];return e}const w={_0:48,_9:57,A:65,F:70,a:97,f:102};function _(t){if(t>=w._0&&t<=w._9)return t-w._0;if(t>=w.A&&t<=w.F)return t-(w.A-10);if(t>=w.a&&t<=w.f)return t-(w.a-10)}function C(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);if(k)return Uint8Array.fromHex(t);const e=t.length,o=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(o);for(let i=0,s=0;i<o;i++,s+=2){const c=_(t.charCodeAt(s)),u=_(t.charCodeAt(s+1));if(c===void 0||u===void 0){const n=t[s]+t[s+1];throw new Error('hex string expected, got non-hex character "'+n+'" at index '+s)}r[i]=c*16+u}return r}function j(t){return O(M(t))}function z(t){return A(t),O(M(Uint8Array.from(t).reverse()))}function I(t,e){return C(t.toString(16).padStart(e*2,"0"))}function V(t,e){return I(t,e).reverse()}function Et(t,e,o){let r;if(typeof e=="string")try{r=C(e)}catch(s){throw new Error(t+" must be hex string or Uint8Array, cause: "+s)}else if(q(e))r=Uint8Array.from(e);else throw new Error(t+" must be hex string or Uint8Array");const i=r.length;if(typeof o=="number"&&i!==o)throw new Error(t+" of length "+o+" expected, got "+i);return r}function et(...t){let e=0;for(let r=0;r<t.length;r++){const i=t[r];A(i),e+=i.length}const o=new Uint8Array(e);for(let r=0,i=0;r<t.length;r++){const s=t[r];o.set(s,i),i+=s.length}return o}const v=t=>typeof t=="bigint"&&H<=t;function nt(t,e,o){return v(t)&&v(e)&&v(o)&&e<=t&&t<o}function vt(t,e,o,r){if(!nt(e,o,r))throw new Error("expected valid "+t+": "+o+" <= n < "+r+", got "+e)}function Bt(t){let e;for(e=0;t>H;t>>=x,e+=1);return e}const rt=t=>(x<<BigInt(t))-x,B=t=>new Uint8Array(t),L=t=>Uint8Array.from(t);function xt(t,e,o){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof o!="function")throw new Error("hmacFn must be a function");let r=B(t),i=B(t),s=0;const c=()=>{r.fill(1),i.fill(0),s=0},u=(...l)=>o(i,r,...l),n=(l=B(0))=>{i=u(L([0]),l),r=u(),l.length!==0&&(i=u(L([1]),l),r=u())},f=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let l=0;const h=[];for(;l<e;){r=u();const y=r.slice();h.push(y),l+=r.length}return et(...h)};return(l,h)=>{c(),n(l);let y;for(;!(y=h(f()));)n();return c(),y}}const ot={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||q(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function it(t,e,o={}){const r=(i,s,c)=>{const u=ot[s];if(typeof u!="function")throw new Error("invalid validator function");const n=t[i];if(!(c&&n===void 0)&&!u(n,t))throw new Error("param "+String(i)+" is invalid. Expected "+s+", got "+n)};for(const[i,s]of Object.entries(e))r(i,s,!1);for(const[i,s]of Object.entries(o))r(i,s,!0);return t}function Ht(t){const e=new WeakMap;return(o,...r)=>{const i=e.get(o);if(i!==void 0)return i;const s=t(o,...r);return e.set(o,s),s}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const d=BigInt(0),a=BigInt(1),b=BigInt(2),st=BigInt(3),Z=BigInt(4),$=BigInt(5),K=BigInt(8);function g(t,e){const o=t%e;return o>=d?o:e+o}function qt(t,e,o){let r=t;for(;e-- >d;)r*=r,r%=o;return r}function U(t,e){if(t===d)throw new Error("invert: expected non-zero number");if(e<=d)throw new Error("invert: expected positive modulus, got "+e);let o=g(t,e),r=e,i=d,s=a;for(;o!==d;){const u=r/o,n=r%o,f=i-s*u;r=o,o=n,i=s,s=f}if(r!==a)throw new Error("invert: does not exist");return g(i,e)}function Q(t,e){const o=(t.ORDER+a)/Z,r=t.pow(e,o);if(!t.eql(t.sqr(r),e))throw new Error("Cannot find square root");return r}function ct(t,e){const o=(t.ORDER-$)/K,r=t.mul(e,b),i=t.pow(r,o),s=t.mul(e,i),c=t.mul(t.mul(s,b),i),u=t.mul(s,t.sub(c,t.ONE));if(!t.eql(t.sqr(u),e))throw new Error("Cannot find square root");return u}function ut(t){if(t<BigInt(3))throw new Error("sqrt is not defined for small field");let e=t-a,o=0;for(;e%b===d;)e/=b,o++;let r=b;const i=gt(t);for(;T(i,r)===1;)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(o===1)return Q;let s=i.pow(r,e);const c=(e+a)/b;return function(n,f){if(n.is0(f))return f;if(T(n,f)!==1)throw new Error("Cannot find square root");let m=o,l=n.mul(n.ONE,s),h=n.pow(f,e),y=n.pow(f,c);for(;!n.eql(h,n.ONE);){if(n.is0(h))return n.ZERO;let p=1,E=n.sqr(h);for(;!n.eql(E,n.ONE);)if(p++,E=n.sqr(E),p===m)throw new Error("Cannot find square root");const W=a<<BigInt(m-p-1),N=n.pow(l,W);m=p,l=n.sqr(N),h=n.mul(h,l),y=n.mul(y,N)}return y}}function ft(t){return t%Z===st?Q:t%K===$?ct:ut(t)}const at=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function At(t){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},o=at.reduce((r,i)=>(r[i]="function",r),e);return it(t,o)}function lt(t,e,o){if(o<d)throw new Error("invalid exponent, negatives unsupported");if(o===d)return t.ONE;if(o===a)return e;let r=t.ONE,i=e;for(;o>d;)o&a&&(r=t.mul(r,i)),i=t.sqr(i),o>>=a;return r}function dt(t,e,o=!1){const r=new Array(e.length).fill(o?t.ZERO:void 0),i=e.reduce((c,u,n)=>t.is0(u)?c:(r[n]=c,t.mul(c,u)),t.ONE),s=t.inv(i);return e.reduceRight((c,u,n)=>t.is0(u)?c:(r[n]=t.mul(c,r[n]),t.mul(c,u)),s),r}function T(t,e){const o=(t.ORDER-a)/b,r=t.pow(e,o),i=t.eql(r,t.ONE),s=t.eql(r,t.ZERO),c=t.eql(r,t.neg(t.ONE));if(!i&&!s&&!c)throw new Error("invalid Legendre symbol result");return i?1:s?0:-1}function ht(t,e){e!==void 0&&G(e);const o=e!==void 0?e:t.toString(2).length,r=Math.ceil(o/8);return{nBitLength:o,nByteLength:r}}function gt(t,e,o=!1,r={}){if(t<=d)throw new Error("invalid field: expected ORDER > 0, got "+t);const{nBitLength:i,nByteLength:s}=ht(t,e);if(s>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let c;const u=Object.freeze({ORDER:t,isLE:o,BITS:i,BYTES:s,MASK:rt(i),ZERO:d,ONE:a,create:n=>g(n,t),isValid:n=>{if(typeof n!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof n);return d<=n&&n<t},is0:n=>n===d,isOdd:n=>(n&a)===a,neg:n=>g(-n,t),eql:(n,f)=>n===f,sqr:n=>g(n*n,t),add:(n,f)=>g(n+f,t),sub:(n,f)=>g(n-f,t),mul:(n,f)=>g(n*f,t),pow:(n,f)=>lt(u,n,f),div:(n,f)=>g(n*U(f,t),t),sqrN:n=>n*n,addN:(n,f)=>n+f,subN:(n,f)=>n-f,mulN:(n,f)=>n*f,inv:n=>U(n,t),sqrt:r.sqrt||(n=>(c||(c=ft(t)),c(u,n))),toBytes:n=>o?V(n,s):I(n,s),fromBytes:n=>{if(n.length!==s)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+n.length);return o?z(n):j(n)},invertBatch:n=>dt(u,n),cmov:(n,f,m)=>m?f:n});return Object.freeze(u)}function Y(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function wt(t){const e=Y(t);return e+Math.ceil(e/2)}function It(t,e,o=!1){const r=t.length,i=Y(e),s=wt(e);if(r<16||r<s||r>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+r);const c=o?z(t):j(t),u=g(c,e-a)+a;return o?V(u,i):I(u,i)}class P extends J{constructor(e,o){super(),this.finished=!1,this.destroyed=!1,X(e);const r=D(o);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const i=this.blockLen,s=new Uint8Array(i);s.set(r.length>i?e.create().update(r).digest():r);for(let c=0;c<s.length;c++)s[c]^=54;this.iHash.update(s),this.oHash=e.create();for(let c=0;c<s.length;c++)s[c]^=106;this.oHash.update(s),R(s)}update(e){return S(this),this.iHash.update(e),this}digestInto(e){S(this),F(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:o,iHash:r,finished:i,destroyed:s,blockLen:c,outputLen:u}=this;return e=e,e.finished=i,e.destroyed=s,e.blockLen=c,e.outputLen=u,e.oHash=o._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const yt=(t,e,o)=>new P(t,e).update(o).digest();yt.create=(t,e)=>new P(t,e);export{z as A,gt as F,it as a,Bt as b,rt as c,j as d,et as e,It as f,wt as g,vt as h,Et as i,C as j,q as k,xt as l,g as m,ht as n,dt as o,Ht as p,mt as q,M as r,nt as s,pt as t,I as u,At as v,U as w,yt as x,qt as y,V as z};
