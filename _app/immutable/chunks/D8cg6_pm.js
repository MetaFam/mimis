import{F as Ve,G as yt}from"./C1TpcBhl.js";import{c as bt,d as wt}from"./BEBaXJsP.js";function gt(e,o){for(var t=0;t<o.length;t++){const s=o[t];if(typeof s!="string"&&!Array.isArray(s)){for(const u in s)if(u!=="default"&&!(u in e)){const c=Object.getOwnPropertyDescriptor(s,u);c&&Object.defineProperty(e,u,c.get?c:{enumerable:!0,get:()=>s[u]})}}}return Object.freeze(Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}))}var et={};const Et=Ve(bt),ze=Ve(yt);var Ue={},Ke={};const Bt=Ve(wt);var Ne={};(function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.notImplemented=e.bitMask=e.utf8ToBytes=e.randomBytes=e.isBytes=e.hexToBytes=e.concatBytes=e.bytesToUtf8=e.bytesToHex=e.anumber=e.abytes=void 0,e.abool=c,e.numberToHexUnpadded=b,e.hexToNumber=m,e.bytesToNumberBE=d,e.bytesToNumberLE=p,e.numberToBytesBE=a,e.numberToBytesLE=_,e.numberToVarBytesBE=U,e.ensureBytes=j,e.equalBytes=V,e.inRange=F,e.aInRange=ee,e.bitLen=he,e.bitGet=ye,e.bitSet=be,e.createHmacDrbg=Be,e.validateObject=Te,e.isHash=n,e._validateObject=g,e.memoized=O;/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const o=ze;var t=ze;Object.defineProperty(e,"abytes",{enumerable:!0,get:function(){return t.abytes}}),Object.defineProperty(e,"anumber",{enumerable:!0,get:function(){return t.anumber}}),Object.defineProperty(e,"bytesToHex",{enumerable:!0,get:function(){return t.bytesToHex}}),Object.defineProperty(e,"bytesToUtf8",{enumerable:!0,get:function(){return t.bytesToUtf8}}),Object.defineProperty(e,"concatBytes",{enumerable:!0,get:function(){return t.concatBytes}}),Object.defineProperty(e,"hexToBytes",{enumerable:!0,get:function(){return t.hexToBytes}}),Object.defineProperty(e,"isBytes",{enumerable:!0,get:function(){return t.isBytes}}),Object.defineProperty(e,"randomBytes",{enumerable:!0,get:function(){return t.randomBytes}}),Object.defineProperty(e,"utf8ToBytes",{enumerable:!0,get:function(){return t.utf8ToBytes}});const s=BigInt(0),u=BigInt(1);function c(i,E){if(typeof E!="boolean")throw new Error(i+" boolean expected, got "+E)}function b(i){const E=i.toString(16);return E.length&1?"0"+E:E}function m(i){if(typeof i!="string")throw new Error("hex string expected, got "+typeof i);return i===""?s:BigInt("0x"+i)}function d(i){return m((0,o.bytesToHex)(i))}function p(i){return(0,o.abytes)(i),m((0,o.bytesToHex)(Uint8Array.from(i).reverse()))}function a(i,E){return(0,o.hexToBytes)(i.toString(16).padStart(E*2,"0"))}function _(i,E){return a(i,E).reverse()}function U(i){return(0,o.hexToBytes)(b(i))}function j(i,E,y){let l;if(typeof E=="string")try{l=(0,o.hexToBytes)(E)}catch(v){throw new Error(i+" must be hex string or Uint8Array, cause: "+v)}else if((0,o.isBytes)(E))l=Uint8Array.from(E);else throw new Error(i+" must be hex string or Uint8Array");const f=l.length;if(typeof y=="number"&&f!==y)throw new Error(i+" of length "+y+" expected, got "+f);return l}function V(i,E){if(i.length!==E.length)return!1;let y=0;for(let l=0;l<i.length;l++)y|=i[l]^E[l];return y===0}const $=i=>typeof i=="bigint"&&s<=i;function F(i,E,y){return $(i)&&$(E)&&$(y)&&E<=i&&i<y}function ee(i,E,y,l){if(!F(E,y,l))throw new Error("expected valid "+i+": "+y+" <= n < "+l+", got "+E)}function he(i){let E;for(E=0;i>s;i>>=u,E+=1);return E}function ye(i,E){return i>>BigInt(E)&u}function be(i,E,y){return i|(y?u:s)<<BigInt(E)}const Ee=i=>(u<<BigInt(i))-u;e.bitMask=Ee;function Be(i,E,y){if(typeof i!="number"||i<2)throw new Error("hashLen must be a number");if(typeof E!="number"||E<2)throw new Error("qByteLen must be a number");if(typeof y!="function")throw new Error("hmacFn must be a function");const l=N=>new Uint8Array(N),f=N=>Uint8Array.of(N);let v=l(i),R=l(i),z=0;const P=()=>{v.fill(1),R.fill(0),z=0},H=(...N)=>y(R,v,...N),Z=(N=l(0))=>{R=H(f(0),N),v=H(),N.length!==0&&(R=H(f(1),N),v=H())},J=()=>{if(z++>=1e3)throw new Error("drbg: tried 1000 values");let N=0;const C=[];for(;N<E;){v=H();const K=v.slice();C.push(K),N+=v.length}return(0,o.concatBytes)(...C)};return(N,C)=>{P(),Z(N);let K;for(;!(K=C(J()));)Z();return P(),K}}const we={bigint:i=>typeof i=="bigint",function:i=>typeof i=="function",boolean:i=>typeof i=="boolean",string:i=>typeof i=="string",stringOrUint8Array:i=>typeof i=="string"||(0,o.isBytes)(i),isSafeInteger:i=>Number.isSafeInteger(i),array:i=>Array.isArray(i),field:(i,E)=>E.Fp.isValid(i),hash:i=>typeof i=="function"&&Number.isSafeInteger(i.outputLen)};function Te(i,E,y={}){const l=(f,v,R)=>{const z=we[v];if(typeof z!="function")throw new Error("invalid validator function");const P=i[f];if(!(R&&P===void 0)&&!z(P,i))throw new Error("param "+String(f)+" is invalid. Expected "+v+", got "+P)};for(const[f,v]of Object.entries(E))l(f,v,!1);for(const[f,v]of Object.entries(y))l(f,v,!0);return i}function n(i){return typeof i=="function"&&Number.isSafeInteger(i.outputLen)}function g(i,E,y={}){if(!i||typeof i!="object")throw new Error("expected valid options object");function l(f,v,R){const z=i[f];if(R&&z===void 0)return;const P=typeof z;if(P!==v||z===null)throw new Error(`param "${f}" is invalid: expected ${v}, got ${P}`)}Object.entries(E).forEach(([f,v])=>l(f,v,!1)),Object.entries(y).forEach(([f,v])=>l(f,v,!0))}const r=()=>{throw new Error("not implemented")};e.notImplemented=r;function O(i){const E=new WeakMap;return(y,...l)=>{const f=E.get(y);if(f!==void 0)return f;const v=i(y,...l);return E.set(y,v),v}}})(Ne);var me={},X={};Object.defineProperty(X,"__esModule",{value:!0});X.isNegativeLE=void 0;X.mod=de;X.pow=pt;X.pow2=_t;X.invert=ke;X.tonelliShanks=st;X.FpSqrt=it;X.validateField=xt;X.FpPow=$e;X.FpInvertBatch=at;X.FpDiv=It;X.FpLegendre=Pe;X.FpIsSquare=Nt;X.nLength=Ge;X.Field=Ye;X.FpSqrtOdd=qt;X.FpSqrtEven=Rt;X.hashToPrivateScalar=At;X.getFieldBytesLength=We;X.getMinHashLength=ct;X.mapHashToField=jt;/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ue=Ne,le=BigInt(0),ne=BigInt(1),pe=BigInt(2),vt=BigInt(3),tt=BigInt(4),nt=BigInt(5),rt=BigInt(8);function de(e,o){const t=e%o;return t>=le?t:o+t}function pt(e,o,t){return $e(Ye(t),e,o)}function _t(e,o,t){let s=e;for(;o-- >le;)s*=s,s%=t;return s}function ke(e,o){if(e===le)throw new Error("invert: expected non-zero number");if(o<=le)throw new Error("invert: expected positive modulus, got "+o);let t=de(e,o),s=o,u=le,c=ne;for(;t!==le;){const m=s/t,d=s%t,p=u-c*m;s=t,t=d,u=c,c=p}if(s!==ne)throw new Error("invert: does not exist");return de(u,o)}function ot(e,o){const t=(e.ORDER+ne)/tt,s=e.pow(o,t);if(!e.eql(e.sqr(s),o))throw new Error("Cannot find square root");return s}function St(e,o){const t=(e.ORDER-nt)/rt,s=e.mul(o,pe),u=e.pow(s,t),c=e.mul(o,u),b=e.mul(e.mul(c,pe),u),m=e.mul(c,e.sub(b,e.ONE));if(!e.eql(e.sqr(m),o))throw new Error("Cannot find square root");return m}function st(e){if(e<BigInt(3))throw new Error("sqrt is not defined for small field");let o=e-ne,t=0;for(;o%pe===le;)o/=pe,t++;let s=pe;const u=Ye(e);for(;Pe(u,s)===1;)if(s++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(t===1)return ot;let c=u.pow(s,o);const b=(o+ne)/pe;return function(d,p){if(d.is0(p))return p;if(Pe(d,p)!==1)throw new Error("Cannot find square root");let a=t,_=d.mul(d.ONE,c),U=d.pow(p,o),j=d.pow(p,b);for(;!d.eql(U,d.ONE);){if(d.is0(U))return d.ZERO;let V=1,$=d.sqr(U);for(;!d.eql($,d.ONE);)if(V++,$=d.sqr($),V===a)throw new Error("Cannot find square root");const F=ne<<BigInt(a-V-1),ee=d.pow(_,F);a=V,_=d.sqr(ee),U=d.mul(U,_),j=d.mul(j,ee)}return j}}function it(e){return e%tt===vt?ot:e%rt===nt?St:st(e)}const Tt=(e,o)=>(de(e,o)&ne)===ne;X.isNegativeLE=Tt;const Ot=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function xt(e){const o={ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"},t=Ot.reduce((s,u)=>(s[u]="function",s),o);return(0,ue._validateObject)(e,t),e}function $e(e,o,t){if(t<le)throw new Error("invalid exponent, negatives unsupported");if(t===le)return e.ONE;if(t===ne)return o;let s=e.ONE,u=o;for(;t>le;)t&ne&&(s=e.mul(s,u)),u=e.sqr(u),t>>=ne;return s}function at(e,o,t=!1){const s=new Array(o.length).fill(t?e.ZERO:void 0),u=o.reduce((b,m,d)=>e.is0(m)?b:(s[d]=b,e.mul(b,m)),e.ONE),c=e.inv(u);return o.reduceRight((b,m,d)=>e.is0(m)?b:(s[d]=e.mul(b,s[d]),e.mul(b,m)),c),s}function It(e,o,t){return e.mul(o,typeof t=="bigint"?ke(t,e.ORDER):e.inv(t))}function Pe(e,o){const t=(e.ORDER-ne)/pe,s=e.pow(o,t),u=e.eql(s,e.ONE),c=e.eql(s,e.ZERO),b=e.eql(s,e.neg(e.ONE));if(!u&&!c&&!b)throw new Error("invalid Legendre symbol result");return u?1:c?0:-1}function Nt(e,o){return Pe(e,o)===1}function Ge(e,o){o!==void 0&&(0,ue.anumber)(o);const t=o!==void 0?o:e.toString(2).length,s=Math.ceil(t/8);return{nBitLength:t,nByteLength:s}}function Ye(e,o,t=!1,s={}){if(e<=le)throw new Error("invalid field: expected ORDER > 0, got "+e);let u,c;if(typeof o=="object"&&o!=null){if(s.sqrt||t)throw new Error("cannot specify opts in two arguments");const a=o;a.BITS&&(u=a.BITS),a.sqrt&&(c=a.sqrt),typeof a.isLE=="boolean"&&(t=a.isLE)}else typeof o=="number"&&(u=o),s.sqrt&&(c=s.sqrt);const{nBitLength:b,nByteLength:m}=Ge(e,u);if(m>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let d;const p=Object.freeze({ORDER:e,isLE:t,BITS:b,BYTES:m,MASK:(0,ue.bitMask)(b),ZERO:le,ONE:ne,create:a=>de(a,e),isValid:a=>{if(typeof a!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof a);return le<=a&&a<e},is0:a=>a===le,isValidNot0:a=>!p.is0(a)&&p.isValid(a),isOdd:a=>(a&ne)===ne,neg:a=>de(-a,e),eql:(a,_)=>a===_,sqr:a=>de(a*a,e),add:(a,_)=>de(a+_,e),sub:(a,_)=>de(a-_,e),mul:(a,_)=>de(a*_,e),pow:(a,_)=>$e(p,a,_),div:(a,_)=>de(a*ke(_,e),e),sqrN:a=>a*a,addN:(a,_)=>a+_,subN:(a,_)=>a-_,mulN:(a,_)=>a*_,inv:a=>ke(a,e),sqrt:c||(a=>(d||(d=it(e)),d(p,a))),toBytes:a=>t?(0,ue.numberToBytesLE)(a,m):(0,ue.numberToBytesBE)(a,m),fromBytes:a=>{if(a.length!==m)throw new Error("Field.fromBytes: expected "+m+" bytes, got "+a.length);return t?(0,ue.bytesToNumberLE)(a):(0,ue.bytesToNumberBE)(a)},invertBatch:a=>at(p,a),cmov:(a,_,U)=>U?_:a});return Object.freeze(p)}function qt(e,o){if(!e.isOdd)throw new Error("Field doesn't have isOdd");const t=e.sqrt(o);return e.isOdd(t)?t:e.neg(t)}function Rt(e,o){if(!e.isOdd)throw new Error("Field doesn't have isOdd");const t=e.sqrt(o);return e.isOdd(t)?e.neg(t):t}function At(e,o,t=!1){e=(0,ue.ensureBytes)("privateHash",e);const s=e.length,u=Ge(o).nByteLength+8;if(u<24||s<u||s>1024)throw new Error("hashToPrivateScalar: expected "+u+"-1024 bytes of input, got "+s);const c=t?(0,ue.bytesToNumberLE)(e):(0,ue.bytesToNumberBE)(e);return de(c,o-ne)+ne}function We(e){if(typeof e!="bigint")throw new Error("field order must be bigint");const o=e.toString(2).length;return Math.ceil(o/8)}function ct(e){const o=We(e);return o+Math.ceil(o/2)}function jt(e,o,t=!1){const s=e.length,u=We(o),c=ct(o);if(s<16||s<c||s>1024)throw new Error("expected "+c+"-1024 bytes of input, got "+s);const b=t?(0,ue.bytesToNumberLE)(e):(0,ue.bytesToNumberBE)(e),m=de(b,o-ne)+ne;return t?(0,ue.numberToBytesLE)(m,u):(0,ue.numberToBytesBE)(m,u)}Object.defineProperty(me,"__esModule",{value:!0});me.negateCt=Le;me.normalizeZ=Lt;me.wNAF=kt;me.mulEndoUnsafe=Pt;me.pippenger=Ut;me.precomputeMSMUnsafe=Mt;me.validateBasic=Ht;me._createCurveFields=Zt;/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Re=Ne,Ae=X,Ie=BigInt(0),_e=BigInt(1);function Le(e,o){const t=o.negate();return e?t:o}function Lt(e,o,t){const s=o==="pz"?b=>b.pz:b=>b.ez,u=(0,Ae.FpInvertBatch)(e.Fp,t.map(s));return t.map((b,m)=>b.toAffine(u[m])).map(e.fromAffine)}function Xe(e,o){if(!Number.isSafeInteger(e)||e<=0||e>o)throw new Error("invalid window size, expected [1.."+o+"], got W="+e)}function He(e,o){Xe(e,o);const t=Math.ceil(o/e)+1,s=2**(e-1),u=2**e,c=(0,Re.bitMask)(e),b=BigInt(e);return{windows:t,windowSize:s,mask:c,maxNumber:u,shiftBy:b}}function Qe(e,o,t){const{windowSize:s,mask:u,maxNumber:c,shiftBy:b}=t;let m=Number(e&u),d=e>>b;m>s&&(m-=c,d+=_e);const p=o*s,a=p+Math.abs(m)-1,_=m===0,U=m<0,j=o%2!==0;return{nextN:d,offset:a,isZero:_,isNeg:U,isNegF:j,offsetF:p}}function ft(e,o){if(!Array.isArray(e))throw new Error("array expected");e.forEach((t,s)=>{if(!(t instanceof o))throw new Error("invalid point at index "+s)})}function ut(e,o){if(!Array.isArray(e))throw new Error("array of scalars expected");e.forEach((t,s)=>{if(!o.isValid(t))throw new Error("invalid scalar at index "+s)})}const Ze=new WeakMap,lt=new WeakMap;function Ce(e){return lt.get(e)||1}function Je(e){if(e!==Ie)throw new Error("invalid wNAF")}function kt(e,o){return{constTimeNegate:Le,hasPrecomputes(t){return Ce(t)!==1},unsafeLadder(t,s,u=e.ZERO){let c=t;for(;s>Ie;)s&_e&&(u=u.add(c)),c=c.double(),s>>=_e;return u},precomputeWindow(t,s){const{windows:u,windowSize:c}=He(s,o),b=[];let m=t,d=m;for(let p=0;p<u;p++){d=m,b.push(d);for(let a=1;a<c;a++)d=d.add(m),b.push(d);m=d.double()}return b},wNAF(t,s,u){let c=e.ZERO,b=e.BASE;const m=He(t,o);for(let d=0;d<m.windows;d++){const{nextN:p,offset:a,isZero:_,isNeg:U,isNegF:j,offsetF:V}=Qe(u,d,m);u=p,_?b=b.add(Le(j,s[V])):c=c.add(Le(U,s[a]))}return Je(u),{p:c,f:b}},wNAFUnsafe(t,s,u,c=e.ZERO){const b=He(t,o);for(let m=0;m<b.windows&&u!==Ie;m++){const{nextN:d,offset:p,isZero:a,isNeg:_}=Qe(u,m,b);if(u=d,!a){const U=s[p];c=c.add(_?U.negate():U)}}return Je(u),c},getPrecomputes(t,s,u){let c=Ze.get(s);return c||(c=this.precomputeWindow(s,t),t!==1&&(typeof u=="function"&&(c=u(c)),Ze.set(s,c))),c},wNAFCached(t,s,u){const c=Ce(t);return this.wNAF(c,this.getPrecomputes(c,t,u),s)},wNAFCachedUnsafe(t,s,u,c){const b=Ce(t);return b===1?this.unsafeLadder(t,s,c):this.wNAFUnsafe(b,this.getPrecomputes(b,t,u),s,c)},setWindowSize(t,s){Xe(s,o),lt.set(t,s),Ze.delete(t)}}}function Pt(e,o,t,s){let u=o,c=e.ZERO,b=e.ZERO;for(;t>Ie||s>Ie;)t&_e&&(c=c.add(u)),s&_e&&(b=b.add(u)),u=u.double(),t>>=_e,s>>=_e;return{p1:c,p2:b}}function Ut(e,o,t,s){ft(t,e),ut(s,o);const u=t.length,c=s.length;if(u!==c)throw new Error("arrays of points and scalars must have equal length");const b=e.ZERO,m=(0,Re.bitLen)(BigInt(u));let d=1;m>12?d=m-3:m>4?d=m-2:m>0&&(d=2);const p=(0,Re.bitMask)(d),a=new Array(Number(p)+1).fill(b),_=Math.floor((o.BITS-1)/d)*d;let U=b;for(let j=_;j>=0;j-=d){a.fill(b);for(let $=0;$<c;$++){const F=s[$],ee=Number(F>>BigInt(j)&p);a[ee]=a[ee].add(t[$])}let V=b;for(let $=a.length-1,F=b;$>0;$--)F=F.add(a[$]),V=V.add(F);if(U=U.add(V),j!==0)for(let $=0;$<d;$++)U=U.double()}return U}function Mt(e,o,t,s){Xe(s,o.BITS),ft(t,e);const u=e.ZERO,c=2**s-1,b=Math.ceil(o.BITS/s),m=(0,Re.bitMask)(s),d=t.map(p=>{const a=[];for(let _=0,U=p;_<c;_++)a.push(U),U=U.add(p);return a});return p=>{if(ut(p,o),p.length>t.length)throw new Error("array of scalars must be smaller than array of points");let a=u;for(let _=0;_<b;_++){if(a!==u)for(let j=0;j<s;j++)a=a.double();const U=BigInt(b*s-(_+1)*s);for(let j=0;j<p.length;j++){const V=p[j],$=Number(V>>U&m);$&&(a=a.add(d[j][$-1]))}}return a}}function Ht(e){return(0,Ae.validateField)(e.Fp),(0,Re.validateObject)(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...(0,Ae.nLength)(e.n,e.nBitLength),...e,p:e.Fp.ORDER})}function Fe(e,o){if(o){if(o.ORDER!==e)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return(0,Ae.validateField)(o),o}else return(0,Ae.Field)(e)}function Zt(e,o,t={}){if(!o||typeof o!="object")throw new Error(`expected valid ${e} CURVE object`);for(const m of["p","n","h"]){const d=o[m];if(!(typeof d=="bigint"&&d>Ie))throw new Error(`CURVE.${m} must be positive bigint`)}const s=Fe(o.p,t.Fp),u=Fe(o.n,t.Fn),b=["Gx","Gy","a",e==="weierstrass"?"b":"d"];for(const m of b)if(!s.isValid(o[m]))throw new Error(`CURVE.${m} must be valid field element of CURVE.Fp`);return{Fp:s,Fn:u}}(function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.DER=e.DERErr=void 0,e._legacyHelperEquat=U,e._legacyHelperNormPriv=j,e.weierstrassN=V,e.weierstrassPoints=$,e.ecdsa=ee,e.weierstrass=Be,e.SWUFpSqrtRatio=we,e.mapToCurveSimpleSWU=Te;/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const o=Bt,t=Ne,s=me,u=X;function c(n){n.lowS!==void 0&&(0,t.abool)("lowS",n.lowS),n.prehash!==void 0&&(0,t.abool)("prehash",n.prehash)}class b extends Error{constructor(g=""){super(g)}}e.DERErr=b,e.DER={Err:b,_tlv:{encode:(n,g)=>{const{Err:r}=e.DER;if(n<0||n>256)throw new r("tlv.encode: wrong tag");if(g.length&1)throw new r("tlv.encode: unpadded data");const O=g.length/2,i=(0,t.numberToHexUnpadded)(O);if(i.length/2&128)throw new r("tlv.encode: long form length too big");const E=O>127?(0,t.numberToHexUnpadded)(i.length/2|128):"";return(0,t.numberToHexUnpadded)(n)+E+i+g},decode(n,g){const{Err:r}=e.DER;let O=0;if(n<0||n>256)throw new r("tlv.encode: wrong tag");if(g.length<2||g[O++]!==n)throw new r("tlv.decode: wrong tlv");const i=g[O++],E=!!(i&128);let y=0;if(!E)y=i;else{const f=i&127;if(!f)throw new r("tlv.decode(long): indefinite length not supported");if(f>4)throw new r("tlv.decode(long): byte length is too big");const v=g.subarray(O,O+f);if(v.length!==f)throw new r("tlv.decode: length bytes not complete");if(v[0]===0)throw new r("tlv.decode(long): zero leftmost byte");for(const R of v)y=y<<8|R;if(O+=f,y<128)throw new r("tlv.decode(long): not minimal encoding")}const l=g.subarray(O,O+y);if(l.length!==y)throw new r("tlv.decode: wrong value length");return{v:l,l:g.subarray(O+y)}}},_int:{encode(n){const{Err:g}=e.DER;if(n<m)throw new g("integer: negative integers are not allowed");let r=(0,t.numberToHexUnpadded)(n);if(Number.parseInt(r[0],16)&8&&(r="00"+r),r.length&1)throw new g("unexpected DER parsing assertion: unpadded hex");return r},decode(n){const{Err:g}=e.DER;if(n[0]&128)throw new g("invalid signature integer: negative");if(n[0]===0&&!(n[1]&128))throw new g("invalid signature integer: unnecessary leading zero");return(0,t.bytesToNumberBE)(n)}},toSig(n){const{Err:g,_int:r,_tlv:O}=e.DER,i=(0,t.ensureBytes)("signature",n),{v:E,l:y}=O.decode(48,i);if(y.length)throw new g("invalid signature: left bytes after parsing");const{v:l,l:f}=O.decode(2,E),{v,l:R}=O.decode(2,f);if(R.length)throw new g("invalid signature: left bytes after parsing");return{r:r.decode(l),s:r.decode(v)}},hexFromSig(n){const{_tlv:g,_int:r}=e.DER,O=g.encode(2,r.encode(n.r)),i=g.encode(2,r.encode(n.s)),E=O+i;return g.encode(48,E)}};const m=BigInt(0),d=BigInt(1),p=BigInt(2),a=BigInt(3),_=BigInt(4);function U(n,g,r){function O(i){const E=n.sqr(i),y=n.mul(E,i);return n.add(n.add(y,n.mul(i,g)),r)}return O}function j(n,g,r){const{BYTES:O}=n;function i(E){let y;if(typeof E=="bigint")y=E;else{let l=(0,t.ensureBytes)("private key",E);if(g){if(!g.includes(l.length*2))throw new Error("invalid private key");const f=new Uint8Array(O);f.set(l,f.length-l.length),l=f}try{y=n.fromBytes(l)}catch{throw new Error(`invalid private key: expected ui8a of size ${O}, got ${typeof E}`)}}if(r&&(y=n.create(y)),!n.isValidNot0(y))throw new Error("invalid private key: out of range [1..N-1]");return y}return i}function V(n,g={}){const{Fp:r,Fn:O}=(0,s._createCurveFields)("weierstrass",n,g),{h:i,n:E}=n;(0,t._validateObject)(g,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:y}=g;if(y&&(!r.is0(n.a)||typeof y.beta!="bigint"||typeof y.splitScalar!="function"))throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');function l(){if(!r.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function f(G,h,S){const{x:w,y:B}=h.toAffine(),T=r.toBytes(w);if((0,t.abool)("isCompressed",S),S){l();const q=!r.isOdd(B);return(0,t.concatBytes)(F(q),T)}else return(0,t.concatBytes)(Uint8Array.of(4),T,r.toBytes(B))}function v(G){(0,t.abytes)(G);const h=r.BYTES,S=h+1,w=2*h+1,B=G.length,T=G[0],q=G.subarray(1);if(B===S&&(T===2||T===3)){const x=r.fromBytes(q);if(!r.isValid(x))throw new Error("bad point: is not on curve, wrong x");const I=P(x);let k;try{k=r.sqrt(I)}catch(W){const M=W instanceof Error?": "+W.message:"";throw new Error("bad point: is not on curve, sqrt error"+M)}l();const A=r.isOdd(k);return(T&1)===1!==A&&(k=r.neg(k)),{x,y:k}}else if(B===w&&T===4){const x=r.fromBytes(q.subarray(h*0,h*1)),I=r.fromBytes(q.subarray(h*1,h*2));if(!H(x,I))throw new Error("bad point: is not on curve");return{x,y:I}}else throw new Error(`bad point: got length ${B}, expected compressed=${S} or uncompressed=${w}`)}const R=g.toBytes||f,z=g.fromBytes||v,P=U(r,n.a,n.b);function H(G,h){const S=r.sqr(h),w=P(G);return r.eql(S,w)}if(!H(n.Gx,n.Gy))throw new Error("bad curve params: generator point");const Z=r.mul(r.pow(n.a,a),_),J=r.mul(r.sqr(n.b),BigInt(27));if(r.is0(r.add(Z,J)))throw new Error("bad curve params: a or b");function D(G,h,S=!1){if(!r.isValid(h)||S&&r.is0(h))throw new Error(`bad point coordinate ${G}`);return h}function N(G){if(!(G instanceof L))throw new Error("ProjectivePoint expected")}const C=(0,t.memoized)((G,h)=>{const{px:S,py:w,pz:B}=G;if(r.eql(B,r.ONE))return{x:S,y:w};const T=G.is0();h==null&&(h=T?r.ONE:r.inv(B));const q=r.mul(S,h),x=r.mul(w,h),I=r.mul(B,h);if(T)return{x:r.ZERO,y:r.ZERO};if(!r.eql(I,r.ONE))throw new Error("invZ was invalid");return{x:q,y:x}}),K=(0,t.memoized)(G=>{if(G.is0()){if(g.allowInfinityPoint&&!r.is0(G.py))return;throw new Error("bad point: ZERO")}const{x:h,y:S}=G.toAffine();if(!r.isValid(h)||!r.isValid(S))throw new Error("bad point: x or y not field elements");if(!H(h,S))throw new Error("bad point: equation left != right");if(!G.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function Y(G,h,S,w,B){return S=new L(r.mul(S.px,G),S.py,S.pz),h=(0,s.negateCt)(w,h),S=(0,s.negateCt)(B,S),h.add(S)}class L{constructor(h,S,w){this.px=D("x",h),this.py=D("y",S,!0),this.pz=D("z",w),Object.freeze(this)}static fromAffine(h){const{x:S,y:w}=h||{};if(!h||!r.isValid(S)||!r.isValid(w))throw new Error("invalid affine point");if(h instanceof L)throw new Error("projective point not allowed");return r.is0(S)&&r.is0(w)?L.ZERO:new L(S,w,r.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(h){return(0,s.normalizeZ)(L,"pz",h)}static fromBytes(h){return(0,t.abytes)(h),L.fromHex(h)}static fromHex(h){const S=L.fromAffine(z((0,t.ensureBytes)("pointHex",h)));return S.assertValidity(),S}static fromPrivateKey(h){const S=j(O,g.allowedPrivateKeyLengths,g.wrapPrivateKey);return L.BASE.multiply(S(h))}static msm(h,S){return(0,s.pippenger)(L,O,h,S)}precompute(h=8,S=!0){return re.setWindowSize(this,h),S||this.multiply(a),this}_setWindowSize(h){this.precompute(h)}assertValidity(){K(this)}hasEvenY(){const{y:h}=this.toAffine();if(!r.isOdd)throw new Error("Field doesn't support isOdd");return!r.isOdd(h)}equals(h){N(h);const{px:S,py:w,pz:B}=this,{px:T,py:q,pz:x}=h,I=r.eql(r.mul(S,x),r.mul(T,B)),k=r.eql(r.mul(w,x),r.mul(q,B));return I&&k}negate(){return new L(this.px,r.neg(this.py),this.pz)}double(){const{a:h,b:S}=n,w=r.mul(S,a),{px:B,py:T,pz:q}=this;let x=r.ZERO,I=r.ZERO,k=r.ZERO,A=r.mul(B,B),te=r.mul(T,T),W=r.mul(q,q),M=r.mul(B,T);return M=r.add(M,M),k=r.mul(B,q),k=r.add(k,k),x=r.mul(h,k),I=r.mul(w,W),I=r.add(x,I),x=r.sub(te,I),I=r.add(te,I),I=r.mul(x,I),x=r.mul(M,x),k=r.mul(w,k),W=r.mul(h,W),M=r.sub(A,W),M=r.mul(h,M),M=r.add(M,k),k=r.add(A,A),A=r.add(k,A),A=r.add(A,W),A=r.mul(A,M),I=r.add(I,A),W=r.mul(T,q),W=r.add(W,W),A=r.mul(W,M),x=r.sub(x,A),k=r.mul(W,te),k=r.add(k,k),k=r.add(k,k),new L(x,I,k)}add(h){N(h);const{px:S,py:w,pz:B}=this,{px:T,py:q,pz:x}=h;let I=r.ZERO,k=r.ZERO,A=r.ZERO;const te=n.a,W=r.mul(n.b,a);let M=r.mul(S,T),oe=r.mul(w,q),se=r.mul(B,x),ae=r.add(S,w),Q=r.add(T,q);ae=r.mul(ae,Q),Q=r.add(M,oe),ae=r.sub(ae,Q),Q=r.add(S,B);let ce=r.add(T,x);return Q=r.mul(Q,ce),ce=r.add(M,se),Q=r.sub(Q,ce),ce=r.add(w,B),I=r.add(q,x),ce=r.mul(ce,I),I=r.add(oe,se),ce=r.sub(ce,I),A=r.mul(te,Q),I=r.mul(W,se),A=r.add(I,A),I=r.sub(oe,A),A=r.add(oe,A),k=r.mul(I,A),oe=r.add(M,M),oe=r.add(oe,M),se=r.mul(te,se),Q=r.mul(W,Q),oe=r.add(oe,se),se=r.sub(M,se),se=r.mul(te,se),Q=r.add(Q,se),M=r.mul(oe,Q),k=r.add(k,M),M=r.mul(ce,Q),I=r.mul(ae,I),I=r.sub(I,M),M=r.mul(ae,oe),A=r.mul(ce,A),A=r.add(A,M),new L(I,k,A)}subtract(h){return this.add(h.negate())}is0(){return this.equals(L.ZERO)}multiply(h){const{endo:S}=g;if(!O.isValidNot0(h))throw new Error("invalid scalar: out of range");let w,B;const T=q=>re.wNAFCached(this,q,L.normalizeZ);if(S){const{k1neg:q,k1:x,k2neg:I,k2:k}=S.splitScalar(h),{p:A,f:te}=T(x),{p:W,f:M}=T(k);B=te.add(M),w=Y(S.beta,A,W,q,I)}else{const{p:q,f:x}=T(h);w=q,B=x}return L.normalizeZ([w,B])[0]}multiplyUnsafe(h){const{endo:S}=g,w=this;if(!O.isValid(h))throw new Error("invalid scalar: out of range");if(h===m||w.is0())return L.ZERO;if(h===d)return w;if(re.hasPrecomputes(this))return this.multiply(h);if(S){const{k1neg:B,k1:T,k2neg:q,k2:x}=S.splitScalar(h),{p1:I,p2:k}=(0,s.mulEndoUnsafe)(L,w,T,x);return Y(S.beta,I,k,B,q)}else return re.wNAFCachedUnsafe(w,h)}multiplyAndAddUnsafe(h,S,w){const B=this.multiplyUnsafe(S).add(h.multiplyUnsafe(w));return B.is0()?void 0:B}toAffine(h){return C(this,h)}isTorsionFree(){const{isTorsionFree:h}=g;return i===d?!0:h?h(L,this):re.wNAFCachedUnsafe(this,E).is0()}clearCofactor(){const{clearCofactor:h}=g;return i===d?this:h?h(L,this):this.multiplyUnsafe(i)}toBytes(h=!0){return(0,t.abool)("isCompressed",h),this.assertValidity(),R(L,this,h)}toRawBytes(h=!0){return this.toBytes(h)}toHex(h=!0){return(0,t.bytesToHex)(this.toBytes(h))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}}L.BASE=new L(n.Gx,n.Gy,r.ONE),L.ZERO=new L(r.ZERO,r.ONE,r.ZERO),L.Fp=r,L.Fn=O;const fe=O.BITS,re=(0,s.wNAF)(L,g.endo?Math.ceil(fe/2):fe);return L}function $(n){const{CURVE:g,curveOpts:r}=he(n),O=V(g,r);return be(n,O)}function F(n){return Uint8Array.of(n?2:3)}function ee(n,g,r={}){(0,t._validateObject)(g,{hash:"function"},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const O=g.randomBytes||t.randomBytes,i=g.hmac||((w,...B)=>(0,o.hmac)(g.hash,w,(0,t.concatBytes)(...B))),{Fp:E,Fn:y}=n,{ORDER:l,BITS:f}=y;function v(w){const B=l>>d;return w>B}function R(w){return v(w)?y.neg(w):w}function z(w,B){if(!y.isValidNot0(B))throw new Error(`invalid signature ${w}: out of range 1..CURVE.n`)}class P{constructor(B,T,q){z("r",B),z("s",T),this.r=B,this.s=T,q!=null&&(this.recovery=q),Object.freeze(this)}static fromCompact(B){const T=y.BYTES,q=(0,t.ensureBytes)("compactSignature",B,T*2);return new P(y.fromBytes(q.subarray(0,T)),y.fromBytes(q.subarray(T,T*2)))}static fromDER(B){const{r:T,s:q}=e.DER.toSig((0,t.ensureBytes)("DER",B));return new P(T,q)}assertValidity(){}addRecoveryBit(B){return new P(this.r,this.s,B)}recoverPublicKey(B){const T=E.ORDER,{r:q,s:x,recovery:I}=this;if(I==null||![0,1,2,3].includes(I))throw new Error("recovery id invalid");if(l*p<T&&I>1)throw new Error("recovery id is ambiguous for h>1 curve");const A=I===2||I===3?q+l:q;if(!E.isValid(A))throw new Error("recovery id 2 or 3 invalid");const te=E.toBytes(A),W=n.fromHex((0,t.concatBytes)(F((I&1)===0),te)),M=y.inv(A),oe=K((0,t.ensureBytes)("msgHash",B)),se=y.create(-oe*M),ae=y.create(x*M),Q=n.BASE.multiplyUnsafe(se).add(W.multiplyUnsafe(ae));if(Q.is0())throw new Error("point at infinify");return Q.assertValidity(),Q}hasHighS(){return v(this.s)}normalizeS(){return this.hasHighS()?new P(this.r,y.neg(this.s),this.recovery):this}toBytes(B){if(B==="compact")return(0,t.concatBytes)(y.toBytes(this.r),y.toBytes(this.s));if(B==="der")return(0,t.hexToBytes)(e.DER.hexFromSig(this));throw new Error("invalid format")}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return(0,t.bytesToHex)(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return(0,t.bytesToHex)(this.toBytes("compact"))}}const H=j(y,r.allowedPrivateKeyLengths,r.wrapPrivateKey),Z={isValidPrivateKey(w){try{return H(w),!0}catch{return!1}},normPrivateKeyToScalar:H,randomPrivateKey:()=>{const w=l;return(0,u.mapHashToField)(O((0,u.getMinHashLength)(w)),w)},precompute(w=8,B=n.BASE){return B.precompute(w,!1)}};function J(w,B=!0){return n.fromPrivateKey(w).toBytes(B)}function D(w){if(typeof w=="bigint")return!1;if(w instanceof n)return!0;const T=(0,t.ensureBytes)("key",w).length,q=E.BYTES,x=q+1,I=2*q+1;if(!(r.allowedPrivateKeyLengths||y.BYTES===x))return T===x||T===I}function N(w,B,T=!0){if(D(w)===!0)throw new Error("first arg must be private key");if(D(B)===!1)throw new Error("second arg must be public key");return n.fromHex(B).multiply(H(w)).toBytes(T)}const C=g.bits2int||function(w){if(w.length>8192)throw new Error("input is too large");const B=(0,t.bytesToNumberBE)(w),T=w.length*8-f;return T>0?B>>BigInt(T):B},K=g.bits2int_modN||function(w){return y.create(C(w))},Y=(0,t.bitMask)(f);function L(w){return(0,t.aInRange)("num < 2^"+f,w,m,Y),y.toBytes(w)}function fe(w,B,T=re){if(["recovered","canonical"].some(ae=>ae in T))throw new Error("sign() legacy options not supported");const{hash:q}=g;let{lowS:x,prehash:I,extraEntropy:k}=T;x==null&&(x=!0),w=(0,t.ensureBytes)("msgHash",w),c(T),I&&(w=(0,t.ensureBytes)("prehashed msgHash",q(w)));const A=K(w),te=H(B),W=[L(te),L(A)];if(k!=null&&k!==!1){const ae=k===!0?O(E.BYTES):k;W.push((0,t.ensureBytes)("extraEntropy",ae))}const M=(0,t.concatBytes)(...W),oe=A;function se(ae){const Q=C(ae);if(!y.isValidNot0(Q))return;const ce=y.inv(Q),qe=n.BASE.multiply(Q).toAffine(),Oe=y.create(qe.x);if(Oe===m)return;const ve=y.create(ce*y.create(oe+Oe*te));if(ve===m)return;let Me=(qe.x===Oe?0:2)|Number(qe.y&d),xe=ve;return x&&v(ve)&&(xe=R(ve),Me^=1),new P(Oe,xe,Me)}return{seed:M,k2sig:se}}const re={lowS:g.lowS,prehash:!1},G={lowS:g.lowS,prehash:!1};function h(w,B,T=re){const{seed:q,k2sig:x}=fe(w,B,T);return(0,t.createHmacDrbg)(g.hash.outputLen,y.BYTES,i)(q,x)}n.BASE.precompute(8);function S(w,B,T,q=G){const x=w;B=(0,t.ensureBytes)("msgHash",B),T=(0,t.ensureBytes)("publicKey",T),c(q);const{lowS:I,prehash:k,format:A}=q;if("strict"in q)throw new Error("options.strict was renamed to lowS");if(A!==void 0&&!["compact","der","js"].includes(A))throw new Error('format must be "compact", "der" or "js"');const te=typeof x=="string"||(0,t.isBytes)(x),W=!te&&!A&&typeof x=="object"&&x!==null&&typeof x.r=="bigint"&&typeof x.s=="bigint";if(!te&&!W)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let M,oe;try{if(W)if(A===void 0||A==="js")M=new P(x.r,x.s);else throw new Error("invalid format");if(te){try{A!=="compact"&&(M=P.fromDER(x))}catch(xe){if(!(xe instanceof e.DER.Err))throw xe}!M&&A!=="der"&&(M=P.fromCompact(x))}oe=n.fromHex(T)}catch{return!1}if(!M||I&&M.hasHighS())return!1;k&&(B=g.hash(B));const{r:se,s:ae}=M,Q=K(B),ce=y.inv(ae),qe=y.create(Q*ce),Oe=y.create(se*ce),ve=n.BASE.multiplyUnsafe(qe).add(oe.multiplyUnsafe(Oe));return ve.is0()?!1:y.create(ve.x)===se}return Object.freeze({getPublicKey:J,getSharedSecret:N,sign:h,verify:S,utils:Z,Point:n,Signature:P})}function he(n){const g={a:n.a,b:n.b,p:n.Fp.ORDER,n:n.n,h:n.h,Gx:n.Gx,Gy:n.Gy},r=n.Fp,O=(0,u.Field)(g.n,n.nBitLength),i={Fp:r,Fn:O,allowedPrivateKeyLengths:n.allowedPrivateKeyLengths,allowInfinityPoint:n.allowInfinityPoint,endo:n.endo,wrapPrivateKey:n.wrapPrivateKey,isTorsionFree:n.isTorsionFree,clearCofactor:n.clearCofactor,fromBytes:n.fromBytes,toBytes:n.toBytes};return{CURVE:g,curveOpts:i}}function ye(n){const{CURVE:g,curveOpts:r}=he(n),O={hash:n.hash,hmac:n.hmac,randomBytes:n.randomBytes,lowS:n.lowS,bits2int:n.bits2int,bits2int_modN:n.bits2int_modN};return{CURVE:g,curveOpts:r,ecdsaOpts:O}}function be(n,g){const{Fp:r,Fn:O}=g;function i(l){return(0,t.inRange)(l,d,O.ORDER)}const E=U(r,n.a,n.b),y=j(O,n.allowedPrivateKeyLengths,n.wrapPrivateKey);return Object.assign({},{CURVE:n,Point:g,ProjectivePoint:g,normPrivateKeyToScalar:y,weierstrassEquation:E,isWithinCurveOrder:i})}function Ee(n,g){return Object.assign({},g,{ProjectivePoint:g.Point,CURVE:n})}function Be(n){const{CURVE:g,curveOpts:r,ecdsaOpts:O}=ye(n),i=V(g,r),E=ee(i,O,r);return Ee(n,E)}function we(n,g){const r=n.ORDER;let O=m;for(let Z=r-d;Z%p===m;Z/=p)O+=d;const i=O,E=p<<i-d-d,y=E*p,l=(r-d)/y,f=(l-d)/p,v=y-d,R=E,z=n.pow(g,l),P=n.pow(g,(l+d)/p);let H=(Z,J)=>{let D=z,N=n.pow(J,v),C=n.sqr(N);C=n.mul(C,J);let K=n.mul(Z,C);K=n.pow(K,f),K=n.mul(K,N),N=n.mul(K,J),C=n.mul(K,Z);let Y=n.mul(C,N);K=n.pow(Y,R);let L=n.eql(K,n.ONE);N=n.mul(C,P),K=n.mul(Y,D),C=n.cmov(N,C,L),Y=n.cmov(K,Y,L);for(let fe=i;fe>d;fe--){let re=fe-p;re=p<<re-d;let G=n.pow(Y,re);const h=n.eql(G,n.ONE);N=n.mul(C,D),D=n.mul(D,D),G=n.mul(Y,D),C=n.cmov(N,C,h),Y=n.cmov(G,Y,h)}return{isValid:L,value:C}};if(n.ORDER%_===a){const Z=(n.ORDER-a)/_,J=n.sqrt(n.neg(g));H=(D,N)=>{let C=n.sqr(N);const K=n.mul(D,N);C=n.mul(C,K);let Y=n.pow(C,Z);Y=n.mul(Y,K);const L=n.mul(Y,J),fe=n.mul(n.sqr(Y),N),re=n.eql(fe,D);let G=n.cmov(L,Y,re);return{isValid:re,value:G}}}return H}function Te(n,g){(0,u.validateField)(n);const{A:r,B:O,Z:i}=g;if(!n.isValid(r)||!n.isValid(O)||!n.isValid(i))throw new Error("mapToCurveSimpleSWU: invalid opts");const E=we(n,i);if(!n.isOdd)throw new Error("Field does not have .isOdd()");return y=>{let l,f,v,R,z,P,H,Z;l=n.sqr(y),l=n.mul(l,i),f=n.sqr(l),f=n.add(f,l),v=n.add(f,n.ONE),v=n.mul(v,O),R=n.cmov(i,n.neg(f),!n.eql(f,n.ZERO)),R=n.mul(R,r),f=n.sqr(v),P=n.sqr(R),z=n.mul(P,r),f=n.add(f,z),f=n.mul(f,v),P=n.mul(P,R),z=n.mul(P,O),f=n.add(f,z),H=n.mul(l,v);const{isValid:J,value:D}=E(f,P);Z=n.mul(l,y),Z=n.mul(Z,D),H=n.cmov(H,v,J),Z=n.cmov(Z,D,J);const N=n.isOdd(y)===n.isOdd(Z);Z=n.cmov(n.neg(Z),Z,N);const C=(0,u.FpInvertBatch)(n,[R],!0)[0];return H=n.mul(H,C),{x:H,y:Z}}}})(Ke);Object.defineProperty(Ue,"__esModule",{value:!0});Ue.getHash=zt;Ue.createCurve=Dt;/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ct=Ke;function zt(e){return{hash:e}}function Dt(e,o){const t=s=>(0,Ct.weierstrass)({...e,hash:s});return{...t(o),create:t}}var Se={};Object.defineProperty(Se,"__esModule",{value:!0});Se.expand_message_xmd=ht;Se.expand_message_xof=mt;Se.hash_to_field=De;Se.isogenyMap=$t;Se.createHasher=Gt;const ie=Ne,dt=X,Vt=ie.bytesToNumberBE;function ge(e,o){if(je(e),je(o),e<0||e>=1<<8*o)throw new Error("invalid I2OSP input: "+e);const t=Array.from({length:o}).fill(0);for(let s=o-1;s>=0;s--)t[s]=e&255,e>>>=8;return new Uint8Array(t)}function Kt(e,o){const t=new Uint8Array(e.length);for(let s=0;s<e.length;s++)t[s]=e[s]^o[s];return t}function je(e){if(!Number.isSafeInteger(e))throw new Error("number expected")}function ht(e,o,t,s){(0,ie.abytes)(e),(0,ie.abytes)(o),je(t),o.length>255&&(o=s((0,ie.concatBytes)((0,ie.utf8ToBytes)("H2C-OVERSIZE-DST-"),o)));const{outputLen:u,blockLen:c}=s,b=Math.ceil(t/u);if(t>65535||b>255)throw new Error("expand_message_xmd: invalid lenInBytes");const m=(0,ie.concatBytes)(o,ge(o.length,1)),d=ge(0,c),p=ge(t,2),a=new Array(b),_=s((0,ie.concatBytes)(d,e,p,ge(0,1),m));a[0]=s((0,ie.concatBytes)(_,ge(1,1),m));for(let j=1;j<=b;j++){const V=[Kt(_,a[j-1]),ge(j+1,1),m];a[j]=s((0,ie.concatBytes)(...V))}return(0,ie.concatBytes)(...a).slice(0,t)}function mt(e,o,t,s,u){if((0,ie.abytes)(e),(0,ie.abytes)(o),je(t),o.length>255){const c=Math.ceil(2*s/8);o=u.create({dkLen:c}).update((0,ie.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(o).digest()}if(t>65535||o.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return u.create({dkLen:t}).update(e).update(ge(t,2)).update(o).update(ge(o.length,1)).digest()}function De(e,o,t){(0,ie._validateObject)(t,{p:"bigint",m:"number",k:"number",hash:"function"});const{p:s,k:u,m:c,hash:b,expand:m,DST:d}=t;if(!(0,ie.isBytes)(d)&&typeof d!="string")throw new Error("DST must be string or uint8array");if(!(0,ie.isHash)(t.hash))throw new Error("expected valid hash");(0,ie.abytes)(e),je(o);const p=typeof d=="string"?(0,ie.utf8ToBytes)(d):d,a=s.toString(2).length,_=Math.ceil((a+u)/8),U=o*c*_;let j;if(m==="xmd")j=ht(e,p,U,b);else if(m==="xof")j=mt(e,p,U,u,b);else if(m==="_internal_pass")j=e;else throw new Error('expand must be "xmd" or "xof"');const V=new Array(o);for(let $=0;$<o;$++){const F=new Array(c);for(let ee=0;ee<c;ee++){const he=_*(ee+$*c),ye=j.subarray(he,he+_);F[ee]=(0,dt.mod)(Vt(ye),s)}V[$]=F}return V}function $t(e,o){const t=o.map(s=>Array.from(s).reverse());return(s,u)=>{const[c,b,m,d]=t.map(_=>_.reduce((U,j)=>e.add(e.mul(U,s),j))),[p,a]=(0,dt.FpInvertBatch)(e,[b,d],!0);return s=e.mul(c,p),u=e.mul(u,e.mul(m,a)),{x:s,y:u}}}function Gt(e,o,t){if(typeof o!="function")throw new Error("mapToCurve() must be defined");function s(c){return e.fromAffine(o(c))}function u(c){const b=c.clearCofactor();return b.equals(e.ZERO)?e.ZERO:(b.assertValidity(),b)}return{defaults:t,hashToCurve(c,b){const m=t.DST?t.DST:{},d=Object.assign({},t,m,b),p=De(c,2,d),a=s(p[0]),_=s(p[1]);return u(a.add(_))},encodeToCurve(c,b){const m=t.encodeDST?t.encodeDST:{},d=Object.assign({},t,m,b),p=De(c,1,d);return u(s(p[0]))},mapToCurve(c){if(!Array.isArray(c))throw new Error("expected array of bigints");for(const b of c)if(typeof b!="bigint")throw new Error("expected array of bigints");return u(s(c))}}}(function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.encodeToCurve=e.hashToCurve=e.secp256k1_hasher=e.schnorr=e.secp256k1=void 0;/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const o=Et,t=ze,s=Ue,u=Se,c=X,b=Ke,m=Ne,d={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},p=BigInt(0),a=BigInt(1),_=BigInt(2),U=(l,f)=>(l+f/_)/f;function j(l){const f=d.p,v=BigInt(3),R=BigInt(6),z=BigInt(11),P=BigInt(22),H=BigInt(23),Z=BigInt(44),J=BigInt(88),D=l*l*l%f,N=D*D*l%f,C=(0,c.pow2)(N,v,f)*N%f,K=(0,c.pow2)(C,v,f)*N%f,Y=(0,c.pow2)(K,_,f)*D%f,L=(0,c.pow2)(Y,z,f)*Y%f,fe=(0,c.pow2)(L,P,f)*L%f,re=(0,c.pow2)(fe,Z,f)*fe%f,G=(0,c.pow2)(re,J,f)*re%f,h=(0,c.pow2)(G,Z,f)*fe%f,S=(0,c.pow2)(h,v,f)*N%f,w=(0,c.pow2)(S,H,f)*L%f,B=(0,c.pow2)(w,R,f)*D%f,T=(0,c.pow2)(B,_,f);if(!V.eql(V.sqr(T),l))throw new Error("Cannot find square root");return T}const V=(0,c.Field)(d.p,void 0,void 0,{sqrt:j});e.secp256k1=(0,s.createCurve)({...d,Fp:V,lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:l=>{const f=d.n,v=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),R=-a*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),z=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),P=v,H=BigInt("0x100000000000000000000000000000000"),Z=U(P*l,f),J=U(-R*l,f);let D=(0,c.mod)(l-Z*v-J*z,f),N=(0,c.mod)(-Z*R-J*P,f);const C=D>H,K=N>H;if(C&&(D=f-D),K&&(N=f-N),D>H||N>H)throw new Error("splitScalar: Endomorphism failed, k="+l);return{k1neg:C,k1:D,k2neg:K,k2:N}}}},o.sha256);const $={};function F(l,...f){let v=$[l];if(v===void 0){const R=(0,o.sha256)(Uint8Array.from(l,z=>z.charCodeAt(0)));v=(0,m.concatBytes)(R,R),$[l]=v}return(0,o.sha256)((0,m.concatBytes)(v,...f))}const ee=l=>l.toBytes(!0).slice(1),he=l=>(0,m.numberToBytesBE)(l,32),ye=l=>(0,c.mod)(l,d.p),be=l=>(0,c.mod)(l,d.n),Ee=e.secp256k1.Point,Be=l=>l%_===p;function we(l){let f=e.secp256k1.utils.normPrivateKeyToScalar(l),v=Ee.fromPrivateKey(f);return{scalar:Be(v.y)?f:be(-f),bytes:ee(v)}}function Te(l){(0,m.aInRange)("x",l,a,d.p);const f=ye(l*l),v=ye(f*l+BigInt(7));let R=j(v);Be(R)||(R=ye(-R));const z=Ee.fromAffine({x:l,y:R});return z.assertValidity(),z}const n=m.bytesToNumberBE;function g(...l){return be(n(F("BIP0340/challenge",...l)))}function r(l){return we(l).bytes}function O(l,f,v=(0,t.randomBytes)(32)){const R=(0,m.ensureBytes)("message",l),{bytes:z,scalar:P}=we(f),H=(0,m.ensureBytes)("auxRand",v,32),Z=he(P^n(F("BIP0340/aux",H))),J=F("BIP0340/nonce",Z,z,R),D=be(n(J));if(D===p)throw new Error("sign failed: k is zero");const{bytes:N,scalar:C}=we(D),K=g(N,z,R),Y=new Uint8Array(64);if(Y.set(N,0),Y.set(he(be(C+K*P)),32),!i(Y,R,z))throw new Error("sign: Invalid signature produced");return Y}function i(l,f,v){const R=(0,m.ensureBytes)("signature",l,64),z=(0,m.ensureBytes)("message",f),P=(0,m.ensureBytes)("publicKey",v,32);try{const H=Te(n(P)),Z=n(R.subarray(0,32));if(!(0,m.inRange)(Z,a,d.p))return!1;const J=n(R.subarray(32,64));if(!(0,m.inRange)(J,a,d.n))return!1;const D=g(he(Z),ee(H),z),N=Ee.BASE.multiplyUnsafe(J).add(H.multiplyUnsafe(be(-D))),{x:C,y:K}=N.toAffine();return!(N.is0()||!Be(K)||C!==Z)}catch{return!1}}e.schnorr={getPublicKey:r,sign:O,verify:i,utils:{randomPrivateKey:e.secp256k1.utils.randomPrivateKey,lift_x:Te,pointToBytes:ee,numberToBytesBE:m.numberToBytesBE,bytesToNumberBE:m.bytesToNumberBE,taggedHash:F,mod:c.mod}};const E=(0,u.isogenyMap)(V,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(l=>l.map(f=>BigInt(f)))),y=(0,b.mapToCurveSimpleSWU)(V,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:V.create(BigInt("-11"))});e.secp256k1_hasher=(0,u.createHasher)(e.secp256k1.Point,l=>{const{x:f,y:v}=y(V.create(l[0]));return E(f,v)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:V.ORDER,m:1,k:128,expand:"xmd",hash:o.sha256}),e.hashToCurve=e.secp256k1_hasher.hashToCurve,e.encodeToCurve=e.secp256k1_hasher.encodeToCurve})(et);const Xt=gt({__proto__:null},[et]);export{et as a,Xt as s};
