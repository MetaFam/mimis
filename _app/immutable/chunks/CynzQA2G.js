const g=[];for(let n=0;n<256;++n)g.push((n+256).toString(16).slice(1));function p(n,x=0){return(g[n[x+0]]+g[n[x+1]]+g[n[x+2]]+g[n[x+3]]+"-"+g[n[x+4]]+g[n[x+5]]+"-"+g[n[x+6]]+g[n[x+7]]+"-"+g[n[x+8]]+g[n[x+9]]+"-"+g[n[x+10]]+g[n[x+11]]+g[n[x+12]]+g[n[x+13]]+g[n[x+14]]+g[n[x+15]]).toLowerCase()}let y;const R=new Uint8Array(16);function m(){if(!y){if(typeof crypto>"u"||!crypto.getRandomValues)throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");y=crypto.getRandomValues.bind(crypto)}return y(R)}const w={};function V(n,x,l){var c;let i;if(n)i=u(n.random??((c=n.rng)==null?void 0:c.call(n))??m(),n.msecs,n.seq,x,l);else{const e=Date.now(),h=m();d(w,e,h),i=u(h,w.msecs,w.seq,x,l)}return x??p(i)}function d(n,x,l){return n.msecs??(n.msecs=-1/0),n.seq??(n.seq=0),x>n.msecs?(n.seq=l[6]<<23|l[7]<<16|l[8]<<8|l[9],n.msecs=x):(n.seq=n.seq+1|0,n.seq===0&&n.msecs++),n}function u(n,x,l,i,c=0){if(n.length<16)throw new Error("Random bytes length must be >= 16");if(!i)i=new Uint8Array(16),c=0;else if(c<0||c+16>i.length)throw new RangeError(`UUID byte range ${c}:${c+15} is out of buffer bounds`);return x??(x=Date.now()),l??(l=n[6]*127<<24|n[7]<<16|n[8]<<8|n[9]),i[c++]=x/1099511627776&255,i[c++]=x/4294967296&255,i[c++]=x/16777216&255,i[c++]=x/65536&255,i[c++]=x/256&255,i[c++]=x&255,i[c++]=112|l>>>28&15,i[c++]=l>>>20&255,i[c++]=128|l>>>14&63,i[c++]=l>>>6&255,i[c++]=l<<2&255|n[10]&3,i[c++]=n[11],i[c++]=n[12],i[c++]=n[13],i[c++]=n[14],i[c++]=n[15],i}export{V as v};
