import{h as xt,i as Lt,d as bt,g as st,f as F,e as Xt,r as Wt,s as Qt}from"./DquymGsT.js";import{h as Jt}from"./Bl2jHvLt.js";/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const St=BigInt(0),Et=BigInt(1);function at(e,n){if(typeof n!="boolean")throw new Error(e+" boolean expected, got "+n)}function ft(e){const n=e.toString(16);return n.length&1?"0"+n:n}function jt(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);return e===""?St:BigInt("0x"+e)}function ut(e){return jt(st(e))}function Ut(e){return bt(e),jt(st(Uint8Array.from(e).reverse()))}function It(e,n){return xt(e.toString(16).padStart(n*2,"0"))}function $t(e,n){return It(e,n).reverse()}function V(e,n,t){let r;if(typeof n=="string")try{r=xt(n)}catch(s){throw new Error(e+" must be hex string or Uint8Array, cause: "+s)}else if(Lt(n))r=Uint8Array.from(n);else throw new Error(e+" must be hex string or Uint8Array");const i=r.length;if(typeof t=="number"&&i!==t)throw new Error(e+" of length "+t+" expected, got "+i);return r}const gt=e=>typeof e=="bigint"&&St<=e;function te(e,n,t){return gt(e)&&gt(n)&&gt(t)&&n<=e&&e<t}function ee(e,n,t,r){if(!te(n,t,r))throw new Error("expected valid "+e+": "+t+" <= n < "+r+", got "+n)}function ne(e){let n;for(n=0;e>St;e>>=Et,n+=1);return n}const dt=e=>(Et<<BigInt(e))-Et;function re(e,n,t){if(typeof e!="number"||e<2)throw new Error("hashLen must be a number");if(typeof n!="number"||n<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");const r=S=>new Uint8Array(S),i=S=>Uint8Array.of(S);let s=r(e),o=r(e),l=0;const a=()=>{s.fill(1),o.fill(0),l=0},g=(...S)=>t(o,s,...S),f=(S=r(0))=>{o=g(i(0),S),s=g(),S.length!==0&&(o=g(i(1),S),s=g())},E=()=>{if(l++>=1e3)throw new Error("drbg: tried 1000 values");let S=0;const _=[];for(;S<n;){s=g();const N=s.slice();_.push(N),S+=s.length}return F(..._)};return(S,_)=>{a(),f(S);let N;for(;!(N=_(E()));)f();return a(),N}}function Nt(e,n,t={}){if(!e||typeof e!="object")throw new Error("expected valid options object");function r(i,s,o){const l=e[i];if(o&&l===void 0)return;const a=typeof l;if(a!==s||l===null)throw new Error(`param "${i}" is invalid: expected ${s}, got ${a}`)}Object.entries(n).forEach(([i,s])=>r(i,s,!1)),Object.entries(t).forEach(([i,s])=>r(i,s,!0))}function qt(e){const n=new WeakMap;return(t,...r)=>{const i=n.get(t);if(i!==void 0)return i;const s=e(t,...r);return n.set(t,s),s}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const $=BigInt(0),U=BigInt(1),P=BigInt(2),oe=BigInt(3),Mt=BigInt(4),kt=BigInt(5),Vt=BigInt(8);function C(e,n){const t=e%n;return t>=$?t:n+t}function k(e,n,t){let r=e;for(;n-- >$;)r*=r,r%=t;return r}function At(e,n){if(e===$)throw new Error("invert: expected non-zero number");if(n<=$)throw new Error("invert: expected positive modulus, got "+n);let t=C(e,n),r=n,i=$,s=U;for(;t!==$;){const l=r/t,a=r%t,g=i-s*l;r=t,t=a,i=s,s=g}if(r!==U)throw new Error("invert: does not exist");return C(i,n)}function Ct(e,n){const t=(e.ORDER+U)/Mt,r=e.pow(n,t);if(!e.eql(e.sqr(r),n))throw new Error("Cannot find square root");return r}function ie(e,n){const t=(e.ORDER-kt)/Vt,r=e.mul(n,P),i=e.pow(r,t),s=e.mul(n,i),o=e.mul(e.mul(s,P),i),l=e.mul(s,e.sub(o,e.ONE));if(!e.eql(e.sqr(l),n))throw new Error("Cannot find square root");return l}function se(e){if(e<BigInt(3))throw new Error("sqrt is not defined for small field");let n=e-U,t=0;for(;n%P===$;)n/=P,t++;let r=P;const i=ht(e);for(;_t(i,r)===1;)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(t===1)return Ct;let s=i.pow(r,n);const o=(n+U)/P;return function(a,g){if(a.is0(g))return g;if(_t(a,g)!==1)throw new Error("Cannot find square root");let f=t,E=a.mul(a.ONE,s),x=a.pow(g,n),S=a.pow(g,o);for(;!a.eql(x,a.ONE);){if(a.is0(x))return a.ZERO;let _=1,N=a.sqr(x);for(;!a.eql(N,a.ONE);)if(_++,N=a.sqr(N),_===f)throw new Error("Cannot find square root");const T=U<<BigInt(f-_-1),M=a.pow(E,T);f=_,E=a.sqr(M),x=a.mul(x,E),S=a.mul(S,M)}return S}}function fe(e){return e%Mt===oe?Ct:e%Vt===kt?ie:se(e)}const ce=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function ae(e){const n={ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"},t=ce.reduce((r,i)=>(r[i]="function",r),n);return Nt(e,t),e}function le(e,n,t){if(t<$)throw new Error("invalid exponent, negatives unsupported");if(t===$)return e.ONE;if(t===U)return n;let r=e.ONE,i=n;for(;t>$;)t&U&&(r=e.mul(r,i)),i=e.sqr(i),t>>=U;return r}function Kt(e,n,t=!1){const r=new Array(n.length).fill(t?e.ZERO:void 0),i=n.reduce((o,l,a)=>e.is0(l)?o:(r[a]=o,e.mul(o,l)),e.ONE),s=e.inv(i);return n.reduceRight((o,l,a)=>e.is0(l)?o:(r[a]=e.mul(o,r[a]),e.mul(o,l)),s),r}function _t(e,n){const t=(e.ORDER-U)/P,r=e.pow(n,t),i=e.eql(r,e.ONE),s=e.eql(r,e.ZERO),o=e.eql(r,e.neg(e.ONE));if(!i&&!s&&!o)throw new Error("invalid Legendre symbol result");return i?1:s?0:-1}function ue(e,n){n!==void 0&&Xt(n);const t=n!==void 0?n:e.toString(2).length,r=Math.ceil(t/8);return{nBitLength:t,nByteLength:r}}function ht(e,n,t=!1,r={}){if(e<=$)throw new Error("invalid field: expected ORDER > 0, got "+e);let i,s;if(typeof n=="object"&&n!=null){if(r.sqrt||t)throw new Error("cannot specify opts in two arguments");const f=n;f.BITS&&(i=f.BITS),f.sqrt&&(s=f.sqrt),typeof f.isLE=="boolean"&&(t=f.isLE)}else typeof n=="number"&&(i=n),r.sqrt&&(s=r.sqrt);const{nBitLength:o,nByteLength:l}=ue(e,i);if(l>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let a;const g=Object.freeze({ORDER:e,isLE:t,BITS:o,BYTES:l,MASK:dt(o),ZERO:$,ONE:U,create:f=>C(f,e),isValid:f=>{if(typeof f!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof f);return $<=f&&f<e},is0:f=>f===$,isValidNot0:f=>!g.is0(f)&&g.isValid(f),isOdd:f=>(f&U)===U,neg:f=>C(-f,e),eql:(f,E)=>f===E,sqr:f=>C(f*f,e),add:(f,E)=>C(f+E,e),sub:(f,E)=>C(f-E,e),mul:(f,E)=>C(f*E,e),pow:(f,E)=>le(g,f,E),div:(f,E)=>C(f*At(E,e),e),sqrN:f=>f*f,addN:(f,E)=>f+E,subN:(f,E)=>f-E,mulN:(f,E)=>f*E,inv:f=>At(f,e),sqrt:s||(f=>(a||(a=fe(e)),a(g,f))),toBytes:f=>t?$t(f,l):It(f,l),fromBytes:f=>{if(f.length!==l)throw new Error("Field.fromBytes: expected "+l+" bytes, got "+f.length);return t?Ut(f):ut(f)},invertBatch:f=>Kt(g,f),cmov:(f,E,x)=>x?E:f});return Object.freeze(g)}function Ht(e){if(typeof e!="bigint")throw new Error("field order must be bigint");const n=e.toString(2).length;return Math.ceil(n/8)}function Yt(e){const n=Ht(e);return n+Math.ceil(n/2)}function de(e,n,t=!1){const r=e.length,i=Ht(n),s=Yt(n);if(r<16||r<s||r>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+r);const o=t?Ut(e):ut(e),l=C(o,n-U)+U;return t?$t(l,i):It(l,i)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const et=BigInt(0),X=BigInt(1);function rt(e,n){const t=n.negate();return e?t:n}function he(e,n,t){const r=o=>o.pz,i=Kt(e.Fp,t.map(r));return t.map((o,l)=>o.toAffine(i[l])).map(e.fromAffine)}function Dt(e,n){if(!Number.isSafeInteger(e)||e<=0||e>n)throw new Error("invalid window size, expected [1.."+n+"], got W="+e)}function mt(e,n){Dt(e,n);const t=Math.ceil(n/e)+1,r=2**(e-1),i=2**e,s=dt(e),o=BigInt(e);return{windows:t,windowSize:r,mask:s,maxNumber:i,shiftBy:o}}function Zt(e,n,t){const{windowSize:r,mask:i,maxNumber:s,shiftBy:o}=t;let l=Number(e&i),a=e>>o;l>r&&(l-=s,a+=X);const g=n*r,f=g+Math.abs(l)-1,E=l===0,x=l<0,S=n%2!==0;return{nextN:a,offset:f,isZero:E,isNeg:x,isNegF:S,offsetF:g}}function we(e,n){if(!Array.isArray(e))throw new Error("array expected");e.forEach((t,r)=>{if(!(t instanceof n))throw new Error("invalid point at index "+r)})}function ge(e,n){if(!Array.isArray(e))throw new Error("array of scalars expected");e.forEach((t,r)=>{if(!n.isValid(t))throw new Error("invalid scalar at index "+r)})}const yt=new WeakMap,Gt=new WeakMap;function pt(e){return Gt.get(e)||1}function Rt(e){if(e!==et)throw new Error("invalid wNAF")}function me(e,n){return{constTimeNegate:rt,hasPrecomputes(t){return pt(t)!==1},unsafeLadder(t,r,i=e.ZERO){let s=t;for(;r>et;)r&X&&(i=i.add(s)),s=s.double(),r>>=X;return i},precomputeWindow(t,r){const{windows:i,windowSize:s}=mt(r,n),o=[];let l=t,a=l;for(let g=0;g<i;g++){a=l,o.push(a);for(let f=1;f<s;f++)a=a.add(l),o.push(a);l=a.double()}return o},wNAF(t,r,i){let s=e.ZERO,o=e.BASE;const l=mt(t,n);for(let a=0;a<l.windows;a++){const{nextN:g,offset:f,isZero:E,isNeg:x,isNegF:S,offsetF:_}=Zt(i,a,l);i=g,E?o=o.add(rt(S,r[_])):s=s.add(rt(x,r[f]))}return Rt(i),{p:s,f:o}},wNAFUnsafe(t,r,i,s=e.ZERO){const o=mt(t,n);for(let l=0;l<o.windows&&i!==et;l++){const{nextN:a,offset:g,isZero:f,isNeg:E}=Zt(i,l,o);if(i=a,!f){const x=r[g];s=s.add(E?x.negate():x)}}return Rt(i),s},getPrecomputes(t,r,i){let s=yt.get(r);return s||(s=this.precomputeWindow(r,t),t!==1&&(typeof i=="function"&&(s=i(s)),yt.set(r,s))),s},wNAFCached(t,r,i){const s=pt(t);return this.wNAF(s,this.getPrecomputes(s,t,i),r)},wNAFCachedUnsafe(t,r,i,s){const o=pt(t);return o===1?this.unsafeLadder(t,r,s):this.wNAFUnsafe(o,this.getPrecomputes(o,t,i),r,s)},setWindowSize(t,r){Dt(r,n),Gt.set(t,r),yt.delete(t)}}}function ye(e,n,t,r){let i=n,s=e.ZERO,o=e.ZERO;for(;t>et||r>et;)t&X&&(s=s.add(i)),r&X&&(o=o.add(i)),i=i.double(),t>>=X,r>>=X;return{p1:s,p2:o}}function pe(e,n,t,r){we(t,e),ge(r,n);const i=t.length,s=r.length;if(i!==s)throw new Error("arrays of points and scalars must have equal length");const o=e.ZERO,l=ne(BigInt(i));let a=1;l>12?a=l-3:l>4?a=l-2:l>0&&(a=2);const g=dt(a),f=new Array(Number(g)+1).fill(o),E=Math.floor((n.BITS-1)/a)*a;let x=o;for(let S=E;S>=0;S-=a){f.fill(o);for(let N=0;N<s;N++){const T=r[N],M=Number(T>>BigInt(S)&g);f[M]=f[M].add(t[N])}let _=o;for(let N=f.length-1,T=o;N>0;N--)T=T.add(f[N]),_=_.add(T);if(x=x.add(_),S!==0)for(let N=0;N<a;N++)x=x.double()}return x}function Ot(e,n){if(n){if(n.ORDER!==e)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return ae(n),n}else return ht(e)}function be(e,n,t={}){if(!n||typeof n!="object")throw new Error(`expected valid ${e} CURVE object`);for(const l of["p","n","h"]){const a=n[l];if(!(typeof a=="bigint"&&a>et))throw new Error(`CURVE.${l} must be positive bigint`)}const r=Ot(n.p,t.Fp),i=Ot(n.n,t.Fn),o=["Gx","Gy","a","b"];for(const l of o)if(!r.isValid(n[l]))throw new Error(`CURVE.${l} must be valid field element of CURVE.Fp`);return{Fp:r,Fn:i}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function zt(e){e.lowS!==void 0&&at("lowS",e.lowS),e.prehash!==void 0&&at("prehash",e.prehash)}class Ee extends Error{constructor(n=""){super(n)}}const K={Err:Ee,_tlv:{encode:(e,n)=>{const{Err:t}=K;if(e<0||e>256)throw new t("tlv.encode: wrong tag");if(n.length&1)throw new t("tlv.encode: unpadded data");const r=n.length/2,i=ft(r);if(i.length/2&128)throw new t("tlv.encode: long form length too big");const s=r>127?ft(i.length/2|128):"";return ft(e)+s+i+n},decode(e,n){const{Err:t}=K;let r=0;if(e<0||e>256)throw new t("tlv.encode: wrong tag");if(n.length<2||n[r++]!==e)throw new t("tlv.decode: wrong tlv");const i=n[r++],s=!!(i&128);let o=0;if(!s)o=i;else{const a=i&127;if(!a)throw new t("tlv.decode(long): indefinite length not supported");if(a>4)throw new t("tlv.decode(long): byte length is too big");const g=n.subarray(r,r+a);if(g.length!==a)throw new t("tlv.decode: length bytes not complete");if(g[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(const f of g)o=o<<8|f;if(r+=a,o<128)throw new t("tlv.decode(long): not minimal encoding")}const l=n.subarray(r,r+o);if(l.length!==o)throw new t("tlv.decode: wrong value length");return{v:l,l:n.subarray(r+o)}}},_int:{encode(e){const{Err:n}=K;if(e<ot)throw new n("integer: negative integers are not allowed");let t=ft(e);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new n("unexpected DER parsing assertion: unpadded hex");return t},decode(e){const{Err:n}=K;if(e[0]&128)throw new n("invalid signature integer: negative");if(e[0]===0&&!(e[1]&128))throw new n("invalid signature integer: unnecessary leading zero");return ut(e)}},toSig(e){const{Err:n,_int:t,_tlv:r}=K,i=V("signature",e),{v:s,l:o}=r.decode(48,i);if(o.length)throw new n("invalid signature: left bytes after parsing");const{v:l,l:a}=r.decode(2,s),{v:g,l:f}=r.decode(2,a);if(f.length)throw new n("invalid signature: left bytes after parsing");return{r:t.decode(l),s:t.decode(g)}},hexFromSig(e){const{_tlv:n,_int:t}=K,r=n.encode(2,t.encode(e.r)),i=n.encode(2,t.encode(e.s)),s=r+i;return n.encode(48,s)}},ot=BigInt(0),it=BigInt(1),Be=BigInt(2),ct=BigInt(3),ve=BigInt(4);function xe(e,n,t){function r(i){const s=e.sqr(i),o=e.mul(s,i);return e.add(e.add(o,e.mul(i,n)),t)}return r}function Ft(e,n,t){const{BYTES:r}=e;function i(s){let o;if(typeof s=="bigint")o=s;else{let l=V("private key",s);if(n){if(!n.includes(l.length*2))throw new Error("invalid private key");const a=new Uint8Array(r);a.set(l,a.length-l.length),l=a}try{o=e.fromBytes(l)}catch{throw new Error(`invalid private key: expected ui8a of size ${r}, got ${typeof s}`)}}if(t&&(o=e.create(o)),!e.isValidNot0(o))throw new Error("invalid private key: out of range [1..N-1]");return o}return i}function Se(e,n={}){const{Fp:t,Fn:r}=be("weierstrass",e,n),{h:i,n:s}=e;Nt(n,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:o}=n;if(o&&(!t.is0(e.a)||typeof o.beta!="bigint"||typeof o.splitScalar!="function"))throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');function l(){if(!t.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function a(Z,c,h){const{x:u,y:d}=c.toAffine(),w=t.toBytes(u);if(at("isCompressed",h),h){l();const p=!t.isOdd(d);return F(Pt(p),w)}else return F(Uint8Array.of(4),w,t.toBytes(d))}function g(Z){bt(Z);const c=t.BYTES,h=c+1,u=2*c+1,d=Z.length,w=Z[0],p=Z.subarray(1);if(d===h&&(w===2||w===3)){const m=t.fromBytes(p);if(!t.isValid(m))throw new Error("bad point: is not on curve, wrong x");const y=x(m);let B;try{B=t.sqrt(y)}catch(q){const v=q instanceof Error?": "+q.message:"";throw new Error("bad point: is not on curve, sqrt error"+v)}l();const b=t.isOdd(B);return(w&1)===1!==b&&(B=t.neg(B)),{x:m,y:B}}else if(d===u&&w===4){const m=t.fromBytes(p.subarray(c*0,c*1)),y=t.fromBytes(p.subarray(c*1,c*2));if(!S(m,y))throw new Error("bad point: is not on curve");return{x:m,y}}else throw new Error(`bad point: got length ${d}, expected compressed=${h} or uncompressed=${u}`)}const f=n.toBytes||a,E=n.fromBytes||g,x=xe(t,e.a,e.b);function S(Z,c){const h=t.sqr(c),u=x(Z);return t.eql(h,u)}if(!S(e.Gx,e.Gy))throw new Error("bad curve params: generator point");const _=t.mul(t.pow(e.a,ct),ve),N=t.mul(t.sqr(e.b),BigInt(27));if(t.is0(t.add(_,N)))throw new Error("bad curve params: a or b");function T(Z,c,h=!1){if(!t.isValid(c)||h&&t.is0(c))throw new Error(`bad point coordinate ${Z}`);return c}function M(Z){if(!(Z instanceof I))throw new Error("ProjectivePoint expected")}const W=qt((Z,c)=>{const{px:h,py:u,pz:d}=Z;if(t.eql(d,t.ONE))return{x:h,y:u};const w=Z.is0();c==null&&(c=w?t.ONE:t.inv(d));const p=t.mul(h,c),m=t.mul(u,c),y=t.mul(d,c);if(w)return{x:t.ZERO,y:t.ZERO};if(!t.eql(y,t.ONE))throw new Error("invZ was invalid");return{x:p,y:m}}),Y=qt(Z=>{if(Z.is0()){if(n.allowInfinityPoint&&!t.is0(Z.py))return;throw new Error("bad point: ZERO")}const{x:c,y:h}=Z.toAffine();if(!t.isValid(c)||!t.isValid(h))throw new Error("bad point: x or y not field elements");if(!S(c,h))throw new Error("bad point: equation left != right");if(!Z.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function Q(Z,c,h,u,d){return h=new I(t.mul(h.px,Z),h.py,h.pz),c=rt(u,c),h=rt(d,h),c.add(h)}class I{constructor(c,h,u){this.px=T("x",c),this.py=T("y",h,!0),this.pz=T("z",u),Object.freeze(this)}static fromAffine(c){const{x:h,y:u}=c||{};if(!c||!t.isValid(h)||!t.isValid(u))throw new Error("invalid affine point");if(c instanceof I)throw new Error("projective point not allowed");return t.is0(h)&&t.is0(u)?I.ZERO:new I(h,u,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(c){return he(I,"pz",c)}static fromBytes(c){return bt(c),I.fromHex(c)}static fromHex(c){const h=I.fromAffine(E(V("pointHex",c)));return h.assertValidity(),h}static fromPrivateKey(c){const h=Ft(r,n.allowedPrivateKeyLengths,n.wrapPrivateKey);return I.BASE.multiply(h(c))}static msm(c,h){return pe(I,r,c,h)}precompute(c=8,h=!0){return H.setWindowSize(this,c),h||this.multiply(ct),this}_setWindowSize(c){this.precompute(c)}assertValidity(){Y(this)}hasEvenY(){const{y:c}=this.toAffine();if(!t.isOdd)throw new Error("Field doesn't support isOdd");return!t.isOdd(c)}equals(c){M(c);const{px:h,py:u,pz:d}=this,{px:w,py:p,pz:m}=c,y=t.eql(t.mul(h,m),t.mul(w,d)),B=t.eql(t.mul(u,m),t.mul(p,d));return y&&B}negate(){return new I(this.px,t.neg(this.py),this.pz)}double(){const{a:c,b:h}=e,u=t.mul(h,ct),{px:d,py:w,pz:p}=this;let m=t.ZERO,y=t.ZERO,B=t.ZERO,b=t.mul(d,d),R=t.mul(w,w),q=t.mul(p,p),v=t.mul(d,w);return v=t.add(v,v),B=t.mul(d,p),B=t.add(B,B),m=t.mul(c,B),y=t.mul(u,q),y=t.add(m,y),m=t.sub(R,y),y=t.add(R,y),y=t.mul(m,y),m=t.mul(v,m),B=t.mul(u,B),q=t.mul(c,q),v=t.sub(b,q),v=t.mul(c,v),v=t.add(v,B),B=t.add(b,b),b=t.add(B,b),b=t.add(b,q),b=t.mul(b,v),y=t.add(y,b),q=t.mul(w,p),q=t.add(q,q),b=t.mul(q,v),m=t.sub(m,b),B=t.mul(q,R),B=t.add(B,B),B=t.add(B,B),new I(m,y,B)}add(c){M(c);const{px:h,py:u,pz:d}=this,{px:w,py:p,pz:m}=c;let y=t.ZERO,B=t.ZERO,b=t.ZERO;const R=e.a,q=t.mul(e.b,ct);let v=t.mul(h,w),O=t.mul(u,p),z=t.mul(d,m),L=t.add(h,u),A=t.add(w,p);L=t.mul(L,A),A=t.add(v,O),L=t.sub(L,A),A=t.add(h,d);let j=t.add(w,m);return A=t.mul(A,j),j=t.add(v,z),A=t.sub(A,j),j=t.add(u,d),y=t.add(p,m),j=t.mul(j,y),y=t.add(O,z),j=t.sub(j,y),b=t.mul(R,A),y=t.mul(q,z),b=t.add(y,b),y=t.sub(O,b),b=t.add(O,b),B=t.mul(y,b),O=t.add(v,v),O=t.add(O,v),z=t.mul(R,z),A=t.mul(q,A),O=t.add(O,z),z=t.sub(v,z),z=t.mul(R,z),A=t.add(A,z),v=t.mul(O,A),B=t.add(B,v),v=t.mul(j,A),y=t.mul(L,y),y=t.sub(y,v),v=t.mul(L,O),b=t.mul(j,b),b=t.add(b,v),new I(y,B,b)}subtract(c){return this.add(c.negate())}is0(){return this.equals(I.ZERO)}multiply(c){const{endo:h}=n;if(!r.isValidNot0(c))throw new Error("invalid scalar: out of range");let u,d;const w=p=>H.wNAFCached(this,p,I.normalizeZ);if(h){const{k1neg:p,k1:m,k2neg:y,k2:B}=h.splitScalar(c),{p:b,f:R}=w(m),{p:q,f:v}=w(B);d=R.add(v),u=Q(h.beta,b,q,p,y)}else{const{p,f:m}=w(c);u=p,d=m}return I.normalizeZ([u,d])[0]}multiplyUnsafe(c){const{endo:h}=n,u=this;if(!r.isValid(c))throw new Error("invalid scalar: out of range");if(c===ot||u.is0())return I.ZERO;if(c===it)return u;if(H.hasPrecomputes(this))return this.multiply(c);if(h){const{k1neg:d,k1:w,k2neg:p,k2:m}=h.splitScalar(c),{p1:y,p2:B}=ye(I,u,w,m);return Q(h.beta,y,B,d,p)}else return H.wNAFCachedUnsafe(u,c)}multiplyAndAddUnsafe(c,h,u){const d=this.multiplyUnsafe(h).add(c.multiplyUnsafe(u));return d.is0()?void 0:d}toAffine(c){return W(this,c)}isTorsionFree(){const{isTorsionFree:c}=n;return i===it?!0:c?c(I,this):H.wNAFCachedUnsafe(this,s).is0()}clearCofactor(){const{clearCofactor:c}=n;return i===it?this:c?c(I,this):this.multiplyUnsafe(i)}toBytes(c=!0){return at("isCompressed",c),this.assertValidity(),f(I,this,c)}toRawBytes(c=!0){return this.toBytes(c)}toHex(c=!0){return st(this.toBytes(c))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}}I.BASE=new I(e.Gx,e.Gy,t.ONE),I.ZERO=new I(t.ZERO,t.ONE,t.ZERO),I.Fp=t,I.Fn=r;const D=r.BITS,H=me(I,n.endo?Math.ceil(D/2):D);return I}function Pt(e){return Uint8Array.of(e?2:3)}function Ie(e,n,t={}){Nt(n,{hash:"function"},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const r=n.randomBytes||Wt,i=n.hmac||((u,...d)=>Jt(n.hash,u,F(...d))),{Fp:s,Fn:o}=e,{ORDER:l,BITS:a}=o;function g(u){const d=l>>it;return u>d}function f(u){return g(u)?o.neg(u):u}function E(u,d){if(!o.isValidNot0(d))throw new Error(`invalid signature ${u}: out of range 1..CURVE.n`)}class x{constructor(d,w,p){E("r",d),E("s",w),this.r=d,this.s=w,p!=null&&(this.recovery=p),Object.freeze(this)}static fromCompact(d){const w=o.BYTES,p=V("compactSignature",d,w*2);return new x(o.fromBytes(p.subarray(0,w)),o.fromBytes(p.subarray(w,w*2)))}static fromDER(d){const{r:w,s:p}=K.toSig(V("DER",d));return new x(w,p)}assertValidity(){}addRecoveryBit(d){return new x(this.r,this.s,d)}recoverPublicKey(d){const w=s.ORDER,{r:p,s:m,recovery:y}=this;if(y==null||![0,1,2,3].includes(y))throw new Error("recovery id invalid");if(l*Be<w&&y>1)throw new Error("recovery id is ambiguous for h>1 curve");const b=y===2||y===3?p+l:p;if(!s.isValid(b))throw new Error("recovery id 2 or 3 invalid");const R=s.toBytes(b),q=e.fromHex(F(Pt((y&1)===0),R)),v=o.inv(b),O=Y(V("msgHash",d)),z=o.create(-O*v),L=o.create(m*v),A=e.BASE.multiplyUnsafe(z).add(q.multiplyUnsafe(L));if(A.is0())throw new Error("point at infinify");return A.assertValidity(),A}hasHighS(){return g(this.s)}normalizeS(){return this.hasHighS()?new x(this.r,o.neg(this.s),this.recovery):this}toBytes(d){if(d==="compact")return F(o.toBytes(this.r),o.toBytes(this.s));if(d==="der")return xt(K.hexFromSig(this));throw new Error("invalid format")}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return st(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return st(this.toBytes("compact"))}}const S=Ft(o,t.allowedPrivateKeyLengths,t.wrapPrivateKey),_={isValidPrivateKey(u){try{return S(u),!0}catch{return!1}},normPrivateKeyToScalar:S,randomPrivateKey:()=>{const u=l;return de(r(Yt(u)),u)},precompute(u=8,d=e.BASE){return d.precompute(u,!1)}};function N(u,d=!0){return e.fromPrivateKey(u).toBytes(d)}function T(u){if(typeof u=="bigint")return!1;if(u instanceof e)return!0;const w=V("key",u).length,p=s.BYTES,m=p+1,y=2*p+1;if(!(t.allowedPrivateKeyLengths||o.BYTES===m))return w===m||w===y}function M(u,d,w=!0){if(T(u)===!0)throw new Error("first arg must be private key");if(T(d)===!1)throw new Error("second arg must be public key");return e.fromHex(d).multiply(S(u)).toBytes(w)}const W=n.bits2int||function(u){if(u.length>8192)throw new Error("input is too large");const d=ut(u),w=u.length*8-a;return w>0?d>>BigInt(w):d},Y=n.bits2int_modN||function(u){return o.create(W(u))},Q=dt(a);function I(u){return ee("num < 2^"+a,u,ot,Q),o.toBytes(u)}function D(u,d,w=H){if(["recovered","canonical"].some(L=>L in w))throw new Error("sign() legacy options not supported");const{hash:p}=n;let{lowS:m,prehash:y,extraEntropy:B}=w;m==null&&(m=!0),u=V("msgHash",u),zt(w),y&&(u=V("prehashed msgHash",p(u)));const b=Y(u),R=S(d),q=[I(R),I(b)];if(B!=null&&B!==!1){const L=B===!0?r(s.BYTES):B;q.push(V("extraEntropy",L))}const v=F(...q),O=b;function z(L){const A=W(L);if(!o.isValidNot0(A))return;const j=o.inv(A),nt=e.BASE.multiply(A).toAffine(),J=o.create(nt.x);if(J===ot)return;const G=o.create(j*o.create(O+J*R));if(G===ot)return;let wt=(nt.x===J?0:2)|Number(nt.y&it),tt=G;return m&&g(G)&&(tt=f(G),wt^=1),new x(J,tt,wt)}return{seed:v,k2sig:z}}const H={lowS:n.lowS,prehash:!1},Z={lowS:n.lowS,prehash:!1};function c(u,d,w=H){const{seed:p,k2sig:m}=D(u,d,w);return re(n.hash.outputLen,o.BYTES,i)(p,m)}e.BASE.precompute(8);function h(u,d,w,p=Z){const m=u;d=V("msgHash",d),w=V("publicKey",w),zt(p);const{lowS:y,prehash:B,format:b}=p;if("strict"in p)throw new Error("options.strict was renamed to lowS");if(b!==void 0&&!["compact","der","js"].includes(b))throw new Error('format must be "compact", "der" or "js"');const R=typeof m=="string"||Lt(m),q=!R&&!b&&typeof m=="object"&&m!==null&&typeof m.r=="bigint"&&typeof m.s=="bigint";if(!R&&!q)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let v,O;try{if(q)if(b===void 0||b==="js")v=new x(m.r,m.s);else throw new Error("invalid format");if(R){try{b!=="compact"&&(v=x.fromDER(m))}catch(tt){if(!(tt instanceof K.Err))throw tt}!v&&b!=="der"&&(v=x.fromCompact(m))}O=e.fromHex(w)}catch{return!1}if(!v||y&&v.hasHighS())return!1;B&&(d=n.hash(d));const{r:z,s:L}=v,A=Y(d),j=o.inv(L),nt=o.create(A*j),J=o.create(z*j),G=e.BASE.multiplyUnsafe(nt).add(O.multiplyUnsafe(J));return G.is0()?!1:o.create(G.x)===z}return Object.freeze({getPublicKey:N,getSharedSecret:M,sign:c,verify:h,utils:_,Point:e,Signature:x})}function Ne(e){const n={a:e.a,b:e.b,p:e.Fp.ORDER,n:e.n,h:e.h,Gx:e.Gx,Gy:e.Gy},t=e.Fp,r=ht(n.n,e.nBitLength),i={Fp:t,Fn:r,allowedPrivateKeyLengths:e.allowedPrivateKeyLengths,allowInfinityPoint:e.allowInfinityPoint,endo:e.endo,wrapPrivateKey:e.wrapPrivateKey,isTorsionFree:e.isTorsionFree,clearCofactor:e.clearCofactor,fromBytes:e.fromBytes,toBytes:e.toBytes};return{CURVE:n,curveOpts:i}}function qe(e){const{CURVE:n,curveOpts:t}=Ne(e),r={hash:e.hash,hmac:e.hmac,randomBytes:e.randomBytes,lowS:e.lowS,bits2int:e.bits2int,bits2int_modN:e.bits2int_modN};return{CURVE:n,curveOpts:t,ecdsaOpts:r}}function Ae(e,n){return Object.assign({},n,{ProjectivePoint:n.Point,CURVE:e})}function _e(e){const{CURVE:n,curveOpts:t,ecdsaOpts:r}=qe(e),i=Se(n,t),s=Ie(i,r,t);return Ae(e,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Ze(e,n){const t=r=>_e({...e,hash:r});return{...t(n),create:t}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const lt={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")};BigInt(0);const Re=BigInt(1),Bt=BigInt(2),Tt=(e,n)=>(e+n/Bt)/n;function Oe(e){const n=lt.p,t=BigInt(3),r=BigInt(6),i=BigInt(11),s=BigInt(22),o=BigInt(23),l=BigInt(44),a=BigInt(88),g=e*e*e%n,f=g*g*e%n,E=k(f,t,n)*f%n,x=k(E,t,n)*f%n,S=k(x,Bt,n)*g%n,_=k(S,i,n)*S%n,N=k(_,s,n)*_%n,T=k(N,l,n)*N%n,M=k(T,a,n)*T%n,W=k(M,l,n)*N%n,Y=k(W,t,n)*f%n,Q=k(Y,o,n)*_%n,I=k(Q,r,n)*g%n,D=k(I,Bt,n);if(!vt.eql(vt.sqr(D),e))throw new Error("Cannot find square root");return D}const vt=ht(lt.p,void 0,void 0,{sqrt:Oe}),Le=Ze({...lt,Fp:vt,lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:e=>{const n=lt.n,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-Re*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=t,o=BigInt("0x100000000000000000000000000000000"),l=Tt(s*e,n),a=Tt(-r*e,n);let g=C(e-l*t-a*i,n),f=C(-l*r-a*s,n);const E=g>o,x=f>o;if(E&&(g=n-g),x&&(f=n-f),g>o||f>o)throw new Error("splitScalar: Endomorphism failed, k="+e);return{k1neg:E,k1:g,k2neg:x,k2:f}}}},Qt);export{Le as secp256k1};
