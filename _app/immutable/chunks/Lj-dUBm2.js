/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */function l(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function b(r,e){return Array.isArray(e)?e.length===0?!0:r?e.every(n=>typeof n=="string"):e.every(n=>Number.isSafeInteger(n)):!1}function B(r){if(typeof r!="function")throw new Error("function expected");return!0}function p(r,e){if(typeof e!="string")throw new Error(`${r}: string expected`);return!0}function a(r){if(!Number.isSafeInteger(r))throw new Error(`invalid integer: ${r}`)}function y(r){if(!Array.isArray(r))throw new Error("array expected")}function g(r,e){if(!b(!0,e))throw new Error(`${r}: array of strings expected`)}function m(r,e){if(!b(!1,e))throw new Error(`${r}: array of numbers expected`)}function R(...r){const e=o=>o,n=(o,s)=>c=>o(s(c)),i=r.map(o=>o.encode).reduceRight(n,e),t=r.map(o=>o.decode).reduce(n,e);return{encode:i,decode:t}}function U(r){const e=typeof r=="string"?r.split(""):r,n=e.length;g("alphabet",e);const i=new Map(e.map((t,o)=>[t,o]));return{encode:t=>(y(t),t.map(o=>{if(!Number.isSafeInteger(o)||o<0||o>=n)throw new Error(`alphabet.encode: digit index outside alphabet "${o}". Allowed: ${r}`);return e[o]})),decode:t=>(y(t),t.map(o=>{p("alphabet.decode",o);const s=i.get(o);if(s===void 0)throw new Error(`Unknown letter: "${o}". Allowed: ${r}`);return s}))}}function k(r=""){return p("join",r),{encode:e=>(g("join.decode",e),e.join(r)),decode:e=>(p("join.decode",e),e.split(r))}}function I(r,e="="){return a(r),p("padding",e),{encode(n){for(g("padding.encode",n);n.length*r%8;)n.push(e);return n},decode(n){g("padding.decode",n);let i=n.length;if(i*r%8)throw new Error("padding: invalid, string should have whole number of bytes");for(;i>0&&n[i-1]===e;i--)if((i-1)*r%8===0)throw new Error("padding: invalid, string has too much padding");return n.slice(0,i)}}}function A(r,e,n){if(e<2)throw new Error(`convertRadix: invalid from=${e}, base cannot be less than 2`);if(n<2)throw new Error(`convertRadix: invalid to=${n}, base cannot be less than 2`);if(y(r),!r.length)return[];let i=0;const t=[],o=Array.from(r,c=>{if(a(c),c<0||c>=e)throw new Error(`invalid integer: ${c}`);return c}),s=o.length;for(;;){let c=0,u=!0;for(let d=i;d<s;d++){const f=o[d],x=e*c,w=x+f;if(!Number.isSafeInteger(w)||x/e!==c||w-f!==x)throw new Error("convertRadix: carry overflow");const j=w/n;c=w%n;const h=Math.floor(j);if(o[d]=h,!Number.isSafeInteger(h)||h*n+c!==w)throw new Error("convertRadix: carry overflow");if(u)h?u=!1:i=d;else continue}if(t.push(c),u)break}for(let c=0;c<r.length-1&&r[c]===0;c++)t.push(0);return t.reverse()}const N=(r,e)=>e===0?r:N(e,r%e),E=(r,e)=>r+(e-N(r,e)),v=(()=>{let r=[];for(let e=0;e<40;e++)r.push(2**e);return r})();function $(r,e,n,i){if(y(r),e<=0||e>32)throw new Error(`convertRadix2: wrong from=${e}`);if(n<=0||n>32)throw new Error(`convertRadix2: wrong to=${n}`);if(E(e,n)>32)throw new Error(`convertRadix2: carry overflow from=${e} to=${n} carryBits=${E(e,n)}`);let t=0,o=0;const s=v[e],c=v[n]-1,u=[];for(const d of r){if(a(d),d>=s)throw new Error(`convertRadix2: invalid data word=${d} from=${e}`);if(t=t<<e|d,o+e>32)throw new Error(`convertRadix2: carry overflow pos=${o} from=${e}`);for(o+=e;o>=n;o-=n)u.push((t>>o-n&c)>>>0);const f=v[o];if(f===void 0)throw new Error("invalid carry");t&=f-1}if(t=t<<n-o&c,!i&&o>=e)throw new Error("Excess padding");if(!i&&t>0)throw new Error(`Non-zero padding: ${t}`);return i&&o>0&&u.push(t>>>0),u}function C(r){a(r);const e=2**8;return{encode:n=>{if(!l(n))throw new Error("radix.encode input should be Uint8Array");return A(Array.from(n),e,r)},decode:n=>(m("radix.decode",n),Uint8Array.from(A(n,r,e)))}}function S(r,e=!1){if(a(r),r<=0||r>32)throw new Error("radix2: bits should be in (0..32]");if(E(8,r)>32||E(r,8)>32)throw new Error("radix2: carry overflow");return{encode:n=>{if(!l(n))throw new Error("radix2.encode input should be Uint8Array");return $(Array.from(n),8,r,!e)},decode:n=>(m("radix2.decode",n),Uint8Array.from($(n,r,8,e)))}}function M(r,e){return a(r),B(e),{encode(n){if(!l(n))throw new Error("checksum.encode: input should be Uint8Array");const i=e(n).slice(0,r),t=new Uint8Array(n.length+r);return t.set(n),t.set(i,n.length),t},decode(n){if(!l(n))throw new Error("checksum.decode: input should be Uint8Array");const i=n.slice(0,-r),t=n.slice(-r),o=e(i).slice(0,r);for(let s=0;s<r;s++)if(o[s]!==t[s])throw new Error("Invalid checksum");return i}}}const O={alphabet:U,chain:R,checksum:M,convertRadix:A,convertRadix2:$,radix:C,radix2:S,join:k,padding:I},V=R(S(5),U("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"),I(5),k(""));export{V as b,O as u};
