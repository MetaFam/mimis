var Y=Object.defineProperty;var H=(r,t,e)=>t in r?Y(r,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):r[t]=e;var c=(r,t,e)=>H(r,typeof t!="symbol"?t+"":t,e);const _=new Uint8Array(0);function Be(r){const t=r.match(/../g);return t!=null?new Uint8Array(t.map(e=>parseInt(e,16))):_}function ee(r,t){if(r===t)return!0;if(r.byteLength!==t.byteLength)return!1;for(let e=0;e<r.byteLength;e++)if(r[e]!==t[e])return!1;return!0}function T(r){if(r instanceof Uint8Array&&r.constructor.name==="Uint8Array")return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);if(ArrayBuffer.isView(r))return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);throw new Error("Unknown type, must be binary type")}function te(r,t){if(r.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),n=0;n<e.length;n++)e[n]=255;for(var o=0;o<r.length;o++){var i=r.charAt(o),s=i.charCodeAt(0);if(e[s]!==255)throw new TypeError(i+" is ambiguous");e[s]=o}var h=r.length,l=r.charAt(0),m=Math.log(h)/Math.log(256),C=Math.log(256)/Math.log(h);function I(a){if(a instanceof Uint8Array||(ArrayBuffer.isView(a)?a=new Uint8Array(a.buffer,a.byteOffset,a.byteLength):Array.isArray(a)&&(a=Uint8Array.from(a))),!(a instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(a.length===0)return"";for(var f=0,S=0,p=0,w=a.length;p!==w&&a[p]===0;)p++,f++;for(var y=(w-p)*C+1>>>0,u=new Uint8Array(y);p!==w;){for(var g=a[p],E=0,b=y-1;(g!==0||E<S)&&b!==-1;b--,E++)g+=256*u[b]>>>0,u[b]=g%h>>>0,g=g/h>>>0;if(g!==0)throw new Error("Non-zero carry");S=E,p++}for(var v=y-S;v!==y&&u[v]===0;)v++;for(var M=l.repeat(f);v<y;++v)M+=r.charAt(u[v]);return M}function U(a){if(typeof a!="string")throw new TypeError("Expected String");if(a.length===0)return new Uint8Array;var f=0;if(a[f]!==" "){for(var S=0,p=0;a[f]===l;)S++,f++;for(var w=(a.length-f)*m+1>>>0,y=new Uint8Array(w);a[f];){var u=e[a.charCodeAt(f)];if(u===255)return;for(var g=0,E=w-1;(u!==0||g<p)&&E!==-1;E--,g++)u+=h*y[E]>>>0,y[E]=u%256>>>0,u=u/256>>>0;if(u!==0)throw new Error("Non-zero carry");p=g,f++}if(a[f]!==" "){for(var b=w-p;b!==w&&y[b]===0;)b++;for(var v=new Uint8Array(S+(w-b)),M=S;b!==w;)v[M++]=y[b++];return v}}}function Z(a){var f=U(a);if(f)return f;throw new Error(`Non-${t} character`)}return{encode:I,decodeUnsafe:U,decode:Z}}var re=te,ne=re;class oe{constructor(t,e,n){c(this,"name");c(this,"prefix");c(this,"baseEncode");this.name=t,this.prefix=e,this.baseEncode=n}encode(t){if(t instanceof Uint8Array)return`${this.prefix}${this.baseEncode(t)}`;throw Error("Unknown type, must be binary type")}}class ie{constructor(t,e,n){c(this,"name");c(this,"prefix");c(this,"baseDecode");c(this,"prefixCodePoint");this.name=t,this.prefix=e;const o=e.codePointAt(0);if(o===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=o,this.baseDecode=n}decode(t){if(typeof t=="string"){if(t.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(t.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(t){return K(this,t)}}class se{constructor(t){c(this,"decoders");this.decoders=t}or(t){return K(this,t)}decode(t){const e=t[0],n=this.decoders[e];if(n!=null)return n.decode(t);throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}function K(r,t){return new se({...r.decoders??{[r.prefix]:r},...t.decoders??{[t.prefix]:t}})}class ae{constructor(t,e,n,o){c(this,"name");c(this,"prefix");c(this,"baseEncode");c(this,"baseDecode");c(this,"encoder");c(this,"decoder");this.name=t,this.prefix=e,this.baseEncode=n,this.baseDecode=o,this.encoder=new oe(t,e,n),this.decoder=new ie(t,e,o)}encode(t){return this.encoder.encode(t)}decode(t){return this.decoder.decode(t)}}function X({name:r,prefix:t,encode:e,decode:n}){return new ae(r,t,e,n)}function D({name:r,prefix:t,alphabet:e}){const{encode:n,decode:o}=ne(e,r);return X({prefix:t,name:r,encode:n,decode:i=>T(o(i))})}function ce(r,t,e,n){let o=r.length;for(;r[o-1]==="=";)--o;const i=new Uint8Array(o*e/8|0);let s=0,h=0,l=0;for(let m=0;m<o;++m){const C=t[r[m]];if(C===void 0)throw new SyntaxError(`Non-${n} character`);h=h<<e|C,s+=e,s>=8&&(s-=8,i[l++]=255&h>>s)}if(s>=e||255&h<<8-s)throw new SyntaxError("Unexpected end of data");return i}function he(r,t,e){const n=t[t.length-1]==="=",o=(1<<e)-1;let i="",s=0,h=0;for(let l=0;l<r.length;++l)for(h=h<<8|r[l],s+=8;s>e;)s-=e,i+=t[o&h>>s];if(s!==0&&(i+=t[o&h<<e-s]),n)for(;i.length*e&7;)i+="=";return i}function de(r){const t={};for(let e=0;e<r.length;++e)t[r[e]]=e;return t}function x({name:r,prefix:t,bitsPerChar:e,alphabet:n}){const o=de(n);return X({prefix:t,name:r,encode(i){return he(i,n,e)},decode(i){return ce(i,o,e,r)}})}const N=x({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5});x({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5});x({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5});x({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5});x({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5});x({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5});x({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5});x({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5});x({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});const L=D({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"});D({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});const A=D({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"});D({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var fe=W,q=128,ue=-128,le=Math.pow(2,31);function W(r,t,e){t=t||[],e=e||0;for(var n=e;r>=le;)t[e++]=r&255|q,r/=128;for(;r&ue;)t[e++]=r&255|q,r>>>=7;return t[e]=r|0,W.bytes=e-n+1,t}var pe=B,be=128,P=127;function B(r,n){var e=0,n=n||0,o=0,i=n,s,h=r.length;do{if(i>=h)throw B.bytes=0,new RangeError("Could not decode varint");s=r[i++],e+=o<28?(s&P)<<o:(s&P)*Math.pow(2,o),o+=7}while(s>=be);return B.bytes=i-n,e}var we=Math.pow(2,7),ye=Math.pow(2,14),ge=Math.pow(2,21),ve=Math.pow(2,28),xe=Math.pow(2,35),me=Math.pow(2,42),Ee=Math.pow(2,49),Ae=Math.pow(2,56),Se=Math.pow(2,63),Ce=function(r){return r<we?1:r<ye?2:r<ge?3:r<ve?4:r<xe?5:r<me?6:r<Ee?7:r<Ae?8:r<Se?9:10},ze={encode:fe,decode:pe,encodingLength:Ce},O=ze;function k(r,t=0){return[O.decode(r,t),O.decode.bytes]}function $(r,t,e=0){return O.encode(r,t,e),t}function V(r){return O.encodingLength(r)}function Ue(r,t){const e=t.byteLength,n=V(r),o=n+V(e),i=new Uint8Array(o+e);return $(r,i,0),$(e,i,n),i.set(t,o),new R(r,e,t,i)}function Me(r){const t=T(r),[e,n]=k(t),[o,i]=k(t.subarray(n)),s=t.subarray(n+i);if(s.byteLength!==o)throw new Error("Incorrect length");return new R(e,o,s,t)}function Ne(r,t){if(r===t)return!0;{const e=t;return r.code===e.code&&r.size===e.size&&e.bytes instanceof Uint8Array&&ee(r.bytes,e.bytes)}}class R{constructor(t,e,n,o){c(this,"code");c(this,"size");c(this,"digest");c(this,"bytes");this.code=t,this.size=e,this.digest=n,this.bytes=o}}function j(r,t){const{bytes:e,version:n}=r;switch(n){case 0:return $e(e,F(r),t??A.encoder);default:return Ve(e,F(r),t??N.encoder)}}const J=new WeakMap;function F(r){const t=J.get(r);if(t==null){const e=new Map;return J.set(r,e),e}return t}var G;class d{constructor(t,e,n,o){c(this,"code");c(this,"version");c(this,"multihash");c(this,"bytes");c(this,"/");c(this,G,"CID");this.code=e,this.version=t,this.multihash=n,this.bytes=o,this["/"]=o}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:t,multihash:e}=this;if(t!==z)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(e.code!==De)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return d.createV0(e)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:t,digest:e}=this.multihash,n=Ue(t,e);return d.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(t){return d.equals(this,t)}static equals(t,e){const n=e;return n!=null&&t.code===n.code&&t.version===n.version&&Ne(t.multihash,n.multihash)}toString(t){return j(this,t)}toJSON(){return{"/":j(this)}}link(){return this}[(G=Symbol.toStringTag,Symbol.for("nodejs.util.inspect.custom"))](){return`CID(${this.toString()})`}static asCID(t){if(t==null)return null;const e=t;if(e instanceof d)return e;if(e["/"]!=null&&e["/"]===e.bytes||e.asCID===e){const{version:n,code:o,multihash:i,bytes:s}=e;return new d(n,o,i,s??Q(n,o,i.bytes))}else if(e[Ie]===!0){const{version:n,multihash:o,code:i}=e,s=Me(o);return d.create(n,i,s)}else return null}static create(t,e,n){if(typeof e!="number")throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(t){case 0:{if(e!==z)throw new Error(`Version 0 CID must use dag-pb (code: ${z}) block encoding`);return new d(t,e,n,n.bytes)}case 1:{const o=Q(t,e,n.bytes);return new d(t,e,n,o)}default:throw new Error("Invalid version")}}static createV0(t){return d.create(0,z,t)}static createV1(t,e){return d.create(1,t,e)}static decode(t){const[e,n]=d.decodeFirst(t);if(n.length!==0)throw new Error("Incorrect length");return e}static decodeFirst(t){const e=d.inspectBytes(t),n=e.size-e.multihashSize,o=T(t.subarray(n,n+e.multihashSize));if(o.byteLength!==e.multihashSize)throw new Error("Incorrect length");const i=o.subarray(e.multihashSize-e.digestSize),s=new R(e.multihashCode,e.digestSize,i,o);return[e.version===0?d.createV0(s):d.createV1(e.codec,s),t.subarray(e.size)]}static inspectBytes(t){let e=0;const n=()=>{const[I,U]=k(t.subarray(e));return e+=U,I};let o=n(),i=z;if(o===18?(o=0,e=0):i=n(),o!==0&&o!==1)throw new RangeError(`Invalid CID version ${o}`);const s=e,h=n(),l=n(),m=e+l,C=m-s;return{version:o,codec:i,multihashCode:h,digestSize:l,multihashSize:C,size:m}}static parse(t,e){const[n,o]=Oe(t,e),i=d.decode(o);if(i.version===0&&t[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return F(i).set(n,t),i}}function Oe(r,t){switch(r[0]){case"Q":{const e=t??A;return[A.prefix,e.decode(`${A.prefix}${r}`)]}case A.prefix:{const e=t??A;return[A.prefix,e.decode(r)]}case N.prefix:{const e=t??N;return[N.prefix,e.decode(r)]}case L.prefix:{const e=t??L;return[L.prefix,e.decode(r)]}default:{if(t==null)throw Error("To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided");return[r[0],t.decode(r)]}}}function $e(r,t,e){const{prefix:n}=e;if(n!==A.prefix)throw Error(`Cannot string encode V0 in ${e.name} encoding`);const o=t.get(n);if(o==null){const i=e.encode(r).slice(1);return t.set(n,i),i}else return o}function Ve(r,t,e){const{prefix:n}=e,o=t.get(n);if(o==null){const i=e.encode(r);return t.set(n,i),i}else return o}const z=112,De=18;function Q(r,t,e){const n=V(r),o=n+V(t),i=new Uint8Array(o+e.byteLength);return $(r,i,0),$(t,i,n),i.set(e,o),i}const Ie=Symbol.for("@ipld/js-cid/CID");export{d as C,T as a,Ue as c,Me as d,Be as f};
