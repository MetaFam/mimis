import{a as y}from"./BuFIMopG.js";import{n as f}from"./OurnOBNA.js";import{d as g,b as m,e as b,f as k,g as L,c as W,h as p}from"./yWm7hIJd.js";import"./BM23hdiM.js";function T(e,t,r,s,i,n){var o=e.__className;if(f||o!==r||o===void 0){var c=y(r,s,n);(!f||c!==e.getAttribute("class"))&&(c==null?e.removeAttribute("class"):e.className=c),e.__className=r}else if(n&&i!==n)for(var a in n){var l=!!n[a];(i==null||l!==!!i[a])&&e.classList.toggle(a,l)}return n}const D=g,$=({writer:e,settings:t=D(),metadata:r={}})=>new w({writer:e,metadata:r,settings:t,entries:new Map,closed:!1}),z=(e,t,r,{overwrite:s=!1}={})=>{const i=h(e.state);if(t.includes("/"))throw new Error(`Directory entry name "${t}" contains forbidden "/" character`);if(!s&&i.entries.has(t))throw new Error(`Directory already contains entry with name "${t}"`);return i.entries.set(t,r),e},B=(e,t)=>(h(e.state).entries.delete(t),e),h=e=>{if(e.closed)throw new Error("Can not change written directory, but you can .fork() and make changes to it");return e},C=async(e,{closeWriter:t=!1,releaseLock:r=!1}={})=>{const{writer:s,settings:i,metadata:n}=h(e.state);e.state.closed=!0;const o=[...d(e)],c=m(o,n),a=b(c),l=await i.hasher.digest(a),u=i.linker.createLink(k,l);return(s.desiredSize||0)<=0&&await s.ready,s.write({cid:u,bytes:a}),t?await s.close():r&&s.releaseLock(),{cid:u,dagByteLength:L(a,o)}},d=function*({state:e}){for(const[t,{dagByteLength:r,cid:s}]of e.entries)yield{name:t,dagByteLength:r,cid:s}},E=({state:e},{writer:t=e.writer,metadata:r=e.metadata,settings:s=e.settings}={})=>new w({writer:t,metadata:r,settings:s,entries:new Map(e.entries.entries()),closed:!1});class w{constructor(t){this.state=t}get writer(){return this.state.writer}get settings(){return this.state.settings}links(){return d(this)}set(t,r,s){return z(this,t,r,s)}remove(t){return B(this,t)}fork(t){return E(this,t)}close(t){return C(this,t)}entries(){return this.state.entries.entries()}has(t){return this.state.entries.has(t)}get size(){return this.state.entries.size}}const Z=({writable:e,settings:t=g()})=>new F({writer:e.getWriter(),settings:t}),M=async(e,{releaseLock:t=!0,closeWriter:r=!0}={})=>(r?await e.writer.close():t&&e.writer.releaseLock(),e);class F{constructor({writer:t,settings:r}){this.writer=t,this.settings=W(r)}createFileWriter({settings:t=this.settings,metadata:r}={}){return p({writer:this.writer,settings:t,metadata:r})}createDirectoryWriter({settings:t=this.settings,metadata:r}={}){return $({writer:this.writer,settings:t,metadata:r})}close(t){return M(this,t)}}const I=1048576,N=I*100,j=(e=N)=>({highWaterMark:e,size:t=>t.bytes.length});export{z as a,$ as b,Z as c,B as r,T as s,j as w};
