import{s as Kt,h as Vt}from"./CPkM1KpG.js";import{z as T}from"./DA0walB8.js";/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const gt=BigInt(0),mt=BigInt(1);function at(e,n){if(typeof n!="boolean")throw new Error(e+" boolean expected, got "+n)}function it(e){const n=e.toString(16);return n.length&1?"0"+n:n}function At(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);return e===""?gt:BigInt("0x"+e)}function ct(e){return At(T.bytesToHex(e))}function It(e){return T.abytes(e),At(T.bytesToHex(Uint8Array.from(e).reverse()))}function yt(e,n){return T.hexToBytes(e.toString(16).padStart(n*2,"0"))}function _t(e,n){return yt(e,n).reverse()}function M(e,n,t){let r;if(typeof n=="string")try{r=T.hexToBytes(n)}catch(s){throw new Error(e+" must be hex string or Uint8Array, cause: "+s)}else if(T.isBytes(n))r=Uint8Array.from(n);else throw new Error(e+" must be hex string or Uint8Array");const i=r.length;if(typeof t=="number"&&i!==t)throw new Error(e+" of length "+t+" expected, got "+i);return r}const ut=e=>typeof e=="bigint"&&gt<=e;function Ct(e,n,t){return ut(e)&&ut(n)&&ut(t)&&n<=e&&e<t}function Yt(e,n,t,r){if(!Ct(n,t,r))throw new Error("expected valid "+e+": "+t+" <= n < "+r+", got "+n)}function kt(e){let n;for(n=0;e>gt;e>>=mt,n+=1);return n}const lt=e=>(mt<<BigInt(e))-mt;function Dt(e,n,t){if(typeof e!="number"||e<2)throw new Error("hashLen must be a number");if(typeof n!="number"||n<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");const r=x=>new Uint8Array(x),i=x=>Uint8Array.of(x);let s=r(e),o=r(e),u=0;const l=()=>{s.fill(1),o.fill(0),u=0},p=(...x)=>t(o,s,...x),a=(x=r(0))=>{o=p(i(0),x),s=p(),x.length!==0&&(o=p(i(1),x),s=p())},B=()=>{if(u++>=1e3)throw new Error("drbg: tried 1000 values");let x=0;const z=[];for(;x<n;){s=p();const I=s.slice();z.push(I),x+=s.length}return T.concatBytes(...z)};return(x,z)=>{l(),a(x);let I;for(;!(I=z(B()));)a();return l(),I}}function pt(e,n,t={}){if(!e||typeof e!="object")throw new Error("expected valid options object");function r(i,s,o){const u=e[i];if(o&&u===void 0)return;const l=typeof u;if(l!==s||u===null)throw new Error(`param "${i}" is invalid: expected ${s}, got ${l}`)}Object.entries(n).forEach(([i,s])=>r(i,s,!1)),Object.entries(t).forEach(([i,s])=>r(i,s,!0))}function bt(e){const n=new WeakMap;return(t,...r)=>{const i=n.get(t);if(i!==void 0)return i;const s=e(t,...r);return n.set(t,s),s}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const $=BigInt(0),L=BigInt(1),D=BigInt(2),Gt=BigInt(3),Tt=BigInt(4),zt=BigInt(5),Zt=BigInt(8);function K(e,n){const t=e%n;return t>=$?t:n+t}function ve(e,n,t){let r=e;for(;n-- >$;)r*=r,r%=t;return r}function vt(e,n){if(e===$)throw new Error("invert: expected non-zero number");if(n<=$)throw new Error("invert: expected positive modulus, got "+n);let t=K(e,n),r=n,i=$,s=L;for(;t!==$;){const u=r/t,l=r%t,p=i-s*u;r=t,t=l,i=s,s=p}if(r!==L)throw new Error("invert: does not exist");return K(i,n)}function Rt(e,n){const t=(e.ORDER+L)/Tt,r=e.pow(n,t);if(!e.eql(e.sqr(r),n))throw new Error("Cannot find square root");return r}function Ft(e,n){const t=(e.ORDER-zt)/Zt,r=e.mul(n,D),i=e.pow(r,t),s=e.mul(n,i),o=e.mul(e.mul(s,D),i),u=e.mul(s,e.sub(o,e.ONE));if(!e.eql(e.sqr(u),n))throw new Error("Cannot find square root");return u}function Xt(e){if(e<BigInt(3))throw new Error("sqrt is not defined for small field");let n=e-L,t=0;for(;n%D===$;)n/=D,t++;let r=D;const i=Et(e);for(;Bt(i,r)===1;)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(t===1)return Rt;let s=i.pow(r,n);const o=(n+L)/D;return function(l,p){if(l.is0(p))return p;if(Bt(l,p)!==1)throw new Error("Cannot find square root");let a=t,B=l.mul(l.ONE,s),S=l.pow(p,n),x=l.pow(p,o);for(;!l.eql(S,l.ONE);){if(l.is0(S))return l.ZERO;let z=1,I=l.sqr(S);for(;!l.eql(I,l.ONE);)if(z++,I=l.sqr(I),z===a)throw new Error("Cannot find square root");const U=L<<BigInt(a-z-1),V=l.pow(B,U);a=z,B=l.sqr(V),S=l.mul(S,B),x=l.mul(x,V)}return x}}function Pt(e){return e%Tt===Gt?Rt:e%Zt===zt?Ft:Xt(e)}const Be=(e,n)=>(K(e,n)&L)===L,Wt=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Qt(e){const n={ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"},t=Wt.reduce((r,i)=>(r[i]="function",r),n);return pt(e,t),e}function Jt(e,n,t){if(t<$)throw new Error("invalid exponent, negatives unsupported");if(t===$)return e.ONE;if(t===L)return n;let r=e.ONE,i=n;for(;t>$;)t&L&&(r=e.mul(r,i)),i=e.sqr(i),t>>=L;return r}function Ot(e,n,t=!1){const r=new Array(n.length).fill(t?e.ZERO:void 0),i=n.reduce((o,u,l)=>e.is0(u)?o:(r[l]=o,e.mul(o,u)),e.ONE),s=e.inv(i);return n.reduceRight((o,u,l)=>e.is0(u)?o:(r[l]=e.mul(o,r[l]),e.mul(o,u)),s),r}function Bt(e,n){const t=(e.ORDER-L)/D,r=e.pow(n,t),i=e.eql(r,e.ONE),s=e.eql(r,e.ZERO),o=e.eql(r,e.neg(e.ONE));if(!i&&!s&&!o)throw new Error("invalid Legendre symbol result");return i?1:s?0:-1}function te(e,n){n!==void 0&&T.anumber(n);const t=n!==void 0?n:e.toString(2).length,r=Math.ceil(t/8);return{nBitLength:t,nByteLength:r}}function Et(e,n,t=!1,r={}){if(e<=$)throw new Error("invalid field: expected ORDER > 0, got "+e);let i,s;if(typeof n=="object"&&n!=null){if(r.sqrt||t)throw new Error("cannot specify opts in two arguments");const a=n;a.BITS&&(i=a.BITS),a.sqrt&&(s=a.sqrt),typeof a.isLE=="boolean"&&(t=a.isLE)}else typeof n=="number"&&(i=n),r.sqrt&&(s=r.sqrt);const{nBitLength:o,nByteLength:u}=te(e,i);if(u>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let l;const p=Object.freeze({ORDER:e,isLE:t,BITS:o,BYTES:u,MASK:lt(o),ZERO:$,ONE:L,create:a=>K(a,e),isValid:a=>{if(typeof a!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof a);return $<=a&&a<e},is0:a=>a===$,isValidNot0:a=>!p.is0(a)&&p.isValid(a),isOdd:a=>(a&L)===L,neg:a=>K(-a,e),eql:(a,B)=>a===B,sqr:a=>K(a*a,e),add:(a,B)=>K(a+B,e),sub:(a,B)=>K(a-B,e),mul:(a,B)=>K(a*B,e),pow:(a,B)=>Jt(p,a,B),div:(a,B)=>K(a*vt(B,e),e),sqrN:a=>a*a,addN:(a,B)=>a+B,subN:(a,B)=>a-B,mulN:(a,B)=>a*B,inv:a=>vt(a,e),sqrt:s||(a=>(l||(l=Pt(e)),l(p,a))),toBytes:a=>t?_t(a,u):yt(a,u),fromBytes:a=>{if(a.length!==u)throw new Error("Field.fromBytes: expected "+u+" bytes, got "+a.length);return t?It(a):ct(a)},invertBatch:a=>Ot(p,a),cmov:(a,B,S)=>S?B:a});return Object.freeze(p)}function Lt(e){if(typeof e!="bigint")throw new Error("field order must be bigint");const n=e.toString(2).length;return Math.ceil(n/8)}function jt(e){const n=Lt(e);return n+Math.ceil(n/2)}function ee(e,n,t=!1){const r=e.length,i=Lt(n),s=jt(n);if(r<16||r<s||r>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+r);const o=t?It(e):ct(e),u=K(o,n-L)+L;return t?_t(u,i):yt(u,i)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const P=BigInt(0),G=BigInt(1);function J(e,n){const t=n.negate();return e?t:n}function ne(e,n,t){const r=n==="pz"?o=>o.pz:o=>o.ez,i=Ot(e.Fp,t.map(r));return t.map((o,u)=>o.toAffine(i[u])).map(e.fromAffine)}function Ht(e,n){if(!Number.isSafeInteger(e)||e<=0||e>n)throw new Error("invalid window size, expected [1.."+n+"], got W="+e)}function dt(e,n){Ht(e,n);const t=Math.ceil(n/e)+1,r=2**(e-1),i=2**e,s=lt(e),o=BigInt(e);return{windows:t,windowSize:r,mask:s,maxNumber:i,shiftBy:o}}function xt(e,n,t){const{windowSize:r,mask:i,maxNumber:s,shiftBy:o}=t;let u=Number(e&i),l=e>>o;u>r&&(u-=s,l+=G);const p=n*r,a=p+Math.abs(u)-1,B=u===0,S=u<0,x=n%2!==0;return{nextN:l,offset:a,isZero:B,isNeg:S,isNegF:x,offsetF:p}}function re(e,n){if(!Array.isArray(e))throw new Error("array expected");e.forEach((t,r)=>{if(!(t instanceof n))throw new Error("invalid point at index "+r)})}function oe(e,n){if(!Array.isArray(e))throw new Error("array of scalars expected");e.forEach((t,r)=>{if(!n.isValid(t))throw new Error("invalid scalar at index "+r)})}const ht=new WeakMap,Ut=new WeakMap;function wt(e){return Ut.get(e)||1}function St(e){if(e!==P)throw new Error("invalid wNAF")}function ie(e,n){return{constTimeNegate:J,hasPrecomputes(t){return wt(t)!==1},unsafeLadder(t,r,i=e.ZERO){let s=t;for(;r>P;)r&G&&(i=i.add(s)),s=s.double(),r>>=G;return i},precomputeWindow(t,r){const{windows:i,windowSize:s}=dt(r,n),o=[];let u=t,l=u;for(let p=0;p<i;p++){l=u,o.push(l);for(let a=1;a<s;a++)l=l.add(u),o.push(l);u=l.double()}return o},wNAF(t,r,i){let s=e.ZERO,o=e.BASE;const u=dt(t,n);for(let l=0;l<u.windows;l++){const{nextN:p,offset:a,isZero:B,isNeg:S,isNegF:x,offsetF:z}=xt(i,l,u);i=p,B?o=o.add(J(x,r[z])):s=s.add(J(S,r[a]))}return St(i),{p:s,f:o}},wNAFUnsafe(t,r,i,s=e.ZERO){const o=dt(t,n);for(let u=0;u<o.windows&&i!==P;u++){const{nextN:l,offset:p,isZero:a,isNeg:B}=xt(i,u,o);if(i=l,!a){const S=r[p];s=s.add(B?S.negate():S)}}return St(i),s},getPrecomputes(t,r,i){let s=ht.get(r);return s||(s=this.precomputeWindow(r,t),t!==1&&(typeof i=="function"&&(s=i(s)),ht.set(r,s))),s},wNAFCached(t,r,i){const s=wt(t);return this.wNAF(s,this.getPrecomputes(s,t,i),r)},wNAFCachedUnsafe(t,r,i,s){const o=wt(t);return o===1?this.unsafeLadder(t,r,s):this.wNAFUnsafe(o,this.getPrecomputes(o,t,i),r,s)},setWindowSize(t,r){Ht(r,n),Ut.set(t,r),ht.delete(t)}}}function se(e,n,t,r){let i=n,s=e.ZERO,o=e.ZERO;for(;t>P||r>P;)t&G&&(s=s.add(i)),r&G&&(o=o.add(i)),i=i.double(),t>>=G,r>>=G;return{p1:s,p2:o}}function ae(e,n,t,r){re(t,e),oe(r,n);const i=t.length,s=r.length;if(i!==s)throw new Error("arrays of points and scalars must have equal length");const o=e.ZERO,u=kt(BigInt(i));let l=1;u>12?l=u-3:u>4?l=u-2:u>0&&(l=2);const p=lt(l),a=new Array(Number(p)+1).fill(o),B=Math.floor((n.BITS-1)/l)*l;let S=o;for(let x=B;x>=0;x-=l){a.fill(o);for(let I=0;I<s;I++){const U=r[I],V=Number(U>>BigInt(x)&p);a[V]=a[V].add(t[I])}let z=o;for(let I=a.length-1,U=o;I>0;I--)U=U.add(a[I]),z=z.add(U);if(S=S.add(z),x!==0)for(let I=0;I<l;I++)S=S.double()}return S}function Nt(e,n){if(n){if(n.ORDER!==e)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return Qt(n),n}else return Et(e)}function ce(e,n,t={}){if(!n||typeof n!="object")throw new Error(`expected valid ${e} CURVE object`);for(const u of["p","n","h"]){const l=n[u];if(!(typeof l=="bigint"&&l>P))throw new Error(`CURVE.${u} must be positive bigint`)}const r=Nt(n.p,t.Fp),i=Nt(n.n,t.Fn),o=["Gx","Gy","a",e==="weierstrass"?"b":"d"];for(const u of o)if(!r.isValid(n[u]))throw new Error(`CURVE.${u} must be valid field element of CURVE.Fp`);return{Fp:r,Fn:i}}const xe=Kt;/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function qt(e){e.lowS!==void 0&&at("lowS",e.lowS),e.prehash!==void 0&&at("prehash",e.prehash)}class le extends Error{constructor(n=""){super(n)}}const C={Err:le,_tlv:{encode:(e,n)=>{const{Err:t}=C;if(e<0||e>256)throw new t("tlv.encode: wrong tag");if(n.length&1)throw new t("tlv.encode: unpadded data");const r=n.length/2,i=it(r);if(i.length/2&128)throw new t("tlv.encode: long form length too big");const s=r>127?it(i.length/2|128):"";return it(e)+s+i+n},decode(e,n){const{Err:t}=C;let r=0;if(e<0||e>256)throw new t("tlv.encode: wrong tag");if(n.length<2||n[r++]!==e)throw new t("tlv.decode: wrong tlv");const i=n[r++],s=!!(i&128);let o=0;if(!s)o=i;else{const l=i&127;if(!l)throw new t("tlv.decode(long): indefinite length not supported");if(l>4)throw new t("tlv.decode(long): byte length is too big");const p=n.subarray(r,r+l);if(p.length!==l)throw new t("tlv.decode: length bytes not complete");if(p[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(const a of p)o=o<<8|a;if(r+=l,o<128)throw new t("tlv.decode(long): not minimal encoding")}const u=n.subarray(r,r+o);if(u.length!==o)throw new t("tlv.decode: wrong value length");return{v:u,l:n.subarray(r+o)}}},_int:{encode(e){const{Err:n}=C;if(e<tt)throw new n("integer: negative integers are not allowed");let t=it(e);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new n("unexpected DER parsing assertion: unpadded hex");return t},decode(e){const{Err:n}=C;if(e[0]&128)throw new n("invalid signature integer: negative");if(e[0]===0&&!(e[1]&128))throw new n("invalid signature integer: unnecessary leading zero");return ct(e)}},toSig(e){const{Err:n,_int:t,_tlv:r}=C,i=M("signature",e),{v:s,l:o}=r.decode(48,i);if(o.length)throw new n("invalid signature: left bytes after parsing");const{v:u,l}=r.decode(2,s),{v:p,l:a}=r.decode(2,l);if(a.length)throw new n("invalid signature: left bytes after parsing");return{r:t.decode(u),s:t.decode(p)}},hexFromSig(e){const{_tlv:n,_int:t}=C,r=n.encode(2,t.encode(e.r)),i=n.encode(2,t.encode(e.s)),s=r+i;return n.encode(48,s)}},tt=BigInt(0),et=BigInt(1),fe=BigInt(2),st=BigInt(3),ue=BigInt(4);function de(e,n,t){function r(i){const s=e.sqr(i),o=e.mul(s,i);return e.add(e.add(o,e.mul(i,n)),t)}return r}function $t(e,n,t){const{BYTES:r}=e;function i(s){let o;if(typeof s=="bigint")o=s;else{let u=M("private key",s);if(n){if(!n.includes(u.length*2))throw new Error("invalid private key");const l=new Uint8Array(r);l.set(u,l.length-u.length),u=l}try{o=e.fromBytes(u)}catch{throw new Error(`invalid private key: expected ui8a of size ${r}, got ${typeof s}`)}}if(t&&(o=e.create(o)),!e.isValidNot0(o))throw new Error("invalid private key: out of range [1..N-1]");return o}return i}function he(e,n={}){const{Fp:t,Fn:r}=ce("weierstrass",e,n),{h:i,n:s}=e;pt(n,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:o}=n;if(o&&(!t.is0(e.a)||typeof o.beta!="bigint"||typeof o.splitScalar!="function"))throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');function u(){if(!t.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function l(_,c,h){const{x:f,y:d}=c.toAffine(),w=t.toBytes(f);if(at("isCompressed",h),h){u();const y=!t.isOdd(d);return T.concatBytes(Mt(y),w)}else return T.concatBytes(Uint8Array.of(4),w,t.toBytes(d))}function p(_){T.abytes(_);const c=t.BYTES,h=c+1,f=2*c+1,d=_.length,w=_[0],y=_.subarray(1);if(d===h&&(w===2||w===3)){const m=t.fromBytes(y);if(!t.isValid(m))throw new Error("bad point: is not on curve, wrong x");const g=S(m);let b;try{b=t.sqrt(g)}catch(q){const v=q instanceof Error?": "+q.message:"";throw new Error("bad point: is not on curve, sqrt error"+v)}u();const E=t.isOdd(b);return(w&1)===1!==E&&(b=t.neg(b)),{x:m,y:b}}else if(d===f&&w===4){const m=t.fromBytes(y.subarray(c*0,c*1)),g=t.fromBytes(y.subarray(c*1,c*2));if(!x(m,g))throw new Error("bad point: is not on curve");return{x:m,y:g}}else throw new Error(`bad point: got length ${d}, expected compressed=${h} or uncompressed=${f}`)}const a=n.toBytes||l,B=n.fromBytes||p,S=de(t,e.a,e.b);function x(_,c){const h=t.sqr(c),f=S(_);return t.eql(h,f)}if(!x(e.Gx,e.Gy))throw new Error("bad curve params: generator point");const z=t.mul(t.pow(e.a,st),ue),I=t.mul(t.sqr(e.b),BigInt(27));if(t.is0(t.add(z,I)))throw new Error("bad curve params: a or b");function U(_,c,h=!1){if(!t.isValid(c)||h&&t.is0(c))throw new Error(`bad point coordinate ${_}`);return c}function V(_){if(!(_ instanceof N))throw new Error("ProjectivePoint expected")}const nt=bt((_,c)=>{const{px:h,py:f,pz:d}=_;if(t.eql(d,t.ONE))return{x:h,y:f};const w=_.is0();c==null&&(c=w?t.ONE:t.inv(d));const y=t.mul(h,c),m=t.mul(f,c),g=t.mul(d,c);if(w)return{x:t.ZERO,y:t.ZERO};if(!t.eql(g,t.ONE))throw new Error("invZ was invalid");return{x:y,y:m}}),W=bt(_=>{if(_.is0()){if(n.allowInfinityPoint&&!t.is0(_.py))return;throw new Error("bad point: ZERO")}const{x:c,y:h}=_.toAffine();if(!t.isValid(c)||!t.isValid(h))throw new Error("bad point: x or y not field elements");if(!x(c,h))throw new Error("bad point: equation left != right");if(!_.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function rt(_,c,h,f,d){return h=new N(t.mul(h.px,_),h.py,h.pz),c=J(f,c),h=J(d,h),c.add(h)}class N{constructor(c,h,f){this.px=U("x",c),this.py=U("y",h,!0),this.pz=U("z",f),Object.freeze(this)}static fromAffine(c){const{x:h,y:f}=c||{};if(!c||!t.isValid(h)||!t.isValid(f))throw new Error("invalid affine point");if(c instanceof N)throw new Error("projective point not allowed");return t.is0(h)&&t.is0(f)?N.ZERO:new N(h,f,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(c){return ne(N,"pz",c)}static fromBytes(c){return T.abytes(c),N.fromHex(c)}static fromHex(c){const h=N.fromAffine(B(M("pointHex",c)));return h.assertValidity(),h}static fromPrivateKey(c){const h=$t(r,n.allowedPrivateKeyLengths,n.wrapPrivateKey);return N.BASE.multiply(h(c))}static msm(c,h){return ae(N,r,c,h)}precompute(c=8,h=!0){return Y.setWindowSize(this,c),h||this.multiply(st),this}_setWindowSize(c){this.precompute(c)}assertValidity(){W(this)}hasEvenY(){const{y:c}=this.toAffine();if(!t.isOdd)throw new Error("Field doesn't support isOdd");return!t.isOdd(c)}equals(c){V(c);const{px:h,py:f,pz:d}=this,{px:w,py:y,pz:m}=c,g=t.eql(t.mul(h,m),t.mul(w,d)),b=t.eql(t.mul(f,m),t.mul(y,d));return g&&b}negate(){return new N(this.px,t.neg(this.py),this.pz)}double(){const{a:c,b:h}=e,f=t.mul(h,st),{px:d,py:w,pz:y}=this;let m=t.ZERO,g=t.ZERO,b=t.ZERO,E=t.mul(d,d),Z=t.mul(w,w),q=t.mul(y,y),v=t.mul(d,w);return v=t.add(v,v),b=t.mul(d,y),b=t.add(b,b),m=t.mul(c,b),g=t.mul(f,q),g=t.add(m,g),m=t.sub(Z,g),g=t.add(Z,g),g=t.mul(m,g),m=t.mul(v,m),b=t.mul(f,b),q=t.mul(c,q),v=t.sub(E,q),v=t.mul(c,v),v=t.add(v,b),b=t.add(E,E),E=t.add(b,E),E=t.add(E,q),E=t.mul(E,v),g=t.add(g,E),q=t.mul(w,y),q=t.add(q,q),E=t.mul(q,v),m=t.sub(m,E),b=t.mul(q,Z),b=t.add(b,b),b=t.add(b,b),new N(m,g,b)}add(c){V(c);const{px:h,py:f,pz:d}=this,{px:w,py:y,pz:m}=c;let g=t.ZERO,b=t.ZERO,E=t.ZERO;const Z=e.a,q=t.mul(e.b,st);let v=t.mul(h,w),R=t.mul(f,y),O=t.mul(d,m),j=t.add(h,f),A=t.add(w,y);j=t.mul(j,A),A=t.add(v,R),j=t.sub(j,A),A=t.add(h,d);let H=t.add(w,m);return A=t.mul(A,H),H=t.add(v,O),A=t.sub(A,H),H=t.add(f,d),g=t.add(y,m),H=t.mul(H,g),g=t.add(R,O),H=t.sub(H,g),E=t.mul(Z,A),g=t.mul(q,O),E=t.add(g,E),g=t.sub(R,E),E=t.add(R,E),b=t.mul(g,E),R=t.add(v,v),R=t.add(R,v),O=t.mul(Z,O),A=t.mul(q,A),R=t.add(R,O),O=t.sub(v,O),O=t.mul(Z,O),A=t.add(A,O),v=t.mul(R,A),b=t.add(b,v),v=t.mul(H,A),g=t.mul(j,g),g=t.sub(g,v),v=t.mul(j,R),E=t.mul(H,E),E=t.add(E,v),new N(g,b,E)}subtract(c){return this.add(c.negate())}is0(){return this.equals(N.ZERO)}multiply(c){const{endo:h}=n;if(!r.isValidNot0(c))throw new Error("invalid scalar: out of range");let f,d;const w=y=>Y.wNAFCached(this,y,N.normalizeZ);if(h){const{k1neg:y,k1:m,k2neg:g,k2:b}=h.splitScalar(c),{p:E,f:Z}=w(m),{p:q,f:v}=w(b);d=Z.add(v),f=rt(h.beta,E,q,y,g)}else{const{p:y,f:m}=w(c);f=y,d=m}return N.normalizeZ([f,d])[0]}multiplyUnsafe(c){const{endo:h}=n,f=this;if(!r.isValid(c))throw new Error("invalid scalar: out of range");if(c===tt||f.is0())return N.ZERO;if(c===et)return f;if(Y.hasPrecomputes(this))return this.multiply(c);if(h){const{k1neg:d,k1:w,k2neg:y,k2:m}=h.splitScalar(c),{p1:g,p2:b}=se(N,f,w,m);return rt(h.beta,g,b,d,y)}else return Y.wNAFCachedUnsafe(f,c)}multiplyAndAddUnsafe(c,h,f){const d=this.multiplyUnsafe(h).add(c.multiplyUnsafe(f));return d.is0()?void 0:d}toAffine(c){return nt(this,c)}isTorsionFree(){const{isTorsionFree:c}=n;return i===et?!0:c?c(N,this):Y.wNAFCachedUnsafe(this,s).is0()}clearCofactor(){const{clearCofactor:c}=n;return i===et?this:c?c(N,this):this.multiplyUnsafe(i)}toBytes(c=!0){return at("isCompressed",c),this.assertValidity(),a(N,this,c)}toRawBytes(c=!0){return this.toBytes(c)}toHex(c=!0){return T.bytesToHex(this.toBytes(c))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}}N.BASE=new N(e.Gx,e.Gy,t.ONE),N.ZERO=new N(t.ZERO,t.ONE,t.ZERO),N.Fp=t,N.Fn=r;const ot=r.BITS,Y=ie(N,n.endo?Math.ceil(ot/2):ot);return N}function Mt(e){return Uint8Array.of(e?2:3)}function we(e,n,t={}){pt(n,{hash:"function"},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const r=n.randomBytes||T.randomBytes,i=n.hmac||((f,...d)=>Vt(n.hash,f,T.concatBytes(...d))),{Fp:s,Fn:o}=e,{ORDER:u,BITS:l}=o;function p(f){const d=u>>et;return f>d}function a(f){return p(f)?o.neg(f):f}function B(f,d){if(!o.isValidNot0(d))throw new Error(`invalid signature ${f}: out of range 1..CURVE.n`)}class S{constructor(d,w,y){B("r",d),B("s",w),this.r=d,this.s=w,y!=null&&(this.recovery=y),Object.freeze(this)}static fromCompact(d){const w=o.BYTES,y=M("compactSignature",d,w*2);return new S(o.fromBytes(y.subarray(0,w)),o.fromBytes(y.subarray(w,w*2)))}static fromDER(d){const{r:w,s:y}=C.toSig(M("DER",d));return new S(w,y)}assertValidity(){}addRecoveryBit(d){return new S(this.r,this.s,d)}recoverPublicKey(d){const w=s.ORDER,{r:y,s:m,recovery:g}=this;if(g==null||![0,1,2,3].includes(g))throw new Error("recovery id invalid");if(u*fe<w&&g>1)throw new Error("recovery id is ambiguous for h>1 curve");const E=g===2||g===3?y+u:y;if(!s.isValid(E))throw new Error("recovery id 2 or 3 invalid");const Z=s.toBytes(E),q=e.fromHex(T.concatBytes(Mt((g&1)===0),Z)),v=o.inv(E),R=W(M("msgHash",d)),O=o.create(-R*v),j=o.create(m*v),A=e.BASE.multiplyUnsafe(O).add(q.multiplyUnsafe(j));if(A.is0())throw new Error("point at infinify");return A.assertValidity(),A}hasHighS(){return p(this.s)}normalizeS(){return this.hasHighS()?new S(this.r,o.neg(this.s),this.recovery):this}toBytes(d){if(d==="compact")return T.concatBytes(o.toBytes(this.r),o.toBytes(this.s));if(d==="der")return T.hexToBytes(C.hexFromSig(this));throw new Error("invalid format")}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return T.bytesToHex(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return T.bytesToHex(this.toBytes("compact"))}}const x=$t(o,t.allowedPrivateKeyLengths,t.wrapPrivateKey),z={isValidPrivateKey(f){try{return x(f),!0}catch{return!1}},normPrivateKeyToScalar:x,randomPrivateKey:()=>{const f=u;return ee(r(jt(f)),f)},precompute(f=8,d=e.BASE){return d.precompute(f,!1)}};function I(f,d=!0){return e.fromPrivateKey(f).toBytes(d)}function U(f){if(typeof f=="bigint")return!1;if(f instanceof e)return!0;const w=M("key",f).length,y=s.BYTES,m=y+1,g=2*y+1;if(!(t.allowedPrivateKeyLengths||o.BYTES===m))return w===m||w===g}function V(f,d,w=!0){if(U(f)===!0)throw new Error("first arg must be private key");if(U(d)===!1)throw new Error("second arg must be public key");return e.fromHex(d).multiply(x(f)).toBytes(w)}const nt=n.bits2int||function(f){if(f.length>8192)throw new Error("input is too large");const d=ct(f),w=f.length*8-l;return w>0?d>>BigInt(w):d},W=n.bits2int_modN||function(f){return o.create(nt(f))},rt=lt(l);function N(f){return Yt("num < 2^"+l,f,tt,rt),o.toBytes(f)}function ot(f,d,w=Y){if(["recovered","canonical"].some(j=>j in w))throw new Error("sign() legacy options not supported");const{hash:y}=n;let{lowS:m,prehash:g,extraEntropy:b}=w;m==null&&(m=!0),f=M("msgHash",f),qt(w),g&&(f=M("prehashed msgHash",y(f)));const E=W(f),Z=x(d),q=[N(Z),N(E)];if(b!=null&&b!==!1){const j=b===!0?r(s.BYTES):b;q.push(M("extraEntropy",j))}const v=T.concatBytes(...q),R=E;function O(j){const A=nt(j);if(!o.isValidNot0(A))return;const H=o.inv(A),Q=e.BASE.multiply(A).toAffine(),F=o.create(Q.x);if(F===tt)return;const k=o.create(H*o.create(R+F*Z));if(k===tt)return;let ft=(Q.x===F?0:2)|Number(Q.y&et),X=k;return m&&p(k)&&(X=a(k),ft^=1),new S(F,X,ft)}return{seed:v,k2sig:O}}const Y={lowS:n.lowS,prehash:!1},_={lowS:n.lowS,prehash:!1};function c(f,d,w=Y){const{seed:y,k2sig:m}=ot(f,d,w);return Dt(n.hash.outputLen,o.BYTES,i)(y,m)}e.BASE.precompute(8);function h(f,d,w,y=_){const m=f;d=M("msgHash",d),w=M("publicKey",w),qt(y);const{lowS:g,prehash:b,format:E}=y;if("strict"in y)throw new Error("options.strict was renamed to lowS");if(E!==void 0&&!["compact","der","js"].includes(E))throw new Error('format must be "compact", "der" or "js"');const Z=typeof m=="string"||T.isBytes(m),q=!Z&&!E&&typeof m=="object"&&m!==null&&typeof m.r=="bigint"&&typeof m.s=="bigint";if(!Z&&!q)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let v,R;try{if(q)if(E===void 0||E==="js")v=new S(m.r,m.s);else throw new Error("invalid format");if(Z){try{E!=="compact"&&(v=S.fromDER(m))}catch(X){if(!(X instanceof C.Err))throw X}!v&&E!=="der"&&(v=S.fromCompact(m))}R=e.fromHex(w)}catch{return!1}if(!v||g&&v.hasHighS())return!1;b&&(d=n.hash(d));const{r:O,s:j}=v,A=W(d),H=o.inv(j),Q=o.create(A*H),F=o.create(O*H),k=e.BASE.multiplyUnsafe(Q).add(R.multiplyUnsafe(F));return k.is0()?!1:o.create(k.x)===O}return Object.freeze({getPublicKey:I,getSharedSecret:V,sign:c,verify:h,utils:z,Point:e,Signature:S})}function me(e){const n={a:e.a,b:e.b,p:e.Fp.ORDER,n:e.n,h:e.h,Gx:e.Gx,Gy:e.Gy},t=e.Fp,r=Et(n.n,e.nBitLength),i={Fp:t,Fn:r,allowedPrivateKeyLengths:e.allowedPrivateKeyLengths,allowInfinityPoint:e.allowInfinityPoint,endo:e.endo,wrapPrivateKey:e.wrapPrivateKey,isTorsionFree:e.isTorsionFree,clearCofactor:e.clearCofactor,fromBytes:e.fromBytes,toBytes:e.toBytes};return{CURVE:n,curveOpts:i}}function ge(e){const{CURVE:n,curveOpts:t}=me(e),r={hash:e.hash,hmac:e.hmac,randomBytes:e.randomBytes,lowS:e.lowS,bits2int:e.bits2int,bits2int_modN:e.bits2int_modN};return{CURVE:n,curveOpts:t,ecdsaOpts:r}}function ye(e,n){return Object.assign({},n,{ProjectivePoint:n.Point,CURVE:e})}function pe(e){const{CURVE:n,curveOpts:t,ecdsaOpts:r}=ge(e),i=he(n,t),s=we(i,r,t);return ye(e,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Se(e,n){const t=r=>pe({...e,hash:r});return{...t(n),create:t}}export{Et as F,ce as _,pt as a,Yt as b,Se as c,at as d,M as e,It as f,_t as g,K as h,ve as i,Be as j,bt as m,ne as n,ae as p,xe as s,ie as w};
