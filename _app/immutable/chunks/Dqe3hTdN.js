const p=[];for(let n=0;n<256;++n)p.push((n+256).toString(16).slice(1));function w(n,i=0){return(p[n[i+0]]+p[n[i+1]]+p[n[i+2]]+p[n[i+3]]+"-"+p[n[i+4]]+p[n[i+5]]+"-"+p[n[i+6]]+p[n[i+7]]+"-"+p[n[i+8]]+p[n[i+9]]+"-"+p[n[i+10]]+p[n[i+11]]+p[n[i+12]]+p[n[i+13]]+p[n[i+14]]+p[n[i+15]]).toLowerCase()}let g;const u=new Uint8Array(16);function h(){if(!g){if(typeof crypto>"u"||!crypto.getRandomValues)throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");g=crypto.getRandomValues.bind(crypto)}return g(u)}const l={};function e(n,i,y){let x;{const c=Date.now(),o=h();m(l,c,o),x=R(o,l.msecs,l.seq,i,y)}return i??w(x)}function m(n,i,y){return n.msecs??(n.msecs=-1/0),n.seq??(n.seq=0),i>n.msecs?(n.seq=y[6]<<23|y[7]<<16|y[8]<<8|y[9],n.msecs=i):(n.seq=n.seq+1|0,n.seq===0&&n.msecs++),n}function R(n,i,y,x,c=0){if(n.length<16)throw new Error("Random bytes length must be >= 16");if(!x)x=new Uint8Array(16),c=0;else if(c<0||c+16>x.length)throw new RangeError(`UUID byte range ${c}:${c+15} is out of buffer bounds`);return i??(i=Date.now()),y??(y=n[6]*127<<24|n[7]<<16|n[8]<<8|n[9]),x[c++]=i/1099511627776&255,x[c++]=i/4294967296&255,x[c++]=i/16777216&255,x[c++]=i/65536&255,x[c++]=i/256&255,x[c++]=i&255,x[c++]=112|y>>>28&15,x[c++]=y>>>20&255,x[c++]=128|y>>>14&63,x[c++]=y>>>6&255,x[c++]=y<<2&255|n[10]&3,x[c++]=n[11],x[c++]=n[12],x[c++]=n[13],x[c++]=n[14],x[c++]=n[15],x}export{e as v};
