import{s as he,u as me}from"./C_jHh3BX.js";import{h as we}from"./usnz5x8K.js";import{as as At}from"./Yy3fPUZA.js";function ye(t,o){for(var e=0;e<o.length;e++){const s=o[e];if(typeof s!="string"&&!Array.isArray(s)){for(const c in s)if(c!=="default"&&!(c in t)){const a=Object.getOwnPropertyDescriptor(s,c);a&&Object.defineProperty(t,c,a.get?a:{enumerable:!0,get:()=>s[c]})}}}return Object.freeze(Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}))}var Jt={},jt={},Dt={},ht={},W={};Object.defineProperty(W,"__esModule",{value:!0});W.isNegativeLE=void 0;W.mod=dt;W.pow=be;W.pow2=Ee;W.invert=Zt;W.tonelliShanks=re;W.FpSqrt=oe;W.validateField=_e;W.FpPow=Vt;W.FpInvertBatch=se;W.FpDiv=Se;W.FpLegendre=Ct;W.FpIsSquare=xe;W.nLength=Kt;W.Field=Yt;W.FpSqrtOdd=qe;W.FpSqrtEven=Ne;W.hashToPrivateScalar=Te;W.getFieldBytesLength=Gt;W.getMinHashLength=ie;W.mapHashToField=Oe;/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ut=At,lt=BigInt(0),tt=BigInt(1),Et=BigInt(2),ge=BigInt(3),Ft=BigInt(4),te=BigInt(5),ee=BigInt(8);function dt(t,o){const e=t%o;return e>=lt?e:o+e}function be(t,o,e){return Vt(Yt(e),t,o)}function Ee(t,o,e){let s=t;for(;o-- >lt;)s*=s,s%=e;return s}function Zt(t,o){if(t===lt)throw new Error("invert: expected non-zero number");if(o<=lt)throw new Error("invert: expected positive modulus, got "+o);let e=dt(t,o),s=o,c=lt,a=tt;for(;e!==lt;){const l=s/e,f=s%e,E=c-a*l;s=e,e=f,c=a,a=E}if(s!==tt)throw new Error("invert: does not exist");return dt(c,o)}function ne(t,o){const e=(t.ORDER+tt)/Ft,s=t.pow(o,e);if(!t.eql(t.sqr(s),o))throw new Error("Cannot find square root");return s}function ve(t,o){const e=(t.ORDER-te)/ee,s=t.mul(o,Et),c=t.pow(s,e),a=t.mul(o,c),m=t.mul(t.mul(a,Et),c),l=t.mul(a,t.sub(m,t.ONE));if(!t.eql(t.sqr(l),o))throw new Error("Cannot find square root");return l}function re(t){if(t<BigInt(3))throw new Error("sqrt is not defined for small field");let o=t-tt,e=0;for(;o%Et===lt;)o/=Et,e++;let s=Et;const c=Yt(t);for(;Ct(c,s)===1;)if(s++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(e===1)return ne;let a=c.pow(s,o);const m=(o+tt)/Et;return function(f,E){if(f.is0(E))return E;if(Ct(f,E)!==1)throw new Error("Cannot find square root");let i=e,B=f.mul(f.ONE,a),M=f.pow(E,o),I=f.pow(E,m);for(;!f.eql(M,f.ONE);){if(f.is0(M))return f.ZERO;let H=1,K=f.sqr(M);for(;!f.eql(K,f.ONE);)if(H++,K=f.sqr(K),H===i)throw new Error("Cannot find square root");const et=tt<<BigInt(i-H-1),it=f.pow(B,et);i=H,B=f.sqr(it),M=f.mul(M,B),I=f.mul(I,it)}return I}}function oe(t){return t%Ft===ge?ne:t%ee===te?ve:re(t)}const pe=(t,o)=>(dt(t,o)&tt)===tt;W.isNegativeLE=pe;const Be=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function _e(t){const o={ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"},e=Be.reduce((s,c)=>(s[c]="function",s),o);return(0,ut._validateObject)(t,e),t}function Vt(t,o,e){if(e<lt)throw new Error("invalid exponent, negatives unsupported");if(e===lt)return t.ONE;if(e===tt)return o;let s=t.ONE,c=o;for(;e>lt;)e&tt&&(s=t.mul(s,c)),c=t.sqr(c),e>>=tt;return s}function se(t,o,e=!1){const s=new Array(o.length).fill(e?t.ZERO:void 0),c=o.reduce((m,l,f)=>t.is0(l)?m:(s[f]=m,t.mul(m,l)),t.ONE),a=t.inv(c);return o.reduceRight((m,l,f)=>t.is0(l)?m:(s[f]=t.mul(m,s[f]),t.mul(m,l)),a),s}function Se(t,o,e){return t.mul(o,typeof e=="bigint"?Zt(e,t.ORDER):t.inv(e))}function Ct(t,o){const e=(t.ORDER-tt)/Et,s=t.pow(o,e),c=t.eql(s,t.ONE),a=t.eql(s,t.ZERO),m=t.eql(s,t.neg(t.ONE));if(!c&&!a&&!m)throw new Error("invalid Legendre symbol result");return c?1:a?0:-1}function xe(t,o){return Ct(t,o)===1}function Kt(t,o){o!==void 0&&(0,ut.anumber)(o);const e=o!==void 0?o:t.toString(2).length,s=Math.ceil(e/8);return{nBitLength:e,nByteLength:s}}function Yt(t,o,e=!1,s={}){if(t<=lt)throw new Error("invalid field: expected ORDER > 0, got "+t);let c,a;if(typeof o=="object"&&o!=null){if(s.sqrt||e)throw new Error("cannot specify opts in two arguments");const i=o;i.BITS&&(c=i.BITS),i.sqrt&&(a=i.sqrt),typeof i.isLE=="boolean"&&(e=i.isLE)}else typeof o=="number"&&(c=o),s.sqrt&&(a=s.sqrt);const{nBitLength:m,nByteLength:l}=Kt(t,c);if(l>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let f;const E=Object.freeze({ORDER:t,isLE:e,BITS:m,BYTES:l,MASK:(0,ut.bitMask)(m),ZERO:lt,ONE:tt,create:i=>dt(i,t),isValid:i=>{if(typeof i!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof i);return lt<=i&&i<t},is0:i=>i===lt,isValidNot0:i=>!E.is0(i)&&E.isValid(i),isOdd:i=>(i&tt)===tt,neg:i=>dt(-i,t),eql:(i,B)=>i===B,sqr:i=>dt(i*i,t),add:(i,B)=>dt(i+B,t),sub:(i,B)=>dt(i-B,t),mul:(i,B)=>dt(i*B,t),pow:(i,B)=>Vt(E,i,B),div:(i,B)=>dt(i*Zt(B,t),t),sqrN:i=>i*i,addN:(i,B)=>i+B,subN:(i,B)=>i-B,mulN:(i,B)=>i*B,inv:i=>Zt(i,t),sqrt:a||(i=>(f||(f=oe(t)),f(E,i))),toBytes:i=>e?(0,ut.numberToBytesLE)(i,l):(0,ut.numberToBytesBE)(i,l),fromBytes:i=>{if(i.length!==l)throw new Error("Field.fromBytes: expected "+l+" bytes, got "+i.length);return e?(0,ut.bytesToNumberLE)(i):(0,ut.bytesToNumberBE)(i)},invertBatch:i=>se(E,i),cmov:(i,B,M)=>M?B:i});return Object.freeze(E)}function qe(t,o){if(!t.isOdd)throw new Error("Field doesn't have isOdd");const e=t.sqrt(o);return t.isOdd(e)?e:t.neg(e)}function Ne(t,o){if(!t.isOdd)throw new Error("Field doesn't have isOdd");const e=t.sqrt(o);return t.isOdd(e)?t.neg(e):e}function Te(t,o,e=!1){t=(0,ut.ensureBytes)("privateHash",t);const s=t.length,c=Kt(o).nByteLength+8;if(c<24||s<c||s>1024)throw new Error("hashToPrivateScalar: expected "+c+"-1024 bytes of input, got "+s);const a=e?(0,ut.bytesToNumberLE)(t):(0,ut.bytesToNumberBE)(t);return dt(a,o-tt)+tt}function Gt(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const o=t.toString(2).length;return Math.ceil(o/8)}function ie(t){const o=Gt(t);return o+Math.ceil(o/2)}function Oe(t,o,e=!1){const s=t.length,c=Gt(o),a=ie(o);if(s<16||s<a||s>1024)throw new Error("expected "+a+"-1024 bytes of input, got "+s);const m=e?(0,ut.bytesToNumberLE)(t):(0,ut.bytesToNumberBE)(t),l=dt(m,o-tt)+tt;return e?(0,ut.numberToBytesLE)(l,c):(0,ut.numberToBytesBE)(l,c)}Object.defineProperty(ht,"__esModule",{value:!0});ht.negateCt=Mt;ht.normalizeZ=Re;ht.wNAF=Ie;ht.mulEndoUnsafe=Ae;ht.pippenger=Le;ht.precomputeMSMUnsafe=Me;ht.validateBasic=Ze;ht._createCurveFields=Ce;/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ot=At,Rt=W,xt=BigInt(0),vt=BigInt(1);function Mt(t,o){const e=o.negate();return t?e:o}function Re(t,o,e){const s=o==="pz"?m=>m.pz:m=>m.ez,c=(0,Rt.FpInvertBatch)(t.Fp,e.map(s));return e.map((m,l)=>m.toAffine(c[l])).map(t.fromAffine)}function $t(t,o){if(!Number.isSafeInteger(t)||t<=0||t>o)throw new Error("invalid window size, expected [1.."+o+"], got W="+t)}function Pt(t,o){$t(t,o);const e=Math.ceil(o/t)+1,s=2**(t-1),c=2**t,a=(0,Ot.bitMask)(t),m=BigInt(t);return{windows:e,windowSize:s,mask:a,maxNumber:c,shiftBy:m}}function Wt(t,o,e){const{windowSize:s,mask:c,maxNumber:a,shiftBy:m}=e;let l=Number(t&c),f=t>>m;l>s&&(l-=a,f+=vt);const E=o*s,i=E+Math.abs(l)-1,B=l===0,M=l<0,I=o%2!==0;return{nextN:f,offset:i,isZero:B,isNeg:M,isNegF:I,offsetF:E}}function ae(t,o){if(!Array.isArray(t))throw new Error("array expected");t.forEach((e,s)=>{if(!(e instanceof o))throw new Error("invalid point at index "+s)})}function ce(t,o){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach((e,s)=>{if(!o.isValid(e))throw new Error("invalid scalar at index "+s)})}const zt=new WeakMap,fe=new WeakMap;function Ut(t){return fe.get(t)||1}function Xt(t){if(t!==xt)throw new Error("invalid wNAF")}function Ie(t,o){return{constTimeNegate:Mt,hasPrecomputes(e){return Ut(e)!==1},unsafeLadder(e,s,c=t.ZERO){let a=e;for(;s>xt;)s&vt&&(c=c.add(a)),a=a.double(),s>>=vt;return c},precomputeWindow(e,s){const{windows:c,windowSize:a}=Pt(s,o),m=[];let l=e,f=l;for(let E=0;E<c;E++){f=l,m.push(f);for(let i=1;i<a;i++)f=f.add(l),m.push(f);l=f.double()}return m},wNAF(e,s,c){let a=t.ZERO,m=t.BASE;const l=Pt(e,o);for(let f=0;f<l.windows;f++){const{nextN:E,offset:i,isZero:B,isNeg:M,isNegF:I,offsetF:H}=Wt(c,f,l);c=E,B?m=m.add(Mt(I,s[H])):a=a.add(Mt(M,s[i]))}return Xt(c),{p:a,f:m}},wNAFUnsafe(e,s,c,a=t.ZERO){const m=Pt(e,o);for(let l=0;l<m.windows&&c!==xt;l++){const{nextN:f,offset:E,isZero:i,isNeg:B}=Wt(c,l,m);if(c=f,!i){const M=s[E];a=a.add(B?M.negate():M)}}return Xt(c),a},getPrecomputes(e,s,c){let a=zt.get(s);return a||(a=this.precomputeWindow(s,e),e!==1&&(typeof c=="function"&&(a=c(a)),zt.set(s,a))),a},wNAFCached(e,s,c){const a=Ut(e);return this.wNAF(a,this.getPrecomputes(a,e,c),s)},wNAFCachedUnsafe(e,s,c,a){const m=Ut(e);return m===1?this.unsafeLadder(e,s,a):this.wNAFUnsafe(m,this.getPrecomputes(m,e,c),s,a)},setWindowSize(e,s){$t(s,o),fe.set(e,s),zt.delete(e)}}}function Ae(t,o,e,s){let c=o,a=t.ZERO,m=t.ZERO;for(;e>xt||s>xt;)e&vt&&(a=a.add(c)),s&vt&&(m=m.add(c)),c=c.double(),e>>=vt,s>>=vt;return{p1:a,p2:m}}function Le(t,o,e,s){ae(e,t),ce(s,o);const c=e.length,a=s.length;if(c!==a)throw new Error("arrays of points and scalars must have equal length");const m=t.ZERO,l=(0,Ot.bitLen)(BigInt(c));let f=1;l>12?f=l-3:l>4?f=l-2:l>0&&(f=2);const E=(0,Ot.bitMask)(f),i=new Array(Number(E)+1).fill(m),B=Math.floor((o.BITS-1)/f)*f;let M=m;for(let I=B;I>=0;I-=f){i.fill(m);for(let K=0;K<a;K++){const et=s[K],it=Number(et>>BigInt(I)&E);i[it]=i[it].add(e[K])}let H=m;for(let K=i.length-1,et=m;K>0;K--)et=et.add(i[K]),H=H.add(et);if(M=M.add(H),I!==0)for(let K=0;K<f;K++)M=M.double()}return M}function Me(t,o,e,s){$t(s,o.BITS),ae(e,t);const c=t.ZERO,a=2**s-1,m=Math.ceil(o.BITS/s),l=(0,Ot.bitMask)(s),f=e.map(E=>{const i=[];for(let B=0,M=E;B<a;B++)i.push(M),M=M.add(E);return i});return E=>{if(ce(E,o),E.length>e.length)throw new Error("array of scalars must be smaller than array of points");let i=c;for(let B=0;B<m;B++){if(i!==c)for(let I=0;I<s;I++)i=i.double();const M=BigInt(m*s-(B+1)*s);for(let I=0;I<E.length;I++){const H=E[I],K=Number(H>>M&l);K&&(i=i.add(f[I][K-1]))}}return i}}function Ze(t){return(0,Rt.validateField)(t.Fp),(0,Ot.validateObject)(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...(0,Rt.nLength)(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}function Qt(t,o){if(o){if(o.ORDER!==t)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return(0,Rt.validateField)(o),o}else return(0,Rt.Field)(t)}function Ce(t,o,e={}){if(!o||typeof o!="object")throw new Error(`expected valid ${t} CURVE object`);for(const l of["p","n","h"]){const f=o[l];if(!(typeof f=="bigint"&&f>xt))throw new Error(`CURVE.${l} must be positive bigint`)}const s=Qt(o.p,e.Fp),c=Qt(o.n,e.Fn),m=["Gx","Gy","a",t==="weierstrass"?"b":"d"];for(const l of m)if(!s.isValid(o[l]))throw new Error(`CURVE.${l} must be valid field element of CURVE.Fp`);return{Fp:s,Fn:c}}(function(t){Object.defineProperty(t,"__esModule",{value:!0}),t.DER=t.DERErr=void 0,t._legacyHelperEquat=M,t._legacyHelperNormPriv=I,t.weierstrassN=H,t.weierstrassPoints=K,t.ecdsa=it,t.weierstrass=Nt,t.SWUFpSqrtRatio=Bt,t.mapToCurveSimpleSWU=Lt;/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const o=we,e=At,s=ht,c=W;function a(n){n.lowS!==void 0&&(0,e.abool)("lowS",n.lowS),n.prehash!==void 0&&(0,e.abool)("prehash",n.prehash)}class m extends Error{constructor(w=""){super(w)}}t.DERErr=m,t.DER={Err:m,_tlv:{encode:(n,w)=>{const{Err:r}=t.DER;if(n<0||n>256)throw new r("tlv.encode: wrong tag");if(w.length&1)throw new r("tlv.encode: unpadded data");const S=w.length/2,L=(0,e.numberToHexUnpadded)(S);if(L.length/2&128)throw new r("tlv.encode: long form length too big");const P=S>127?(0,e.numberToHexUnpadded)(L.length/2|128):"";return(0,e.numberToHexUnpadded)(n)+P+L+w},decode(n,w){const{Err:r}=t.DER;let S=0;if(n<0||n>256)throw new r("tlv.encode: wrong tag");if(w.length<2||w[S++]!==n)throw new r("tlv.decode: wrong tlv");const L=w[S++],P=!!(L&128);let b=0;if(!P)b=L;else{const d=L&127;if(!d)throw new r("tlv.decode(long): indefinite length not supported");if(d>4)throw new r("tlv.decode(long): byte length is too big");const N=w.subarray(S,S+d);if(N.length!==d)throw new r("tlv.decode: length bytes not complete");if(N[0]===0)throw new r("tlv.decode(long): zero leftmost byte");for(const Z of N)b=b<<8|Z;if(S+=d,b<128)throw new r("tlv.decode(long): not minimal encoding")}const y=w.subarray(S,S+b);if(y.length!==b)throw new r("tlv.decode: wrong value length");return{v:y,l:w.subarray(S+b)}}},_int:{encode(n){const{Err:w}=t.DER;if(n<l)throw new w("integer: negative integers are not allowed");let r=(0,e.numberToHexUnpadded)(n);if(Number.parseInt(r[0],16)&8&&(r="00"+r),r.length&1)throw new w("unexpected DER parsing assertion: unpadded hex");return r},decode(n){const{Err:w}=t.DER;if(n[0]&128)throw new w("invalid signature integer: negative");if(n[0]===0&&!(n[1]&128))throw new w("invalid signature integer: unnecessary leading zero");return(0,e.bytesToNumberBE)(n)}},toSig(n){const{Err:w,_int:r,_tlv:S}=t.DER,L=(0,e.ensureBytes)("signature",n),{v:P,l:b}=S.decode(48,L);if(b.length)throw new w("invalid signature: left bytes after parsing");const{v:y,l:d}=S.decode(2,P),{v:N,l:Z}=S.decode(2,d);if(Z.length)throw new w("invalid signature: left bytes after parsing");return{r:r.decode(y),s:r.decode(N)}},hexFromSig(n){const{_tlv:w,_int:r}=t.DER,S=w.encode(2,r.encode(n.r)),L=w.encode(2,r.encode(n.s)),P=S+L;return w.encode(48,P)}};const l=BigInt(0),f=BigInt(1),E=BigInt(2),i=BigInt(3),B=BigInt(4);function M(n,w,r){function S(L){const P=n.sqr(L),b=n.mul(P,L);return n.add(n.add(b,n.mul(L,w)),r)}return S}function I(n,w,r){const{BYTES:S}=n;function L(P){let b;if(typeof P=="bigint")b=P;else{let y=(0,e.ensureBytes)("private key",P);if(w){if(!w.includes(y.length*2))throw new Error("invalid private key");const d=new Uint8Array(S);d.set(y,d.length-y.length),y=d}try{b=n.fromBytes(y)}catch{throw new Error(`invalid private key: expected ui8a of size ${S}, got ${typeof P}`)}}if(r&&(b=n.create(b)),!n.isValidNot0(b))throw new Error("invalid private key: out of range [1..N-1]");return b}return L}function H(n,w={}){const{Fp:r,Fn:S}=(0,s._createCurveFields)("weierstrass",n,w),{h:L,n:P}=n;(0,e._validateObject)(w,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:b}=w;if(b&&(!r.is0(n.a)||typeof b.beta!="bigint"||typeof b.splitScalar!="function"))throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');function y(){if(!r.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function d(V,u,v){const{x:h,y:g}=u.toAffine(),p=r.toBytes(h);if((0,e.abool)("isCompressed",v),v){y();const q=!r.isOdd(g);return(0,e.concatBytes)(et(q),p)}else return(0,e.concatBytes)(Uint8Array.of(4),p,r.toBytes(g))}function N(V){(0,e.abytes)(V);const u=r.BYTES,v=u+1,h=2*u+1,g=V.length,p=V[0],q=V.subarray(1);if(g===v&&(p===2||p===3)){const _=r.fromBytes(q);if(!r.isValid(_))throw new Error("bad point: is not on curve, wrong x");const x=z(_);let R;try{R=r.sqrt(x)}catch($){const A=$ instanceof Error?": "+$.message:"";throw new Error("bad point: is not on curve, sqrt error"+A)}y();const T=r.isOdd(R);return(p&1)===1!==T&&(R=r.neg(R)),{x:_,y:R}}else if(g===h&&p===4){const _=r.fromBytes(q.subarray(u*0,u*1)),x=r.fromBytes(q.subarray(u*1,u*2));if(!D(_,x))throw new Error("bad point: is not on curve");return{x:_,y:x}}else throw new Error(`bad point: got length ${g}, expected compressed=${v} or uncompressed=${h}`)}const Z=w.toBytes||d,X=w.fromBytes||N,z=M(r,n.a,n.b);function D(V,u){const v=r.sqr(u),h=z(V);return r.eql(v,h)}if(!D(n.Gx,n.Gy))throw new Error("bad curve params: generator point");const k=r.mul(r.pow(n.a,i),B),J=r.mul(r.sqr(n.b),BigInt(27));if(r.is0(r.add(k,J)))throw new Error("bad curve params: a or b");function j(V,u,v=!1){if(!r.isValid(u)||v&&r.is0(u))throw new Error(`bad point coordinate ${V}`);return u}function C(V){if(!(V instanceof O))throw new Error("ProjectivePoint expected")}const U=(0,e.memoized)((V,u)=>{const{px:v,py:h,pz:g}=V;if(r.eql(g,r.ONE))return{x:v,y:h};const p=V.is0();u==null&&(u=p?r.ONE:r.inv(g));const q=r.mul(v,u),_=r.mul(h,u),x=r.mul(g,u);if(p)return{x:r.ZERO,y:r.ZERO};if(!r.eql(x,r.ONE))throw new Error("invZ was invalid");return{x:q,y:_}}),Y=(0,e.memoized)(V=>{if(V.is0()){if(w.allowInfinityPoint&&!r.is0(V.py))return;throw new Error("bad point: ZERO")}const{x:u,y:v}=V.toAffine();if(!r.isValid(u)||!r.isValid(v))throw new Error("bad point: x or y not field elements");if(!D(u,v))throw new Error("bad point: equation left != right");if(!V.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function G(V,u,v,h,g){return v=new O(r.mul(v.px,V),v.py,v.pz),u=(0,s.negateCt)(h,u),v=(0,s.negateCt)(g,v),u.add(v)}class O{constructor(u,v,h){this.px=j("x",u),this.py=j("y",v,!0),this.pz=j("z",h),Object.freeze(this)}static fromAffine(u){const{x:v,y:h}=u||{};if(!u||!r.isValid(v)||!r.isValid(h))throw new Error("invalid affine point");if(u instanceof O)throw new Error("projective point not allowed");return r.is0(v)&&r.is0(h)?O.ZERO:new O(v,h,r.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(u){return(0,s.normalizeZ)(O,"pz",u)}static fromBytes(u){return(0,e.abytes)(u),O.fromHex(u)}static fromHex(u){const v=O.fromAffine(X((0,e.ensureBytes)("pointHex",u)));return v.assertValidity(),v}static fromPrivateKey(u){const v=I(S,w.allowedPrivateKeyLengths,w.wrapPrivateKey);return O.BASE.multiply(v(u))}static msm(u,v){return(0,s.pippenger)(O,S,u,v)}precompute(u=8,v=!0){return nt.setWindowSize(this,u),v||this.multiply(i),this}_setWindowSize(u){this.precompute(u)}assertValidity(){Y(this)}hasEvenY(){const{y:u}=this.toAffine();if(!r.isOdd)throw new Error("Field doesn't support isOdd");return!r.isOdd(u)}equals(u){C(u);const{px:v,py:h,pz:g}=this,{px:p,py:q,pz:_}=u,x=r.eql(r.mul(v,_),r.mul(p,g)),R=r.eql(r.mul(h,_),r.mul(q,g));return x&&R}negate(){return new O(this.px,r.neg(this.py),this.pz)}double(){const{a:u,b:v}=n,h=r.mul(v,i),{px:g,py:p,pz:q}=this;let _=r.ZERO,x=r.ZERO,R=r.ZERO,T=r.mul(g,g),F=r.mul(p,p),$=r.mul(q,q),A=r.mul(g,p);return A=r.add(A,A),R=r.mul(g,q),R=r.add(R,R),_=r.mul(u,R),x=r.mul(h,$),x=r.add(_,x),_=r.sub(F,x),x=r.add(F,x),x=r.mul(_,x),_=r.mul(A,_),R=r.mul(h,R),$=r.mul(u,$),A=r.sub(T,$),A=r.mul(u,A),A=r.add(A,R),R=r.add(T,T),T=r.add(R,T),T=r.add(T,$),T=r.mul(T,A),x=r.add(x,T),$=r.mul(p,q),$=r.add($,$),T=r.mul($,A),_=r.sub(_,T),R=r.mul($,F),R=r.add(R,R),R=r.add(R,R),new O(_,x,R)}add(u){C(u);const{px:v,py:h,pz:g}=this,{px:p,py:q,pz:_}=u;let x=r.ZERO,R=r.ZERO,T=r.ZERO;const F=n.a,$=r.mul(n.b,i);let A=r.mul(v,p),rt=r.mul(h,q),ot=r.mul(g,_),at=r.add(v,h),Q=r.add(p,q);at=r.mul(at,Q),Q=r.add(A,rt),at=r.sub(at,Q),Q=r.add(v,g);let ct=r.add(p,_);return Q=r.mul(Q,ct),ct=r.add(A,ot),Q=r.sub(Q,ct),ct=r.add(h,g),x=r.add(q,_),ct=r.mul(ct,x),x=r.add(rt,ot),ct=r.sub(ct,x),T=r.mul(F,Q),x=r.mul($,ot),T=r.add(x,T),x=r.sub(rt,T),T=r.add(rt,T),R=r.mul(x,T),rt=r.add(A,A),rt=r.add(rt,A),ot=r.mul(F,ot),Q=r.mul($,Q),rt=r.add(rt,ot),ot=r.sub(A,ot),ot=r.mul(F,ot),Q=r.add(Q,ot),A=r.mul(rt,Q),R=r.add(R,A),A=r.mul(ct,Q),x=r.mul(at,x),x=r.sub(x,A),A=r.mul(at,rt),T=r.mul(ct,T),T=r.add(T,A),new O(x,R,T)}subtract(u){return this.add(u.negate())}is0(){return this.equals(O.ZERO)}multiply(u){const{endo:v}=w;if(!S.isValidNot0(u))throw new Error("invalid scalar: out of range");let h,g;const p=q=>nt.wNAFCached(this,q,O.normalizeZ);if(v){const{k1neg:q,k1:_,k2neg:x,k2:R}=v.splitScalar(u),{p:T,f:F}=p(_),{p:$,f:A}=p(R);g=F.add(A),h=G(v.beta,T,$,q,x)}else{const{p:q,f:_}=p(u);h=q,g=_}return O.normalizeZ([h,g])[0]}multiplyUnsafe(u){const{endo:v}=w,h=this;if(!S.isValid(u))throw new Error("invalid scalar: out of range");if(u===l||h.is0())return O.ZERO;if(u===f)return h;if(nt.hasPrecomputes(this))return this.multiply(u);if(v){const{k1neg:g,k1:p,k2neg:q,k2:_}=v.splitScalar(u),{p1:x,p2:R}=(0,s.mulEndoUnsafe)(O,h,p,_);return G(v.beta,x,R,g,q)}else return nt.wNAFCachedUnsafe(h,u)}multiplyAndAddUnsafe(u,v,h){const g=this.multiplyUnsafe(v).add(u.multiplyUnsafe(h));return g.is0()?void 0:g}toAffine(u){return U(this,u)}isTorsionFree(){const{isTorsionFree:u}=w;return L===f?!0:u?u(O,this):nt.wNAFCachedUnsafe(this,P).is0()}clearCofactor(){const{clearCofactor:u}=w;return L===f?this:u?u(O,this):this.multiplyUnsafe(L)}toBytes(u=!0){return(0,e.abool)("isCompressed",u),this.assertValidity(),Z(O,this,u)}toRawBytes(u=!0){return this.toBytes(u)}toHex(u=!0){return(0,e.bytesToHex)(this.toBytes(u))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}}O.BASE=new O(n.Gx,n.Gy,r.ONE),O.ZERO=new O(r.ZERO,r.ONE,r.ZERO),O.Fp=r,O.Fn=S;const ft=S.BITS,nt=(0,s.wNAF)(O,w.endo?Math.ceil(ft/2):ft);return O}function K(n){const{CURVE:w,curveOpts:r}=mt(n),S=H(w,r);return gt(n,S)}function et(n){return Uint8Array.of(n?2:3)}function it(n,w,r={}){(0,e._validateObject)(w,{hash:"function"},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const S=w.randomBytes||e.randomBytes,L=w.hmac||((h,...g)=>(0,o.hmac)(w.hash,h,(0,e.concatBytes)(...g))),{Fp:P,Fn:b}=n,{ORDER:y,BITS:d}=b;function N(h){const g=y>>f;return h>g}function Z(h){return N(h)?b.neg(h):h}function X(h,g){if(!b.isValidNot0(g))throw new Error(`invalid signature ${h}: out of range 1..CURVE.n`)}class z{constructor(g,p,q){X("r",g),X("s",p),this.r=g,this.s=p,q!=null&&(this.recovery=q),Object.freeze(this)}static fromCompact(g){const p=b.BYTES,q=(0,e.ensureBytes)("compactSignature",g,p*2);return new z(b.fromBytes(q.subarray(0,p)),b.fromBytes(q.subarray(p,p*2)))}static fromDER(g){const{r:p,s:q}=t.DER.toSig((0,e.ensureBytes)("DER",g));return new z(p,q)}assertValidity(){}addRecoveryBit(g){return new z(this.r,this.s,g)}recoverPublicKey(g){const p=P.ORDER,{r:q,s:_,recovery:x}=this;if(x==null||![0,1,2,3].includes(x))throw new Error("recovery id invalid");if(y*E<p&&x>1)throw new Error("recovery id is ambiguous for h>1 curve");const T=x===2||x===3?q+y:q;if(!P.isValid(T))throw new Error("recovery id 2 or 3 invalid");const F=P.toBytes(T),$=n.fromHex((0,e.concatBytes)(et((x&1)===0),F)),A=b.inv(T),rt=Y((0,e.ensureBytes)("msgHash",g)),ot=b.create(-rt*A),at=b.create(_*A),Q=n.BASE.multiplyUnsafe(ot).add($.multiplyUnsafe(at));if(Q.is0())throw new Error("point at infinify");return Q.assertValidity(),Q}hasHighS(){return N(this.s)}normalizeS(){return this.hasHighS()?new z(this.r,b.neg(this.s),this.recovery):this}toBytes(g){if(g==="compact")return(0,e.concatBytes)(b.toBytes(this.r),b.toBytes(this.s));if(g==="der")return(0,e.hexToBytes)(t.DER.hexFromSig(this));throw new Error("invalid format")}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return(0,e.bytesToHex)(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return(0,e.bytesToHex)(this.toBytes("compact"))}}const D=I(b,r.allowedPrivateKeyLengths,r.wrapPrivateKey),k={isValidPrivateKey(h){try{return D(h),!0}catch{return!1}},normPrivateKeyToScalar:D,randomPrivateKey:()=>{const h=y;return(0,c.mapHashToField)(S((0,c.getMinHashLength)(h)),h)},precompute(h=8,g=n.BASE){return g.precompute(h,!1)}};function J(h,g=!0){return n.fromPrivateKey(h).toBytes(g)}function j(h){if(typeof h=="bigint")return!1;if(h instanceof n)return!0;const p=(0,e.ensureBytes)("key",h).length,q=P.BYTES,_=q+1,x=2*q+1;if(!(r.allowedPrivateKeyLengths||b.BYTES===_))return p===_||p===x}function C(h,g,p=!0){if(j(h)===!0)throw new Error("first arg must be private key");if(j(g)===!1)throw new Error("second arg must be public key");return n.fromHex(g).multiply(D(h)).toBytes(p)}const U=w.bits2int||function(h){if(h.length>8192)throw new Error("input is too large");const g=(0,e.bytesToNumberBE)(h),p=h.length*8-d;return p>0?g>>BigInt(p):g},Y=w.bits2int_modN||function(h){return b.create(U(h))},G=(0,e.bitMask)(d);function O(h){return(0,e.aInRange)("num < 2^"+d,h,l,G),b.toBytes(h)}function ft(h,g,p=nt){if(["recovered","canonical"].some(at=>at in p))throw new Error("sign() legacy options not supported");const{hash:q}=w;let{lowS:_,prehash:x,extraEntropy:R}=p;_==null&&(_=!0),h=(0,e.ensureBytes)("msgHash",h),a(p),x&&(h=(0,e.ensureBytes)("prehashed msgHash",q(h)));const T=Y(h),F=D(g),$=[O(F),O(T)];if(R!=null&&R!==!1){const at=R===!0?S(P.BYTES):R;$.push((0,e.ensureBytes)("extraEntropy",at))}const A=(0,e.concatBytes)(...$),rt=T;function ot(at){const Q=U(at);if(!b.isValidNot0(Q))return;const ct=b.inv(Q),Tt=n.BASE.multiply(Q).toAffine(),_t=b.create(Tt.x);if(_t===l)return;const bt=b.create(ct*b.create(rt+_t*F));if(bt===l)return;let kt=(Tt.x===_t?0:2)|Number(Tt.y&f),St=bt;return _&&N(bt)&&(St=Z(bt),kt^=1),new z(_t,St,kt)}return{seed:A,k2sig:ot}}const nt={lowS:w.lowS,prehash:!1},V={lowS:w.lowS,prehash:!1};function u(h,g,p=nt){const{seed:q,k2sig:_}=ft(h,g,p);return(0,e.createHmacDrbg)(w.hash.outputLen,b.BYTES,L)(q,_)}n.BASE.precompute(8);function v(h,g,p,q=V){const _=h;g=(0,e.ensureBytes)("msgHash",g),p=(0,e.ensureBytes)("publicKey",p),a(q);const{lowS:x,prehash:R,format:T}=q;if("strict"in q)throw new Error("options.strict was renamed to lowS");if(T!==void 0&&!["compact","der","js"].includes(T))throw new Error('format must be "compact", "der" or "js"');const F=typeof _=="string"||(0,e.isBytes)(_),$=!F&&!T&&typeof _=="object"&&_!==null&&typeof _.r=="bigint"&&typeof _.s=="bigint";if(!F&&!$)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let A,rt;try{if($)if(T===void 0||T==="js")A=new z(_.r,_.s);else throw new Error("invalid format");if(F){try{T!=="compact"&&(A=z.fromDER(_))}catch(St){if(!(St instanceof t.DER.Err))throw St}!A&&T!=="der"&&(A=z.fromCompact(_))}rt=n.fromHex(p)}catch{return!1}if(!A||x&&A.hasHighS())return!1;R&&(g=w.hash(g));const{r:ot,s:at}=A,Q=Y(g),ct=b.inv(at),Tt=b.create(Q*ct),_t=b.create(ot*ct),bt=n.BASE.multiplyUnsafe(Tt).add(rt.multiplyUnsafe(_t));return bt.is0()?!1:b.create(bt.x)===ot}return Object.freeze({getPublicKey:J,getSharedSecret:C,sign:u,verify:v,utils:k,Point:n,Signature:z})}function mt(n){const w={a:n.a,b:n.b,p:n.Fp.ORDER,n:n.n,h:n.h,Gx:n.Gx,Gy:n.Gy},r=n.Fp,S=(0,c.Field)(w.n,n.nBitLength),L={Fp:r,Fn:S,allowedPrivateKeyLengths:n.allowedPrivateKeyLengths,allowInfinityPoint:n.allowInfinityPoint,endo:n.endo,wrapPrivateKey:n.wrapPrivateKey,isTorsionFree:n.isTorsionFree,clearCofactor:n.clearCofactor,fromBytes:n.fromBytes,toBytes:n.toBytes};return{CURVE:w,curveOpts:L}}function yt(n){const{CURVE:w,curveOpts:r}=mt(n),S={hash:n.hash,hmac:n.hmac,randomBytes:n.randomBytes,lowS:n.lowS,bits2int:n.bits2int,bits2int_modN:n.bits2int_modN};return{CURVE:w,curveOpts:r,ecdsaOpts:S}}function gt(n,w){const{Fp:r,Fn:S}=w;function L(y){return(0,e.inRange)(y,f,S.ORDER)}const P=M(r,n.a,n.b),b=I(S,n.allowedPrivateKeyLengths,n.wrapPrivateKey);return Object.assign({},{CURVE:n,Point:w,ProjectivePoint:w,normPrivateKeyToScalar:b,weierstrassEquation:P,isWithinCurveOrder:L})}function qt(n,w){return Object.assign({},w,{ProjectivePoint:w.Point,CURVE:n})}function Nt(n){const{CURVE:w,curveOpts:r,ecdsaOpts:S}=yt(n),L=H(w,r),P=it(L,S,r);return qt(n,P)}function Bt(n,w){const r=n.ORDER;let S=l;for(let k=r-f;k%E===l;k/=E)S+=f;const L=S,P=E<<L-f-f,b=P*E,y=(r-f)/b,d=(y-f)/E,N=b-f,Z=P,X=n.pow(w,y),z=n.pow(w,(y+f)/E);let D=(k,J)=>{let j=X,C=n.pow(J,N),U=n.sqr(C);U=n.mul(U,J);let Y=n.mul(k,U);Y=n.pow(Y,d),Y=n.mul(Y,C),C=n.mul(Y,J),U=n.mul(Y,k);let G=n.mul(U,C);Y=n.pow(G,Z);let O=n.eql(Y,n.ONE);C=n.mul(U,z),Y=n.mul(G,j),U=n.cmov(C,U,O),G=n.cmov(Y,G,O);for(let ft=L;ft>f;ft--){let nt=ft-E;nt=E<<nt-f;let V=n.pow(G,nt);const u=n.eql(V,n.ONE);C=n.mul(U,j),j=n.mul(j,j),V=n.mul(G,j),U=n.cmov(C,U,u),G=n.cmov(V,G,u)}return{isValid:O,value:U}};if(n.ORDER%B===i){const k=(n.ORDER-i)/B,J=n.sqrt(n.neg(w));D=(j,C)=>{let U=n.sqr(C);const Y=n.mul(j,C);U=n.mul(U,Y);let G=n.pow(U,k);G=n.mul(G,Y);const O=n.mul(G,J),ft=n.mul(n.sqr(G),C),nt=n.eql(ft,j);let V=n.cmov(O,G,nt);return{isValid:nt,value:V}}}return D}function Lt(n,w){(0,c.validateField)(n);const{A:r,B:S,Z:L}=w;if(!n.isValid(r)||!n.isValid(S)||!n.isValid(L))throw new Error("mapToCurveSimpleSWU: invalid opts");const P=Bt(n,L);if(!n.isOdd)throw new Error("Field does not have .isOdd()");return b=>{let y,d,N,Z,X,z,D,k;y=n.sqr(b),y=n.mul(y,L),d=n.sqr(y),d=n.add(d,y),N=n.add(d,n.ONE),N=n.mul(N,S),Z=n.cmov(L,n.neg(d),!n.eql(d,n.ZERO)),Z=n.mul(Z,r),d=n.sqr(N),z=n.sqr(Z),X=n.mul(z,r),d=n.add(d,X),d=n.mul(d,N),z=n.mul(z,Z),X=n.mul(z,S),d=n.add(d,X),D=n.mul(y,N);const{isValid:J,value:j}=P(d,z);k=n.mul(y,b),k=n.mul(k,j),D=n.cmov(D,N,J),k=n.cmov(k,j,J);const C=n.isOdd(b)===n.isOdd(k);k=n.cmov(n.neg(k),k,C);const U=(0,c.FpInvertBatch)(n,[Z],!0)[0];return D=n.mul(D,U),{x:D,y:k}}}})(Dt);Object.defineProperty(jt,"__esModule",{value:!0});jt.getHash=ke;jt.createCurve=Pe;/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const je=Dt;function ke(t){return{hash:t}}function Pe(t,o){const e=s=>(0,je.weierstrass)({...t,hash:s});return{...e(o),create:e}}var pt={};Object.defineProperty(pt,"__esModule",{value:!0});pt.expand_message_xmd=le;pt.expand_message_xof=de;pt.hash_to_field=Ht;pt.isogenyMap=He;pt.createHasher=De;const st=At,ue=W,ze=st.bytesToNumberBE;function wt(t,o){if(It(t),It(o),t<0||t>=1<<8*o)throw new Error("invalid I2OSP input: "+t);const e=Array.from({length:o}).fill(0);for(let s=o-1;s>=0;s--)e[s]=t&255,t>>>=8;return new Uint8Array(e)}function Ue(t,o){const e=new Uint8Array(t.length);for(let s=0;s<t.length;s++)e[s]=t[s]^o[s];return e}function It(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function le(t,o,e,s){(0,st.abytes)(t),(0,st.abytes)(o),It(e),o.length>255&&(o=s((0,st.concatBytes)((0,st.utf8ToBytes)("H2C-OVERSIZE-DST-"),o)));const{outputLen:c,blockLen:a}=s,m=Math.ceil(e/c);if(e>65535||m>255)throw new Error("expand_message_xmd: invalid lenInBytes");const l=(0,st.concatBytes)(o,wt(o.length,1)),f=wt(0,a),E=wt(e,2),i=new Array(m),B=s((0,st.concatBytes)(f,t,E,wt(0,1),l));i[0]=s((0,st.concatBytes)(B,wt(1,1),l));for(let I=1;I<=m;I++){const H=[Ue(B,i[I-1]),wt(I+1,1),l];i[I]=s((0,st.concatBytes)(...H))}return(0,st.concatBytes)(...i).slice(0,e)}function de(t,o,e,s,c){if((0,st.abytes)(t),(0,st.abytes)(o),It(e),o.length>255){const a=Math.ceil(2*s/8);o=c.create({dkLen:a}).update((0,st.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(o).digest()}if(e>65535||o.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return c.create({dkLen:e}).update(t).update(wt(e,2)).update(o).update(wt(o.length,1)).digest()}function Ht(t,o,e){(0,st._validateObject)(e,{p:"bigint",m:"number",k:"number",hash:"function"});const{p:s,k:c,m:a,hash:m,expand:l,DST:f}=e;if(!(0,st.isBytes)(f)&&typeof f!="string")throw new Error("DST must be string or uint8array");if(!(0,st.isHash)(e.hash))throw new Error("expected valid hash");(0,st.abytes)(t),It(o);const E=typeof f=="string"?(0,st.utf8ToBytes)(f):f,i=s.toString(2).length,B=Math.ceil((i+c)/8),M=o*a*B;let I;if(l==="xmd")I=le(t,E,M,m);else if(l==="xof")I=de(t,E,M,c,m);else if(l==="_internal_pass")I=t;else throw new Error('expand must be "xmd" or "xof"');const H=new Array(o);for(let K=0;K<o;K++){const et=new Array(a);for(let it=0;it<a;it++){const mt=B*(it+K*a),yt=I.subarray(mt,mt+B);et[it]=(0,ue.mod)(ze(yt),s)}H[K]=et}return H}function He(t,o){const e=o.map(s=>Array.from(s).reverse());return(s,c)=>{const[a,m,l,f]=e.map(B=>B.reduce((M,I)=>t.add(t.mul(M,s),I))),[E,i]=(0,ue.FpInvertBatch)(t,[m,f],!0);return s=t.mul(a,E),c=t.mul(c,t.mul(l,i)),{x:s,y:c}}}function De(t,o,e){if(typeof o!="function")throw new Error("mapToCurve() must be defined");function s(a){return t.fromAffine(o(a))}function c(a){const m=a.clearCofactor();return m.equals(t.ZERO)?t.ZERO:(m.assertValidity(),m)}return{defaults:e,hashToCurve(a,m){const l=e.DST?e.DST:{},f=Object.assign({},e,l,m),E=Ht(a,2,f),i=s(E[0]),B=s(E[1]);return c(i.add(B))},encodeToCurve(a,m){const l=e.encodeDST?e.encodeDST:{},f=Object.assign({},e,l,m),E=Ht(a,1,f);return c(s(E[0]))},mapToCurve(a){if(!Array.isArray(a))throw new Error("expected array of bigints");for(const m of a)if(typeof m!="bigint")throw new Error("expected array of bigints");return c(s(a))}}}(function(t){Object.defineProperty(t,"__esModule",{value:!0}),t.encodeToCurve=t.hashToCurve=t.secp256k1_hasher=t.schnorr=t.secp256k1=void 0;/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const o=he,e=me,s=jt,c=pt,a=W,m=Dt,l=At,f={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},E=BigInt(0),i=BigInt(1),B=BigInt(2),M=(y,d)=>(y+d/B)/d;function I(y){const d=f.p,N=BigInt(3),Z=BigInt(6),X=BigInt(11),z=BigInt(22),D=BigInt(23),k=BigInt(44),J=BigInt(88),j=y*y*y%d,C=j*j*y%d,U=(0,a.pow2)(C,N,d)*C%d,Y=(0,a.pow2)(U,N,d)*C%d,G=(0,a.pow2)(Y,B,d)*j%d,O=(0,a.pow2)(G,X,d)*G%d,ft=(0,a.pow2)(O,z,d)*O%d,nt=(0,a.pow2)(ft,k,d)*ft%d,V=(0,a.pow2)(nt,J,d)*nt%d,u=(0,a.pow2)(V,k,d)*ft%d,v=(0,a.pow2)(u,N,d)*C%d,h=(0,a.pow2)(v,D,d)*O%d,g=(0,a.pow2)(h,Z,d)*j%d,p=(0,a.pow2)(g,B,d);if(!H.eql(H.sqr(p),y))throw new Error("Cannot find square root");return p}const H=(0,a.Field)(f.p,void 0,void 0,{sqrt:I});t.secp256k1=(0,s.createCurve)({...f,Fp:H,lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:y=>{const d=f.n,N=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),Z=-i*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),X=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),z=N,D=BigInt("0x100000000000000000000000000000000"),k=M(z*y,d),J=M(-Z*y,d);let j=(0,a.mod)(y-k*N-J*X,d),C=(0,a.mod)(-k*Z-J*z,d);const U=j>D,Y=C>D;if(U&&(j=d-j),Y&&(C=d-C),j>D||C>D)throw new Error("splitScalar: Endomorphism failed, k="+y);return{k1neg:U,k1:j,k2neg:Y,k2:C}}}},o.sha256);const K={};function et(y,...d){let N=K[y];if(N===void 0){const Z=(0,o.sha256)(Uint8Array.from(y,X=>X.charCodeAt(0)));N=(0,l.concatBytes)(Z,Z),K[y]=N}return(0,o.sha256)((0,l.concatBytes)(N,...d))}const it=y=>y.toBytes(!0).slice(1),mt=y=>(0,l.numberToBytesBE)(y,32),yt=y=>(0,a.mod)(y,f.p),gt=y=>(0,a.mod)(y,f.n),qt=t.secp256k1.Point,Nt=y=>y%B===E;function Bt(y){let d=t.secp256k1.utils.normPrivateKeyToScalar(y),N=qt.fromPrivateKey(d);return{scalar:Nt(N.y)?d:gt(-d),bytes:it(N)}}function Lt(y){(0,l.aInRange)("x",y,i,f.p);const d=yt(y*y),N=yt(d*y+BigInt(7));let Z=I(N);Nt(Z)||(Z=yt(-Z));const X=qt.fromAffine({x:y,y:Z});return X.assertValidity(),X}const n=l.bytesToNumberBE;function w(...y){return gt(n(et("BIP0340/challenge",...y)))}function r(y){return Bt(y).bytes}function S(y,d,N=(0,e.randomBytes)(32)){const Z=(0,l.ensureBytes)("message",y),{bytes:X,scalar:z}=Bt(d),D=(0,l.ensureBytes)("auxRand",N,32),k=mt(z^n(et("BIP0340/aux",D))),J=et("BIP0340/nonce",k,X,Z),j=gt(n(J));if(j===E)throw new Error("sign failed: k is zero");const{bytes:C,scalar:U}=Bt(j),Y=w(C,X,Z),G=new Uint8Array(64);if(G.set(C,0),G.set(mt(gt(U+Y*z)),32),!L(G,Z,X))throw new Error("sign: Invalid signature produced");return G}function L(y,d,N){const Z=(0,l.ensureBytes)("signature",y,64),X=(0,l.ensureBytes)("message",d),z=(0,l.ensureBytes)("publicKey",N,32);try{const D=Lt(n(z)),k=n(Z.subarray(0,32));if(!(0,l.inRange)(k,i,f.p))return!1;const J=n(Z.subarray(32,64));if(!(0,l.inRange)(J,i,f.n))return!1;const j=w(mt(k),it(D),X),C=qt.BASE.multiplyUnsafe(J).add(D.multiplyUnsafe(gt(-j))),{x:U,y:Y}=C.toAffine();return!(C.is0()||!Nt(Y)||U!==k)}catch{return!1}}t.schnorr={getPublicKey:r,sign:S,verify:L,utils:{randomPrivateKey:t.secp256k1.utils.randomPrivateKey,lift_x:Lt,pointToBytes:it,numberToBytesBE:l.numberToBytesBE,bytesToNumberBE:l.bytesToNumberBE,taggedHash:et,mod:a.mod}};const P=(0,c.isogenyMap)(H,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(y=>y.map(d=>BigInt(d)))),b=(0,m.mapToCurveSimpleSWU)(H,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:H.create(BigInt("-11"))});t.secp256k1_hasher=(0,c.createHasher)(t.secp256k1.Point,y=>{const{x:d,y:N}=b(H.create(y[0]));return P(d,N)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:H.ORDER,m:1,k:128,expand:"xmd",hash:o.sha256}),t.hashToCurve=t.secp256k1_hasher.hashToCurve,t.encodeToCurve=t.secp256k1_hasher.encodeToCurve})(Jt);const Ge=ye({__proto__:null},[Jt]);export{Jt as a,Ge as s};
