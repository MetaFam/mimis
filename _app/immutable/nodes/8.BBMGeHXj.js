var K=Object.defineProperty;var _=t=>{throw TypeError(t)};var L=(t,r,e)=>r in t?K(t,r,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[r]=e;var m=(t,r,e)=>L(t,typeof r!="symbol"?r+"":r,e),A=(t,r,e)=>r.has(t)||_("Cannot "+e);var w=(t,r,e)=>(A(t,r,"read from private field"),e?e.call(t):r.get(t)),O=(t,r,e)=>r.has(t)?_("Cannot add the same private member more than once"):r instanceof WeakSet?r.add(t):r.set(t,e),T=(t,r,e,a)=>(A(t,r,"write to private field"),a?a.call(t,e):r.set(t,e),e);import"../chunks/CWj6FrbW.js";import"../chunks/BviadKC5.js";import{p as $,f as E,X as M,d as l,b,c as D,$ as H,s as f,ai as W,l as I,r as h,a as U,t as q,G as F}from"../chunks/DyJcJ3Y7.js";import{d as z,s as B}from"../chunks/THFJsEQF.js";import{i as G}from"../chunks/CmfBeWXP.js";import{h as J}from"../chunks/BgZ3Q8g3.js";import{s as Y}from"../chunks/DU3eORWj.js";import{i as X}from"../chunks/Bjjg9L97.js";import{C as y}from"../chunks/C6cB8dNp.js";import{a as Q,e as V,g as N,T as Z}from"../chunks/DTKle_Lf.js";import{t as tt}from"../chunks/dXnwemZP.js";import{m as et,W as rt,P as k,c as st,t as at}from"../chunks/DK3AaC1z.js";const v={async nodes({batchSize:t,log:r,rootId:e}){const s=N().session();try{const o=await s.run(`
        OPTIONAL MATCH (start) WHERE elementId(start) = $rootId
        MATCH (node)
        WHERE
          $rootId IS NULL OR
          (start IS NOT NULL AND ((start)-[*]->(node)))
        RETURN
          DISTINCT elementId(node) as id,
          labels(node) as labels,
          properties(node) as properties
        ORDER BY elementId(node)
      `,{rootId:e});return r==null||r(`Found ${o.records.length} node${o.records.length===1?"":"s"}`),Object.fromEntries(await Promise.all(Array.from(o.records).map(async i=>[i.get("id"),await g({type:"node",labels:i.get("labels"),properties:Object.fromEntries(Object.entries(i.get("properties")).map(([n,p])=>(n==="cid"&&typeof p=="string"&&(p=y.parse(p)),[n,p])))})])))}finally{await s.close()}},async relationships(t,{batchSize:r,log:e,rootId:a}){const c=N().session();try{const i=await c.run(`
        OPTIONAL MATCH (start) WHERE elementId(start) = $rootId
        MATCH (source)-[r]->(target)
        WHERE
          $rootId IS NULL OR
          (start IS NOT NULL AND ((start)-[*]->(source)))
        RETURN
          elementId(source) as sourceId,
          elementId(target) as targetId,
          type(r) as type,
          properties(r) as properties
        ORDER BY elementId(r)
      `,{rootId:a});return Array.from(i.records).map(n=>{const p=t[n.get("sourceId")],d=t[n.get("targetId")];if(!p)throw new Error(`No node for ${n.get("sourceId")}`);if(!d)throw new Error(`No node for ${n.get("targetId")}`);if(!p.equals(d))return{type:"relation",relationship:n.get("type"),source:p,target:d,properties:n.get("properties")}}).filter(Boolean)}finally{await c.close()}},async index(t,r,{log:e,rootId:a}){const s=new Set(r.map(i=>{var n;return((n=i.target)==null?void 0:n.toString())??(()=>{throw new Error(`Relation Mapping Error: ${JSON.stringify(i,null,2)}`)})()})),c=new Set(Object.values(t).map(i=>i.toString())),o=c.difference(s);return g({roots:Array.from(o.values()).map(i=>y.parse(i)),nodes:Array.from(c.values()).map(i=>y.parse(i)),relations:r})}};async function g(t){return await Q().block.put(V(t),{format:"dag-json"})}async function it({log:t=null,batchSize:r=1e3,rootId:e=null}){const a={log:t,batchSize:r,rootId:e};try{t==null||t("Exporting nodes…");const s=await v.nodes(a);t==null||t({nodes:s}),t==null||t("Adding relationships…");const c=await v.relationships(s,a);t==null||t("Writing to IPFS…");const o=await v.index(s,c,a);return t==null||t(`Graph serialized to IPFS.
  Index CID: "${o}"`),o}catch(s){throw console.error({"Graph Serializing Error":s}),s}}var u;class ot{constructor(){m(this,"networks",[et]);m(this,"adapter",new rt({projectId:k,networks:this.networks}));m(this,"metadata",{name:"Mïmis",description:"Collaborative filesystem",url:"https://mimis.dhappy.org",icons:["https://avatars.githubusercontent.com/u/179229932"]});O(this,u,null)}get appKit(){return w(this,u)||T(this,u,st({adapters:[this.adapter],networks:this.networks,metadata:this.metadata,projectId:k,features:{analytics:!0,swaps:!1,onramp:!1,connectMethodsOrder:["wallet","social","email"]}})),w(this,u)}async getProvider(r="eip155",{log:e}={}){await this.appKit.ready();const a=new Promise((s,c)=>{const o=this.appKit.getProvider(r);if(o)return e==null||e({"AppKit Provider":o}),s(o);this.appKit.subscribeProviders(i=>s(i[r])),this.appKit.subscribeEvents(i=>{i.data.event==="MODAL_CLOSE"&&(i.data.properties.connected||c(new Error("Modal closed without connection.")))}),this.appKit.open()});return e==null||e({"Promised Provider":a}),a}async signMessage(r,{log:e}={}){const a=await this.getProvider(void 0,{log:e});let{address:s}=this.appKit.getAccount();if(s||(s=await new Promise(c=>{this.appKit.subscribeAccount(({address:o})=>{o&&c(o)}),this.appKit.open()})),e==null||e({message:r,provider:a,address:s}),!s)throw new Error("Could not find address from provider.");return await a.request({method:"personal_sign",params:[r,s]})}}u=new WeakMap;const C=new ot,nt=async(t,r)=>{try{const e=await it({status:console.debug});console.debug({acct:await at(C.adapter.wagmiConfig)});const a=await C.signMessage(e.toString(),{log:console.debug});console.debug({signature:a}),W(r,await g({index:e,signature:a}))}catch(e){console.debug({"Signing Error":e}),Z({text:e.message,duration:16e3,close:!0,gravity:"bottom",position:"center",stopOnFocus:!0,style:{background:"linear-gradient(to right, #b09b00, #96003d)"}}).showToast()}};var ct=E('<link rel="icon" href="radioactive%20barrel.svg"/>'),pt=E('<hr/> <a class="button svelte-182wcux" target="_blank"><span class="svelte-182wcux">Browse <code> </code></span></a>',1),dt=E('<main class="svelte-182wcux"><button class="svelte-182wcux">Publish</button> <appkit-button></appkit-button> <!></main>',2);function St(t,r){$(r,!1);let e=M(null);X();var a=dt();J(n=>{var p=ct();H.title="Mïmis: Serialize",b(n,p)});var s=l(a);s.__click=[nt,e];var c=f(s,2),o=f(c,2);{var i=n=>{var p=pt(),d=f(U(p),2),P=l(d),S=f(l(P)),R=l(S);h(S),h(P),h(d),q((x,j)=>{Y(d,"href",x),B(R,`ipfs://${j??""}`)},[()=>tt({cid:I(e).toString()}),()=>I(e).toString()],F),b(n,p)};G(o,n=>{I(e)&&n(i)})}h(a),b(t,a),D()}z(["click"]);export{St as component};
