var Q=e=>{throw TypeError(e)};var ne=(e,n,t)=>n.has(e)||Q("Cannot "+t);var C=(e,n,t)=>(ne(e,n,"read from private field"),t?t.call(e):n.get(e)),L=(e,n,t)=>n.has(e)?Q("Cannot add the same private member more than once"):n instanceof WeakSet?n.add(e):n.set(e,t);import"../chunks/CWj6FrbW.js";import{p as re,f as F,s as N,a as ae,d as M,t as z,b as P,c as ie,aj as S,l as I,ai as x,$ as oe,r as A,y as se,aW as ce,aU as ue}from"../chunks/DyJcJ3Y7.js";import{d as de,e as Y,s as le}from"../chunks/THFJsEQF.js";import{i as K}from"../chunks/CmfBeWXP.js";import{h as fe}from"../chunks/BgZ3Q8g3.js";import{r as me}from"../chunks/DU3eORWj.js";import{c as ye}from"../chunks/BmSEacwB.js";import{b as he}from"../chunks/BNDDHLvu.js";import{v as $,d as ge,a as pe,s as we,w as ve}from"../chunks/DDwuHMOd.js";import{d as J,C as X}from"../chunks/C6cB8dNp.js";import{g as Ee,T as Ie}from"../chunks/DTKle_Lf.js";import{v as G}from"../chunks/CynzQA2G.js";const q={SHA2_256:18,LENGTH:32,DAG_PB:112},Re=40;function B(e,n){if(!e.length)throw new Error("Unexpected end of data");const t=$.decode(e);return n.seek($.decode.bytes),t}function Te(e){const n=new DataView(e.buffer,e.byteOffset,e.byteLength);let t=0;return{version:2,characteristics:[n.getBigUint64(t,!0),n.getBigUint64(t+=8,!0)],dataOffset:Number(n.getBigUint64(t+=8,!0)),dataSize:Number(n.getBigUint64(t+=8,!0)),indexOffset:Number(n.getBigUint64(t+=8,!0))}}function Ce(e){$.decode(e);const n=$.decode.bytes,t=$.decode(e.subarray($.decode.bytes)),r=$.decode.bytes;return n+r+t}const T={Null:e=>e===null?e:void 0,Int:e=>Number.isInteger(e)?e:void 0,Float:e=>typeof e=="number"&&Number.isFinite(e)?e:void 0,String:e=>typeof e=="string"?e:void 0,Bool:e=>typeof e=="boolean"?e:void 0,Bytes:e=>e instanceof Uint8Array?e:void 0,Link:e=>e!==null&&typeof e=="object"&&e.asCID===e?e:void 0,List:e=>Array.isArray(e)?e:void 0,Map:e=>e!==null&&typeof e=="object"&&e.asCID!==e&&!Array.isArray(e)&&!(e instanceof Uint8Array)?e:void 0},V={"CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)":T.Link,"CarV1HeaderOrV2Pragma > roots (anon)":e=>{if(T.List(e)!==void 0){for(let n=0;n<e.length;n++){let t=e[n];if(t=V["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](t),t===void 0)return;if(t!==e[n]){const r=e.slice(0,n);for(let a=n;a<e.length;a++){let i=e[a];if(i=V["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](i),i===void 0)return;r.push(i)}return r}}return e}},Int:T.Int,CarV1HeaderOrV2Pragma:e=>{if(T.Map(e)===void 0)return;const n=Object.entries(e);let t=e,r=1;for(let a=0;a<n.length;a++){const[i,c]=n[a];switch(i){case"roots":{const d=V["CarV1HeaderOrV2Pragma > roots (anon)"](e[i]);if(d===void 0)return;if(d!==c||t!==e){if(t===e){t={};for(let u=0;u<a;u++)t[n[u][0]]=n[u][1]}t.roots=d}}break;case"version":{r--;const d=V.Int(e[i]);if(d===void 0)return;if(d!==c||t!==e){if(t===e){t={};for(let u=0;u<a;u++)t[n[u][0]]=n[u][1]}t.version=d}}break;default:return}}if(!(r>0))return t}},O={"CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)":T.Link,"CarV1HeaderOrV2Pragma > roots (anon)":e=>{if(T.List(e)!==void 0){for(let n=0;n<e.length;n++){let t=e[n];if(t=O["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](t),t===void 0)return;if(t!==e[n]){const r=e.slice(0,n);for(let a=n;a<e.length;a++){let i=e[a];if(i=O["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](i),i===void 0)return;r.push(i)}return r}}return e}},Int:T.Int,CarV1HeaderOrV2Pragma:e=>{if(T.Map(e)===void 0)return;const n=Object.entries(e);let t=e,r=1;for(let a=0;a<n.length;a++){const[i,c]=n[a];switch(i){case"roots":{const d=O["CarV1HeaderOrV2Pragma > roots (anon)"](c);if(d===void 0)return;if(d!==c||t!==e){if(t===e){t={};for(let u=0;u<a;u++)t[n[u][0]]=n[u][1]}t.roots=d}}break;case"version":{r--;const d=O.Int(c);if(d===void 0)return;if(d!==c||t!==e){if(t===e){t={};for(let u=0;u<a;u++)t[n[u][0]]=n[u][1]}t.version=d}}break;default:return}}if(!(r>0))return t}},$e={toTyped:V.CarV1HeaderOrV2Pragma,toRepresentation:O.CarV1HeaderOrV2Pragma};async function Z(e,n){const t=B(await e.upTo(8),e);if(t===0)throw new Error("Invalid CAR header (zero length)");const r=await e.exactly(t,!0),a=ge(r);if($e.toTyped(a)===void 0)throw new Error("Invalid CAR header format");if(a.version!==1&&a.version!==2||n!==void 0&&a.version!==n)throw new Error(`Invalid CAR version: ${a.version}${n!==void 0?` (expected ${n})`:""}`);if(a.version===1){if(!Array.isArray(a.roots))throw new Error("Invalid CAR header format");return a}if(a.roots!==void 0)throw new Error("Invalid CAR header format");const i=Te(await e.exactly(Re,!0));e.seek(i.dataOffset-e.pos);const c=await Z(e,1);return Object.assign(c,i)}async function be(e){const n=await e.exactly(2,!1);if(n[0]===q.SHA2_256&&n[1]===q.LENGTH){const c=await e.exactly(34,!0),d=J(c);return X.create(0,q.DAG_PB,d)}const t=B(await e.upTo(8),e);if(t!==1)throw new Error(`Unexpected CID version (${t})`);const r=B(await e.upTo(8),e),a=await e.exactly(Ce(await e.upTo(8)),!0),i=J(a);return X.create(t,r,i)}async function j(e){const n=e.pos;let t=B(await e.upTo(8),e);if(t===0)throw new Error("Invalid CAR section (zero length)");t+=e.pos-n;const r=await be(e),a=t-Number(e.pos-n);return{cid:r,length:t,blockLength:a}}async function Se(e){const{cid:n,blockLength:t}=await j(e);return{bytes:await e.exactly(t,!0),cid:n}}async function He(e){const n=e.pos,{cid:t,length:r,blockLength:a}=await j(e),i={cid:t,length:r,blockLength:a,offset:n,blockOffset:e.pos};return e.seek(i.blockLength),i}function _e(e){const n=(async()=>{const t=await Z(e);if(t.version===2){const r=e.pos-t.dataOffset;e=Ve(e,t.dataSize-r)}return t})();return{header:()=>n,async*blocks(){for(await n;(await e.upTo(8)).length>0;)yield await Se(e)},async*blocksIndex(){for(await n;(await e.upTo(8)).length>0;)yield await He(e)}}}function ke(e){let n=0;return{async upTo(t){return e.subarray(n,n+Math.min(t,e.length-n))},async exactly(t,r=!1){if(t>e.length-n)throw new Error("Unexpected end of data");const a=e.subarray(n,n+t);return r&&(n+=t),a},seek(t){n+=t},get pos(){return n}}}function Ne(e){let n=0,t=0,r=0,a=new Uint8Array(0);const i=async c=>{t=a.length-r;const d=[a.subarray(r)];for(;t<c;){const o=await e();if(o==null)break;t<0?o.length>t&&d.push(o.subarray(-t)):d.push(o),t+=o.length}a=new Uint8Array(d.reduce((o,l)=>o+l.length,0));let u=0;for(const o of d)a.set(o,u),u+=o.length;r=0};return{async upTo(c){return a.length-r<c&&await i(c),a.subarray(r,r+Math.min(a.length-r,c))},async exactly(c,d=!1){if(a.length-r<c&&await i(c),a.length-r<c)throw new Error("Unexpected end of data");const u=a.subarray(r,r+c);return d&&(n+=c,r+=c),u},seek(c){n+=c,r+=c},get pos(){return n}}}function xe(e){const n=e[Symbol.asyncIterator]();async function t(){const r=await n.next();return r.done?null:r.value}return Ne(t)}function Ve(e,n){let t=0;return{async upTo(r){let a=await e.upTo(r);return a.length+t>n&&(a=a.subarray(0,n-t)),a},async exactly(r,a=!1){const i=await e.exactly(r,a);if(i.length+t>n)throw new Error("Unexpected end of data");return a&&(t+=r),i},seek(r){t+=r,e.seek(r)},get pos(){return e.pos}}}class Oe{constructor(n,t,r){this._version=n,this._roots=t,this._iterable=r,this._decoded=!1}get version(){return this._version}async getRoots(){return this._roots}}class D extends Oe{[Symbol.asyncIterator](){if(this._decoded)throw new Error("Cannot decode more than once");if(!this._iterable)throw new Error("Block iterable not found");return this._decoded=!0,this._iterable[Symbol.asyncIterator]()}static async fromBytes(n){const{version:t,roots:r,iterator:a}=await Ue(n);return new D(t,r,a)}static async fromIterable(n){const{version:t,roots:r,iterator:a}=await Le(n);return new D(t,r,a)}}async function Ue(e){if(!(e instanceof Uint8Array))throw new TypeError("fromBytes() requires a Uint8Array");return ee(ke(e))}async function Le(e){if(!e||typeof e[Symbol.asyncIterator]!="function")throw new TypeError("fromIterable() requires an async iterable");return ee(xe(e))}async function ee(e){const n=_e(e),{version:t,roots:r}=await n.header();return{version:t,roots:r,iterator:n.blocks()}}async function*Me(e){const n=e.getReader();try{for(;;){const{done:t,value:r}=await n.read();if(t)return;yield r}}finally{n.releaseLock()}}async function Pe(e){const n=await D.fromIterable(Me(e.stream())),t=[],r=[],a={};let i=null;for await(const{cid:c,bytes:d}of n){i=c.toString();const u=await pe(d),{Links:o}=u;if(o.length===0){t.push(c.toString());continue}if(o.every(({Name:s})=>s==="")){r.push(c.toString());continue}const l=o.map(({Name:s,Tsize:f,Hash:y})=>({name:s,size:f,cid:y.toString()}));a[c.toString()]=l.map(s=>{const f=r.includes(s.cid)||t.includes(s.cid)?"file":"directory",y={type:f,title:s.name??`Unknown ${f}`,size:s.size??0,cid:s.cid};if(f==="directory"){const h=y.children=a[s.cid],p=h.map(({childCount:v=0})=>v);y.childCount=p.reduce((v,w)=>v+w,h.length)}return y})}if(!i)throw new Error("No nodes found.");return a[i]}async function Ae(e,n=[],t){const r=Ee();try{const o=await u(e);await d({rootId:o});const l=`/${n.join("/")}${n.length>0?"/":""}`;return t==null||t(`Mounted ${o} at ${l}.`),o}finally{}async function a(){const o=r.session();try{const l=`
        CREATE (dir:Spot { mimis_id: $uuid })
        RETURN elementId(dir) AS id
      `,s=G(),{records:f}=await o.run(l,{uuid:s});return t==null||t({"Created Spot":G}),f[0].get("id")}finally{await o.close()}}async function i({dirId:o,itemId:l,name:s,type:f=":Spot",rship:y=":CONTAINS"}){const h=r.session();try{const p=`
        MATCH (entry) WHERE elementId(entry) = $itemId
        ${o==null?`CREATE (dir${f} { mimis_id: $uuid })`:"MATCH (dir) WHERE elementId(dir) = $dirId"}
        MERGE (dir)-[c${y} ${s!=null?"{ path: $name }":""}]->(entry)
        RETURN elementId(dir) AS id
      `,{records:v}=await h.run(p,{itemId:l,name:s,dirId:o,uuid:G()}),w=v[0].get("id");return t==null||t(`Added ${s} → ${l} (${o} → ${w})`),w}finally{await h.close()}}async function c({cid:o,type:l,size:s}){const f=r.session();try{const y=`
        MERGE (file:IPFS:File { cid: $cid })
        MERGE (item:Nöopoint)-[:EMBODIED_AS]->(file)
        SET file.mimetype = CASE WHEN $type IS NOT NULL THEN $type END
        SET file.size = $size
        RETURN elementId(item) AS id
      `,{records:h}=await f.run(y,{cid:o,type:l,size:s});return t==null||t({Added:`/${o} (${l})`}),h[0].get("id")}finally{await f.close()}}async function d({rootId:o}){const l=r.session();try{const s=n.length===0;s&&(t==null||t({"Rooting To":o}));const f=`
        ${s?"MATCH (r:Spot)":"MERGE (r:Root)"}
        ${s?"WHERE elementId(r) = $rootId":""}
        SET r:Root:Mount:Spot
        RETURN elementId(r) AS id
      `;console.debug({rootQ:f});const{records:y}=await l.run(f,{rootId:o});let h=y[0].get("id");for(t==null||t(`Added Root: ${h}`);n.length>1;){const p=`
          MATCH (dir) WHERE elementId(dir) = $current
          MERGE (dir)-[:CONTAINS {path: $elem}]->(item)
          SET item:Spot
          RETURN elementId(item) as id
        `,v=n.shift(),{records:w}=await l.run(p,{current:h,elem:v});h=w[0].get("id")}if(!e.children)throw new Error("Root has no children.");s||await l.run(`
          MATCH (mount) WHERE elementId(mount) = $current
          MATCH (base) WHERE elementId(base) = $rootId
          MERGE (mount)-[:CONNECTS { path: $name }]->(base)
        `,{current:h,rootId:o,name:n[0]})}finally{await l.close()}}async function u(o){if(!o.children)throw new Error(`Not a directory: ${o.title}.`);if(o.children.length===0)throw new Error(`Empty directory: ${o.title}.`);const l=await a();return await Promise.all(o.children.map(async s=>{if(!s.selected&&s.getSelectedNodes().length===0)return null;if(s.children)await i({itemId:await u(s),dirId:l,name:s.title});else{const f=s.title.split(".").at(-1),y=s.title.slice(0,-(f.length+1)),h=(()=>{switch(f){case"svg":return"image/svg+xml";case"png":return"image/png";case"jpg":case"jpeg":return"image/jpeg";default:return null}})();let p=await c({cid:s.data.cid,type:h,size:s.data.size});p=await i({itemId:p,dirId:y===f?l:void 0,rship:":REPRESENTED_BY"}),y!==f&&await i({itemId:p,name:y,dirId:l})}})),l}}var Be=F('<link rel="icon" href="upload.svg"/>'),De=F('<form class="svelte-1gc7151"><input placeholder="/system/mount/point/"/> <button>Neo4j Import <!></button></form>'),ze=F('<header><h1>Upload a CAR File to Mïmis</h1></header> <main><form class="svelte-1gc7151"><input type="file" required accept=".car"/> <button>Read CAR</button></form> <!> <div id="fs-tree" class="svelte-1gc7151"></div></main>',1);function nt(e,n){var v,w,H,_;re(n,!0);class t{constructor(){L(this,w,S());L(this,H,S(!((v=this.form)!=null&&v.checkValidity())));L(this,_,S(!1))}get form(){return I(C(this,w))}set form(m){x(C(this,w),m,!0)}get disabled(){return I(C(this,H))}set disabled(m){x(C(this,H),m,!0)}get generating(){return I(C(this,_))}set generating(m){x(C(this,_),m,!0)}}w=new WeakMap,H=new WeakMap,_=new WeakMap;let r=S(0),a=S(void 0),i=new t,c=S("");const d=async g=>{var b,U;g.preventDefault();const m=((b=i.form)==null?void 0:b.querySelector('input[type="file"]'))??null,R=(U=m==null?void 0:m.files)==null?void 0:U[0];if(!R)throw new Error("No file selected.");const E=await Pe(R);we(E),x(a,ve({source:E,mount:"fs-tree"}),!0)},u=async g=>{g.preventDefault();try{i.generating=!0;const m=I(c).split("/").filter(Boolean);if(!I(a))throw new Error("No tree to mount.");const R=b=>{console.debug(b),ce(r)};console.debug({root:I(a).root});const E=await Ae(I(a).root,m,R);Ie({text:`Loaded: ipfs://${E.slice(0,5)}…${E.slice(-5)}`,duration:8e3,destination:`https://w3s.link/ipfs/${E}`,newWindow:!0,close:!0,gravity:"bottom",position:"center",stopOnFocus:!0,style:{background:"linear-gradient(to right, #00b09b, #96c93d)"}}).showToast()}finally{i.generating=!1}};var o=ze();fe(g=>{var m=Be();oe.title="Upload a CAR",P(g,m)});var l=N(ae(o),2),s=M(l),f=M(s);f.__change=()=>{var g;return i.disabled=!((g=i.form)!=null&&g.checkValidity())};var y=N(f,2);A(s),he(s,g=>i.form=g,()=>i==null?void 0:i.form);var h=N(s,2);{var p=g=>{var m=De(),R=M(m);me(R);var E=N(R,2),b=N(M(E));{var U=k=>{var W=ue();z(te=>le(W,te),[()=>I(r).toLocaleString()]),P(k,W)};K(b,k=>{i.generating&&k(U)})}A(E),A(m),z(()=>E.disabled=i.generating),Y("submit",m,u),ye(R,()=>I(c),k=>x(c,k)),P(g,m)};K(h,g=>{I(a)&&g(p)})}se(2),A(l),z(()=>y.disabled=i.disabled),Y("submit",s,d),P(e,o),ie()}de(["change"]);export{nt as component};
