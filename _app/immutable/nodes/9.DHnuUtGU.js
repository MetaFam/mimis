var W=e=>{throw TypeError(e)};var te=(e,n,t)=>n.has(e)||W("Cannot "+t);var R=(e,n,t)=>(te(e,n,"read from private field"),t?t.call(e):n.get(e)),U=(e,n,t)=>n.has(e)?W("Cannot add the same private member more than once"):n instanceof WeakSet?n.add(e):n.set(e,t);import{t as G,a as D,d as ne}from"../chunks/B3xmI3gr.js";import{p as re,s as _,f as ae,c as P,t as z,a as ie,ae as k,i as I,ad as x,$ as oe,r as L,w as se,aI as ce}from"../chunks/BvUmx899.js";import{s as ue}from"../chunks/SMaB7GV9.js";import{i as Q}from"../chunks/DKHvhmB-.js";import{h as de}from"../chunks/DyBNRPx0.js";import{r as le}from"../chunks/CVWUL3tM.js";import{d as fe,e as Y}from"../chunks/CRs1HFvY.js";import{c as ye}from"../chunks/tswFArya.js";import{b as me}from"../chunks/XKytFIX2.js";import{v as b,d as he,a as K,C as J,b as ge,s as we,w as pe}from"../chunks/Ke9233B-.js";import{g as ve,T as Ee}from"../chunks/CwkKCLNu.js";const F={SHA2_256:18,LENGTH:32,DAG_PB:112},Ie=40;function M(e,n){if(!e.length)throw new Error("Unexpected end of data");const t=b.decode(e);return n.seek(b.decode.bytes),t}function Ce(e){const n=new DataView(e.buffer,e.byteOffset,e.byteLength);let t=0;return{version:2,characteristics:[n.getBigUint64(t,!0),n.getBigUint64(t+=8,!0)],dataOffset:Number(n.getBigUint64(t+=8,!0)),dataSize:Number(n.getBigUint64(t+=8,!0)),indexOffset:Number(n.getBigUint64(t+=8,!0))}}function Te(e){b.decode(e);const n=b.decode.bytes,t=b.decode(e.subarray(b.decode.bytes)),r=b.decode.bytes;return n+r+t}const T={Null:e=>e===null?e:void 0,Int:e=>Number.isInteger(e)?e:void 0,Float:e=>typeof e=="number"&&Number.isFinite(e)?e:void 0,String:e=>typeof e=="string"?e:void 0,Bool:e=>typeof e=="boolean"?e:void 0,Bytes:e=>e instanceof Uint8Array?e:void 0,Link:e=>e!==null&&typeof e=="object"&&e.asCID===e?e:void 0,List:e=>Array.isArray(e)?e:void 0,Map:e=>e!==null&&typeof e=="object"&&e.asCID!==e&&!Array.isArray(e)&&!(e instanceof Uint8Array)?e:void 0},V={"CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)":T.Link,"CarV1HeaderOrV2Pragma > roots (anon)":e=>{if(T.List(e)!==void 0){for(let n=0;n<e.length;n++){let t=e[n];if(t=V["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](t),t===void 0)return;if(t!==e[n]){const r=e.slice(0,n);for(let a=n;a<e.length;a++){let i=e[a];if(i=V["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](i),i===void 0)return;r.push(i)}return r}}return e}},Int:T.Int,CarV1HeaderOrV2Pragma:e=>{if(T.Map(e)===void 0)return;const n=Object.entries(e);let t=e,r=1;for(let a=0;a<n.length;a++){const[i,o]=n[a];switch(i){case"roots":{const d=V["CarV1HeaderOrV2Pragma > roots (anon)"](e[i]);if(d===void 0)return;if(d!==o||t!==e){if(t===e){t={};for(let u=0;u<a;u++)t[n[u][0]]=n[u][1]}t.roots=d}}break;case"version":{r--;const d=V.Int(e[i]);if(d===void 0)return;if(d!==o||t!==e){if(t===e){t={};for(let u=0;u<a;u++)t[n[u][0]]=n[u][1]}t.version=d}}break;default:return}}if(!(r>0))return t}},O={"CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)":T.Link,"CarV1HeaderOrV2Pragma > roots (anon)":e=>{if(T.List(e)!==void 0){for(let n=0;n<e.length;n++){let t=e[n];if(t=O["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](t),t===void 0)return;if(t!==e[n]){const r=e.slice(0,n);for(let a=n;a<e.length;a++){let i=e[a];if(i=O["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](i),i===void 0)return;r.push(i)}return r}}return e}},Int:T.Int,CarV1HeaderOrV2Pragma:e=>{if(T.Map(e)===void 0)return;const n=Object.entries(e);let t=e,r=1;for(let a=0;a<n.length;a++){const[i,o]=n[a];switch(i){case"roots":{const d=O["CarV1HeaderOrV2Pragma > roots (anon)"](o);if(d===void 0)return;if(d!==o||t!==e){if(t===e){t={};for(let u=0;u<a;u++)t[n[u][0]]=n[u][1]}t.roots=d}}break;case"version":{r--;const d=O.Int(o);if(d===void 0)return;if(d!==o||t!==e){if(t===e){t={};for(let u=0;u<a;u++)t[n[u][0]]=n[u][1]}t.version=d}}break;default:return}}if(!(r>0))return t}},Re={toTyped:V.CarV1HeaderOrV2Pragma,toRepresentation:O.CarV1HeaderOrV2Pragma};async function X(e,n){const t=M(await e.upTo(8),e);if(t===0)throw new Error("Invalid CAR header (zero length)");const r=await e.exactly(t,!0),a=he(r);if(Re.toTyped(a)===void 0)throw new Error("Invalid CAR header format");if(a.version!==1&&a.version!==2||n!==void 0&&a.version!==n)throw new Error(`Invalid CAR version: ${a.version}${n!==void 0?` (expected ${n})`:""}`);if(a.version===1){if(!Array.isArray(a.roots))throw new Error("Invalid CAR header format");return a}if(a.roots!==void 0)throw new Error("Invalid CAR header format");const i=Ce(await e.exactly(Ie,!0));e.seek(i.dataOffset-e.pos);const o=await X(e,1);return Object.assign(o,i)}async function be(e){const n=await e.exactly(2,!1);if(n[0]===F.SHA2_256&&n[1]===F.LENGTH){const o=await e.exactly(34,!0),d=K(o);return J.create(0,F.DAG_PB,d)}const t=M(await e.upTo(8),e);if(t!==1)throw new Error(`Unexpected CID version (${t})`);const r=M(await e.upTo(8),e),a=await e.exactly(Te(await e.upTo(8)),!0),i=K(a);return J.create(t,r,i)}async function Z(e){const n=e.pos;let t=M(await e.upTo(8),e);if(t===0)throw new Error("Invalid CAR section (zero length)");t+=e.pos-n;const r=await be(e),a=t-Number(e.pos-n);return{cid:r,length:t,blockLength:a}}async function $e(e){const{cid:n,blockLength:t}=await Z(e);return{bytes:await e.exactly(t,!0),cid:n}}async function ke(e){const n=e.pos,{cid:t,length:r,blockLength:a}=await Z(e),i={cid:t,length:r,blockLength:a,offset:n,blockOffset:e.pos};return e.seek(i.blockLength),i}function Se(e){const n=(async()=>{const t=await X(e);if(t.version===2){const r=e.pos-t.dataOffset;e=xe(e,t.dataSize-r)}return t})();return{header:()=>n,async*blocks(){for(await n;(await e.upTo(8)).length>0;)yield await $e(e)},async*blocksIndex(){for(await n;(await e.upTo(8)).length>0;)yield await ke(e)}}}function He(e){let n=0;return{async upTo(t){return e.subarray(n,n+Math.min(t,e.length-n))},async exactly(t,r=!1){if(t>e.length-n)throw new Error("Unexpected end of data");const a=e.subarray(n,n+t);return r&&(n+=t),a},seek(t){n+=t},get pos(){return n}}}function Ne(e){let n=0,t=0,r=0,a=new Uint8Array(0);const i=async o=>{t=a.length-r;const d=[a.subarray(r)];for(;t<o;){const s=await e();if(s==null)break;t<0?s.length>t&&d.push(s.subarray(-t)):d.push(s),t+=s.length}a=new Uint8Array(d.reduce((s,l)=>s+l.length,0));let u=0;for(const s of d)a.set(s,u),u+=s.length;r=0};return{async upTo(o){return a.length-r<o&&await i(o),a.subarray(r,r+Math.min(a.length-r,o))},async exactly(o,d=!1){if(a.length-r<o&&await i(o),a.length-r<o)throw new Error("Unexpected end of data");const u=a.subarray(r,r+o);return d&&(n+=o,r+=o),u},seek(o){n+=o,r+=o},get pos(){return n}}}function _e(e){const n=e[Symbol.asyncIterator]();async function t(){const r=await n.next();return r.done?null:r.value}return Ne(t)}function xe(e,n){let t=0;return{async upTo(r){let a=await e.upTo(r);return a.length+t>n&&(a=a.subarray(0,n-t)),a},async exactly(r,a=!1){const i=await e.exactly(r,a);if(i.length+t>n)throw new Error("Unexpected end of data");return a&&(t+=r),i},seek(r){t+=r,e.seek(r)},get pos(){return e.pos}}}class Ve{constructor(n,t,r){this._version=n,this._roots=t,this._iterable=r,this._decoded=!1}get version(){return this._version}async getRoots(){return this._roots}}class B extends Ve{[Symbol.asyncIterator](){if(this._decoded)throw new Error("Cannot decode more than once");if(!this._iterable)throw new Error("Block iterable not found");return this._decoded=!0,this._iterable[Symbol.asyncIterator]()}static async fromBytes(n){const{version:t,roots:r,iterator:a}=await Oe(n);return new B(t,r,a)}static async fromIterable(n){const{version:t,roots:r,iterator:a}=await Ae(n);return new B(t,r,a)}}async function Oe(e){if(!(e instanceof Uint8Array))throw new TypeError("fromBytes() requires a Uint8Array");return j(He(e))}async function Ae(e){if(!e||typeof e[Symbol.asyncIterator]!="function")throw new TypeError("fromIterable() requires an async iterable");return j(_e(e))}async function j(e){const n=Se(e),{version:t,roots:r}=await n.header();return{version:t,roots:r,iterator:n.blocks()}}async function*Ue(e){const n=e.getReader();try{for(;;){const{done:t,value:r}=await n.read();if(t)return;yield r}}finally{n.releaseLock()}}async function De(e){const n=await B.fromIterable(Ue(e.stream())),t=[],r=[],a={};let i=null;for await(const{cid:o,bytes:d}of n){i=o.toString();const u=await ge(d),{Links:s}=u;if(s.length===0){t.push(o.toString());continue}if(s.every(({Name:c})=>c==="")){r.push(o.toString());continue}const l=s.map(({Name:c,Tsize:f,Hash:y})=>({name:c,size:f,cid:y.toString()}));a[o.toString()]=l.map(c=>{const f=r.includes(c.cid)||t.includes(c.cid)?"file":"directory",y={type:f,title:c.name??`Unknown ${f}`,size:c.size??0,cid:c.cid};if(f==="directory"){const g=y.children=a[c.cid],p=g.map(({childCount:v=0})=>v);y.childCount=p.reduce((v,w)=>v+w,g.length)}return y})}if(!i)throw new Error("No nodes found.");return a[i]}async function Pe(e,n=[],t){const r=ve();try{const s=`/${n.join("/")}${n.length>0?"/":""}`,l=await u(e);return await d({rootId:l}),t==null||t(`Mounted ${l} at ${s}.`),l}finally{await r.close()}async function a(){const s=r.session();try{const l=`
        CREATE (dir:IPFS:Directory)
        RETURN elementId(dir) AS id
      `,{records:c}=await s.run(l);return t==null||t("Created Directory"),c[0].get("id")}finally{await s.close()}}async function i({dirId:s,itemId:l,name:c,type:f=":IPFS:Directory",rship:y=":CONTAINS"}){const g=r.session();try{const p=`
        MATCH (entry) WHERE elementId(entry) = $itemId
        ${s==null?`CREATE (dir${f})`:"MATCH (dir) WHERE elementId(dir) = $dirId"}
        MERGE (dir)-[c${y} ${c!=null?"{ path: $name }":""}]->(entry)
        RETURN elementId(dir) AS id
      `,{records:v}=await g.run(p,{itemId:l,name:c,dirId:s}),w=v[0].get("id");return t==null||t(`Added ${c} → ${l} (${s} → ${w})`),w}finally{await g.close()}}async function o({cid:s,type:l,size:c}){const f=r.session();try{const y=`
        MERGE (file:IPFS:File { cid: $cid })
        MERGE (item:Nöopoint)-[:EMBODIED_AS]->(file)
        SET file.mimetype = CASE WHEN $type IS NOT NULL THEN $type END
        SET file.size = $size
        RETURN elementId(item) AS id
      `,{records:g}=await f.run(y,{cid:s,type:l,size:c});return t==null||t(`Added /${s} (${l})`),g[0].get("id")}finally{await f.close()}}async function d({rootId:s}){const l=r.session(),c=`
      MERGE (r:Root)
      SET r:Mount:Directory
      RETURN elementId(r) AS id
    `,{records:f}=await l.run(c);let y=f[0].get("id");for(t==null||t(`Added Root: ${y}`);n.length>1;){const p=`
        MATCH (dir)
        WHERE elementId(dir) = $current
        MERGE (dir)-[:CONTAINS {path: $elem}]->(item)
        SET item:Mount:Directory
        RETURN elementId(item) as id
      `,v=n.shift(),{records:w}=await l.run(p,{current:y,elem:v});y=w[0].get("id")}if(!e.children)throw new Error("Root has no children.");await l.run(`
      MATCH (mount)
      MATCH (base)
      WHERE elementId(mount) = $current
      AND elementId(base) = $rootId
      MERGE (mount)-[:CONNECTS { path: $name }]->(base)
    `,{current:y,rootId:s,name:n[0]}),await l.close()}async function u(s){if(!s.children)throw new Error(`Not a directory: ${s.title}.`);if(s.children.length===0)throw new Error(`Empty directory: ${s.title}.`);const l=await a();return await Promise.all(s.children.map(async c=>{if(!c.selected&&c.getSelectedNodes().length===0)return null;if(c.children)await i({itemId:await u(c),dirId:l,name:c.title});else{const f=c.title.split(".").at(-1),y=c.title.slice(0,-(f.length+1)),g=(()=>{switch(f){case"svg":return"image/svg+xml";case"png":return"image/png";case"jpg":case"jpeg":return"image/jpeg";default:return null}})();let p=await o({cid:c.data.cid,type:g,size:c.data.size});p=await i({itemId:p,dirId:y===f?l:void 0,rship:":REPRESENTED_BY"}),y!==f&&await i({itemId:p,name:y,dirId:l})}})),l}}var Le=G('<link rel="icon" href="upload.svg">'),Me=G('<form class="svelte-1gc7151"><input placeholder="/system/mount/point/"> <button>Neo4j Import <!></button></form>'),Be=G('<header><h1>Upload a CAR File to Mïmis</h1></header> <main><form class="svelte-1gc7151"><input type="file" required accept=".car"> <button>Read CAR</button></form> <!> <div id="fs-tree" class="svelte-1gc7151"></div></main>',1);function et(e,n){var v,w,S,H;re(n,!0);class t{constructor(){U(this,w,k());U(this,S,k(!((v=this.form)!=null&&v.checkValidity())));U(this,H,k(!1))}get form(){return I(R(this,w))}set form(m){x(R(this,w),m,!0)}get disabled(){return I(R(this,S))}set disabled(m){x(R(this,S),m,!0)}get generating(){return I(R(this,H))}set generating(m){x(R(this,H),m,!0)}}w=new WeakMap,S=new WeakMap,H=new WeakMap;let r=k(0),a=k(void 0),i=new t,o=k("");const d=async h=>{var $,A;h.preventDefault();const m=(($=i.form)==null?void 0:$.querySelector('input[type="file"]'))??null,C=(A=m==null?void 0:m.files)==null?void 0:A[0];if(!C)throw new Error("No file selected.");const E=await De(C);we(E),x(a,pe({source:E,mount:"fs-tree"}),!0)},u=async h=>{h.preventDefault();try{i.generating=!0;const m=I(o).split("/").filter(Boolean);if(!I(a))throw new Error("No tree to mount.");const C=$=>{console.debug($),ce(r)};console.debug({root:I(a).root});const E=await Pe(I(a).root,m,C);Ee({text:`Loaded: ipfs://${E.slice(0,5)}…${E.slice(-5)}`,duration:8e3,destination:`https://w3s.link/ipfs/${E}`,newWindow:!0,close:!0,gravity:"bottom",position:"center",stopOnFocus:!0,style:{background:"linear-gradient(to right, #00b09b, #96c93d)"}}).showToast()}finally{i.generating=!1}};var s=Be();de(h=>{var m=Le();oe.title="Upload a CAR",D(h,m)});var l=_(ae(s),2),c=P(l),f=P(c);f.__change=()=>{var h;return i.disabled=!((h=i.form)!=null&&h.checkValidity())};var y=_(f,2);L(c),me(c,h=>i.form=h,()=>i==null?void 0:i.form);var g=_(c,2);{var p=h=>{var m=Me(),C=P(m);le(C);var E=_(C,2),$=_(P(E));{var A=N=>{var q=ne();z(ee=>ue(q,ee),[()=>I(r).toLocaleString()]),D(N,q)};Q($,N=>{i.generating&&N(A)})}L(E),L(m),z(()=>E.disabled=i.generating),Y("submit",m,u),ye(C,()=>I(o),N=>x(o,N)),D(h,m)};Q(g,h=>{I(a)&&h(p)})}se(2),L(l),z(()=>y.disabled=i.disabled),Y("submit",c,d),D(e,s),ie()}fe(["change"]);export{et as component};
