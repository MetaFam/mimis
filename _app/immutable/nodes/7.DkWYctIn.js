var $=e=>{throw TypeError(e)};var J=(e,n,t)=>n.has(e)||$("Cannot "+t);var I=(e,n,t)=>(J(e,n,"read from private field"),t?t.call(e):n.get(e)),x=(e,n,t)=>n.has(e)?$("Cannot add the same private member more than once"):n instanceof WeakSet?n.add(e):n.set(e,t);import{a as M,t as Q}from"../chunks/disclose-version.CtYrEA78.js";import{aD as X,a7 as Z,h as j,p as ee,f as te,t as ne,a as re,aA as ae,c as D,s as L,d as v,aH as A,e as b,r as P,aI as U}from"../chunks/runtime.Dweuwbqp.js";import{l as oe,d as ie,e as B}from"../chunks/events.BodA8K1H.js";import{h as se}from"../chunks/svelte-head.iJn9f2HD.js";import{i as ce,p as R}from"../chunks/if.BfmecCpI.js";import{r as de}from"../chunks/attributes.D28ev2Wi.js";import{b as ue}from"../chunks/this.6eaA7jh8.js";import{v as C,d as fe,a as z,C as G,b as le,s as ye,w as he}from"../chunks/bootstrap-icons.1fgYhea-.js";import{g as me}from"../chunks/neo4jDriver.tQrFAidX.js";function pe(e,n,t=n){var a=X();oe(e,"input",()=>{var r=q(e)?F(e.value):e.value;t(r),a&&r!==(r=n())&&(e.value=r??"")}),Z(()=>{var r=n();if(j&&e.defaultValue!==e.value){t(e.value);return}q(e)&&r===F(e.value)||e.type==="date"&&!r&&!e.value||r!==e.value&&(e.value=r??"")})}function q(e){var n=e.type;return n==="number"||n==="range"}function F(e){return e===""?null:+e}const N={SHA2_256:18,LENGTH:32,DAG_PB:112},we=40;function H(e,n){if(!e.length)throw new Error("Unexpected end of data");const t=C.decode(e);return n.seek(C.decode.bytes),t}function ge(e){const n=new DataView(e.buffer,e.byteOffset,e.byteLength);let t=0;return{version:2,characteristics:[n.getBigUint64(t,!0),n.getBigUint64(t+=8,!0)],dataOffset:Number(n.getBigUint64(t+=8,!0)),dataSize:Number(n.getBigUint64(t+=8,!0)),indexOffset:Number(n.getBigUint64(t+=8,!0))}}function ve(e){C.decode(e);const n=C.decode.bytes,t=C.decode(e.subarray(C.decode.bytes)),a=C.decode.bytes;return n+a+t}const g={Null:e=>e===null?e:void 0,Int:e=>Number.isInteger(e)?e:void 0,Float:e=>typeof e=="number"&&Number.isFinite(e)?e:void 0,String:e=>typeof e=="string"?e:void 0,Bool:e=>typeof e=="boolean"?e:void 0,Bytes:e=>e instanceof Uint8Array?e:void 0,Link:e=>e!==null&&typeof e=="object"&&e.asCID===e?e:void 0,List:e=>Array.isArray(e)?e:void 0,Map:e=>e!==null&&typeof e=="object"&&e.asCID!==e&&!Array.isArray(e)&&!(e instanceof Uint8Array)?e:void 0},_={"CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)":g.Link,"CarV1HeaderOrV2Pragma > roots (anon)":e=>{if(g.List(e)!==void 0){for(let n=0;n<e.length;n++){let t=e[n];if(t=_["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](t),t===void 0)return;if(t!==e[n]){const a=e.slice(0,n);for(let r=n;r<e.length;r++){let s=e[r];if(s=_["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](s),s===void 0)return;a.push(s)}return a}}return e}},Int:g.Int,CarV1HeaderOrV2Pragma:e=>{if(g.Map(e)===void 0)return;const n=Object.entries(e);let t=e,a=1;for(let r=0;r<n.length;r++){const[s,c]=n[r];switch(s){case"roots":{const o=_["CarV1HeaderOrV2Pragma > roots (anon)"](e[s]);if(o===void 0)return;if(o!==c||t!==e){if(t===e){t={};for(let d=0;d<r;d++)t[n[d][0]]=n[d][1]}t.roots=o}}break;case"version":{a--;const o=_.Int(e[s]);if(o===void 0)return;if(o!==c||t!==e){if(t===e){t={};for(let d=0;d<r;d++)t[n[d][0]]=n[d][1]}t.version=o}}break;default:return}}if(!(a>0))return t}},T={"CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)":g.Link,"CarV1HeaderOrV2Pragma > roots (anon)":e=>{if(g.List(e)!==void 0){for(let n=0;n<e.length;n++){let t=e[n];if(t=T["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](t),t===void 0)return;if(t!==e[n]){const a=e.slice(0,n);for(let r=n;r<e.length;r++){let s=e[r];if(s=T["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](s),s===void 0)return;a.push(s)}return a}}return e}},Int:g.Int,CarV1HeaderOrV2Pragma:e=>{if(g.Map(e)===void 0)return;const n=Object.entries(e);let t=e,a=1;for(let r=0;r<n.length;r++){const[s,c]=n[r];switch(s){case"roots":{const o=T["CarV1HeaderOrV2Pragma > roots (anon)"](c);if(o===void 0)return;if(o!==c||t!==e){if(t===e){t={};for(let d=0;d<r;d++)t[n[d][0]]=n[d][1]}t.roots=o}}break;case"version":{a--;const o=T.Int(c);if(o===void 0)return;if(o!==c||t!==e){if(t===e){t={};for(let d=0;d<r;d++)t[n[d][0]]=n[d][1]}t.version=o}}break;default:return}}if(!(a>0))return t}},Ce={toTyped:_.CarV1HeaderOrV2Pragma,toRepresentation:T.CarV1HeaderOrV2Pragma};async function W(e,n){const t=H(await e.upTo(8),e);if(t===0)throw new Error("Invalid CAR header (zero length)");const a=await e.exactly(t,!0),r=fe(a);if(Ce.toTyped(r)===void 0)throw new Error("Invalid CAR header format");if(r.version!==1&&r.version!==2||n!==void 0&&r.version!==n)throw new Error(`Invalid CAR version: ${r.version}${n!==void 0?` (expected ${n})`:""}`);if(r.version===1){if(!Array.isArray(r.roots))throw new Error("Invalid CAR header format");return r}if(r.roots!==void 0)throw new Error("Invalid CAR header format");const s=ge(await e.exactly(we,!0));e.seek(s.dataOffset-e.pos);const c=await W(e,1);return Object.assign(c,s)}async function Ee(e){const n=await e.exactly(2,!1);if(n[0]===N.SHA2_256&&n[1]===N.LENGTH){const c=await e.exactly(34,!0),o=z(c);return G.create(0,N.DAG_PB,o)}const t=H(await e.upTo(8),e);if(t!==1)throw new Error(`Unexpected CID version (${t})`);const a=H(await e.upTo(8),e),r=await e.exactly(ve(await e.upTo(8)),!0),s=z(r);return G.create(t,a,s)}async function K(e){const n=e.pos;let t=H(await e.upTo(8),e);if(t===0)throw new Error("Invalid CAR section (zero length)");t+=e.pos-n;const a=await Ee(e),r=t-Number(e.pos-n);return{cid:a,length:t,blockLength:r}}async function Ie(e){const{cid:n,blockLength:t}=await K(e);return{bytes:await e.exactly(t,!0),cid:n}}async function _e(e){const n=e.pos,{cid:t,length:a,blockLength:r}=await K(e),s={cid:t,length:a,blockLength:r,offset:n,blockOffset:e.pos};return e.seek(s.blockLength),s}function Te(e){const n=(async()=>{const t=await W(e);if(t.version===2){const a=e.pos-t.dataOffset;e=He(e,t.dataSize-a)}return t})();return{header:()=>n,async*blocks(){for(await n;(await e.upTo(8)).length>0;)yield await Ie(e)},async*blocksIndex(){for(await n;(await e.upTo(8)).length>0;)yield await _e(e)}}}function ke(e){let n=0;return{async upTo(t){return e.subarray(n,n+Math.min(t,e.length-n))},async exactly(t,a=!1){if(t>e.length-n)throw new Error("Unexpected end of data");const r=e.subarray(n,n+t);return a&&(n+=t),r},seek(t){n+=t},get pos(){return n}}}function Ae(e){let n=0,t=0,a=0,r=new Uint8Array(0);const s=async c=>{t=r.length-a;const o=[r.subarray(a)];for(;t<c;){const i=await e();if(i==null)break;t<0?i.length>t&&o.push(i.subarray(-t)):o.push(i),t+=i.length}r=new Uint8Array(o.reduce((i,f)=>i+f.length,0));let d=0;for(const i of o)r.set(i,d),d+=i.length;a=0};return{async upTo(c){return r.length-a<c&&await s(c),r.subarray(a,a+Math.min(r.length-a,c))},async exactly(c,o=!1){if(r.length-a<c&&await s(c),r.length-a<c)throw new Error("Unexpected end of data");const d=r.subarray(a,a+c);return o&&(n+=c,a+=c),d},seek(c){n+=c,a+=c},get pos(){return n}}}function be(e){const n=e[Symbol.asyncIterator]();async function t(){const a=await n.next();return a.done?null:a.value}return Ae(t)}function He(e,n){let t=0;return{async upTo(a){let r=await e.upTo(a);return r.length+t>n&&(r=r.subarray(0,n-t)),r},async exactly(a,r=!1){const s=await e.exactly(a,r);if(s.length+t>n)throw new Error("Unexpected end of data");return r&&(t+=a),s},seek(a){t+=a,e.seek(a)},get pos(){return e.pos}}}class Ve{constructor(n,t,a){this._version=n,this._roots=t,this._iterable=a,this._decoded=!1}get version(){return this._version}async getRoots(){return this._roots}}class V extends Ve{[Symbol.asyncIterator](){if(this._decoded)throw new Error("Cannot decode more than once");if(!this._iterable)throw new Error("Block iterable not found");return this._decoded=!0,this._iterable[Symbol.asyncIterator]()}static async fromBytes(n){const{version:t,roots:a,iterator:r}=await xe(n);return new V(t,a,r)}static async fromIterable(n){const{version:t,roots:a,iterator:r}=await Re(n);return new V(t,a,r)}}async function xe(e){if(!(e instanceof Uint8Array))throw new TypeError("fromBytes() requires a Uint8Array");return Y(ke(e))}async function Re(e){if(!e||typeof e[Symbol.asyncIterator]!="function")throw new TypeError("fromIterable() requires an async iterable");return Y(be(e))}async function Y(e){const n=Te(e),{version:t,roots:a}=await n.header();return{version:t,roots:a,iterator:n.blocks()}}const Ne=!0,Ke=Object.freeze(Object.defineProperty({__proto__:null,prerender:Ne},Symbol.toStringTag,{value:"Module"}));async function*Se(e){const n=e.getReader();try{for(;;){const{done:t,value:a}=await n.read();if(t)return;yield a}}finally{n.releaseLock()}}async function Oe(e){const n=await V.fromIterable(Se(e.stream())),t=[],a=[],r={};let s=null;for await(const{cid:c,bytes:o}of n){s=c.toString();const d=await le(o),{Links:i}=d;if(i.length===0){t.push(c.toString());continue}if(i.every(({Name:u})=>u==="")){a.push(c.toString());continue}const f=i.map(({Name:u,Tsize:h,Hash:p})=>({name:u,size:h,cid:p.toString()}));r[c.toString()]=f.map(u=>{const h=a.includes(u.cid)||t.includes(u.cid)?"file":"directory",p={type:h,title:u.name??`Unknown ${h}`,size:u.size??0,cid:u.cid};if(h==="directory"){const m=p.children=r[u.cid],w=m.map(({childCount:l=0})=>l);p.childCount=w.reduce((l,y)=>l+y,m.length)}return p})}if(!s)throw new Error("No nodes found.");return r[s]}async function $e(e,n=[]){const t=me();try{const o=await c(e,structuredClone(n));console.info(`Mounted ${o} at /${n.join("/")}/.`)}finally{await t.close()}async function a({dirCID:o,entryCID:d,name:i}){const f=t.session();await f.run(`
      MATCH (e:IPFS { cid: $entryCID })
      MERGE (d:IPFS:Directory { cid: $dirCID })
      MERGE (d)-[c:CONTAINS]->(e)
      SET c.path = $name
    `,{dirCID:o,entryCID:d,name:i}),await f.close()}async function r({cid:o,type:d,size:i}){const f=t.session();await f.run(`
      MERGE (e:IPFS:File { cid: $cid })
      SET e.mimetype = CASE WHEN $type IS NOT NULL THEN $type END
      SET e.size = $size
    `,{cid:o,type:d,size:i}),await f.close()}async function s({path:o,cid:d}){const i=t.session(),f=`
      MERGE (r:Mount:Root)
      RETURN elementId(r) as id
    `,{records:u}=await i.run(f);let h=u[0].get("id");for(;o.length>0;){const m=`
        MATCH (p:Mount)
        WHERE elementId(p) = $next
        MERGE (p)-[:CONTAINS {path: $elem}]->(n:Mount)
        RETURN elementId(n) as id
      `,{records:w}=await i.run(m,{next:h,elem:o.shift()});h=w[0].get("id")}await i.run(`
      MATCH (m:Mount)
      WHERE elementId(m) = $next
      MATCH (i:IPFS { cid: $cid })
      MERGE (m)-[:CONNECTS {order: 1}]->(i)
    `,{next:h,cid:d}),await i.close()}async function c(o,d=[]){if(!o.children)throw new Error(`Not A Directory: ${o.title}`);for(const i of o.children)if(!(!i.selected&&i.getSelectedNodes().length===0)){if(i.children)await c(i);else{const f=(()=>{var u;switch((u=i.title.split(".").at(-1))==null?void 0:u.toLowerCase()){case"svg":return"image/svg+xml";case"png":return"image/png";case"jpg":case"jpeg":return"image/jpeg";default:return null}})();await r({cid:i.data.cid,type:f,size:i.data.size})}if(o.data.cid)await a({dirCID:o.data.cid,entryCID:i.data.cid,name:i.title});else return await s({path:d,cid:i.data.cid}),i.data.cid}}}var Me=Q('<form class="svelte-o04jkh"><input placeholder="/system/mount/point/"> <button>Neo4j Import</button></form>'),De=Q('<form class="svelte-o04jkh"><input type="file" required accept=".car"> <button>Read CAR</button></form> <!> <div id="fs-tree" class="svelte-o04jkh"></div>',1);function Ye(e,n){var p,m,w;ee(n,!0);class t{constructor(){x(this,m,A());x(this,w,A(!((p=this.form)!=null&&p.checkValidity())))}get form(){return v(I(this,m))}set form(y){b(I(this,m),R(y))}get disabled(){return v(I(this,w))}set disabled(y){b(I(this,w),R(y))}}m=new WeakMap,w=new WeakMap;let a=A(void 0),r=new t,s=A("");const c=async l=>{var S,O;l.preventDefault();const y=((S=r.form)==null?void 0:S.querySelector('input[type="file"]'))??null,E=(O=y==null?void 0:y.files)==null?void 0:O[0];if(!E)throw new Error("No file selected.");const k=await Oe(E);ye(k),b(a,R(he({source:k,mount:"fs-tree"})))},o=async l=>{l.preventDefault();const y=v(s).split("/").filter(Boolean);if(!v(a))throw new Error("No tree to mount.");$e(v(a).root,y)};var d=De();se(l=>{ae.title="Upload a CAR"});var i=te(d),f=D(i);f.__change=()=>{var l;return r.disabled=!((l=r.form)!=null&&l.checkValidity())};var u=L(f,2);P(i),ue(i,l=>r.form=l,()=>r==null?void 0:r.form);var h=L(i,2);ce(h,()=>!!v(a),l=>{var y=Me(),E=D(y);de(E),U(2),P(y),B("submit",y,o),pe(E,()=>v(s),k=>b(s,k)),M(l,y)}),U(2),ne(()=>u.disabled=r.disabled),B("submit",i,c),M(e,d),re()}ie(["change"]);export{Ye as component,Ke as universal};
