var M=e=>{throw TypeError(e)};var Y=(e,n,t)=>n.has(e)||M("Cannot "+t);var I=(e,n,t)=>(Y(e,n,"read from private field"),t?t.call(e):n.get(e)),V=(e,n,t)=>n.has(e)?M("Cannot add the same private member more than once"):n instanceof WeakSet?n.add(e):n.set(e,t);import{a as D,t as F}from"../chunks/Df6_adTu.js";import{p as J,f as X,t as P,a as Z,ap as j,c as U,s as S,R as C,av as k,a4 as b,r as B,aC as ee}from"../chunks/CkSVN3h7.js";import{d as te,e as z}from"../chunks/BTxUqvk3.js";import{h as ne}from"../chunks/DG8NnKi0.js";import{i as re}from"../chunks/CRthrAod.js";import{r as ae}from"../chunks/DAZ8PjuF.js";import{b as oe}from"../chunks/Z08y17X_.js";import{p as N}from"../chunks/DbpsKWpO.js";import{b as ie}from"../chunks/DhxH7cBY.js";import{v as T,d as se,a as G,C as q,b as ce,s as de,w as ue}from"../chunks/D2sTaU_6.js";import{g as fe,T as le}from"../chunks/CoPGGKb1.js";const $={SHA2_256:18,LENGTH:32,DAG_PB:112},he=40;function _(e,n){if(!e.length)throw new Error("Unexpected end of data");const t=T.decode(e);return n.seek(T.decode.bytes),t}function ye(e){const n=new DataView(e.buffer,e.byteOffset,e.byteLength);let t=0;return{version:2,characteristics:[n.getBigUint64(t,!0),n.getBigUint64(t+=8,!0)],dataOffset:Number(n.getBigUint64(t+=8,!0)),dataSize:Number(n.getBigUint64(t+=8,!0)),indexOffset:Number(n.getBigUint64(t+=8,!0))}}function me(e){T.decode(e);const n=T.decode.bytes,t=T.decode(e.subarray(T.decode.bytes)),a=T.decode.bytes;return n+a+t}const E={Null:e=>e===null?e:void 0,Int:e=>Number.isInteger(e)?e:void 0,Float:e=>typeof e=="number"&&Number.isFinite(e)?e:void 0,String:e=>typeof e=="string"?e:void 0,Bool:e=>typeof e=="boolean"?e:void 0,Bytes:e=>e instanceof Uint8Array?e:void 0,Link:e=>e!==null&&typeof e=="object"&&e.asCID===e?e:void 0,List:e=>Array.isArray(e)?e:void 0,Map:e=>e!==null&&typeof e=="object"&&e.asCID!==e&&!Array.isArray(e)&&!(e instanceof Uint8Array)?e:void 0},A={"CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)":E.Link,"CarV1HeaderOrV2Pragma > roots (anon)":e=>{if(E.List(e)!==void 0){for(let n=0;n<e.length;n++){let t=e[n];if(t=A["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](t),t===void 0)return;if(t!==e[n]){const a=e.slice(0,n);for(let r=n;r<e.length;r++){let s=e[r];if(s=A["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](s),s===void 0)return;a.push(s)}return a}}return e}},Int:E.Int,CarV1HeaderOrV2Pragma:e=>{if(E.Map(e)===void 0)return;const n=Object.entries(e);let t=e,a=1;for(let r=0;r<n.length;r++){const[s,c]=n[r];switch(s){case"roots":{const o=A["CarV1HeaderOrV2Pragma > roots (anon)"](e[s]);if(o===void 0)return;if(o!==c||t!==e){if(t===e){t={};for(let d=0;d<r;d++)t[n[d][0]]=n[d][1]}t.roots=o}}break;case"version":{a--;const o=A.Int(e[s]);if(o===void 0)return;if(o!==c||t!==e){if(t===e){t={};for(let d=0;d<r;d++)t[n[d][0]]=n[d][1]}t.version=o}}break;default:return}}if(!(a>0))return t}},x={"CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)":E.Link,"CarV1HeaderOrV2Pragma > roots (anon)":e=>{if(E.List(e)!==void 0){for(let n=0;n<e.length;n++){let t=e[n];if(t=x["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](t),t===void 0)return;if(t!==e[n]){const a=e.slice(0,n);for(let r=n;r<e.length;r++){let s=e[r];if(s=x["CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)"](s),s===void 0)return;a.push(s)}return a}}return e}},Int:E.Int,CarV1HeaderOrV2Pragma:e=>{if(E.Map(e)===void 0)return;const n=Object.entries(e);let t=e,a=1;for(let r=0;r<n.length;r++){const[s,c]=n[r];switch(s){case"roots":{const o=x["CarV1HeaderOrV2Pragma > roots (anon)"](c);if(o===void 0)return;if(o!==c||t!==e){if(t===e){t={};for(let d=0;d<r;d++)t[n[d][0]]=n[d][1]}t.roots=o}}break;case"version":{a--;const o=x.Int(c);if(o===void 0)return;if(o!==c||t!==e){if(t===e){t={};for(let d=0;d<r;d++)t[n[d][0]]=n[d][1]}t.version=o}}break;default:return}}if(!(a>0))return t}},pe={toTyped:A.CarV1HeaderOrV2Pragma,toRepresentation:x.CarV1HeaderOrV2Pragma};async function Q(e,n){const t=_(await e.upTo(8),e);if(t===0)throw new Error("Invalid CAR header (zero length)");const a=await e.exactly(t,!0),r=se(a);if(pe.toTyped(r)===void 0)throw new Error("Invalid CAR header format");if(r.version!==1&&r.version!==2||n!==void 0&&r.version!==n)throw new Error(`Invalid CAR version: ${r.version}${n!==void 0?` (expected ${n})`:""}`);if(r.version===1){if(!Array.isArray(r.roots))throw new Error("Invalid CAR header format");return r}if(r.roots!==void 0)throw new Error("Invalid CAR header format");const s=ye(await e.exactly(he,!0));e.seek(s.dataOffset-e.pos);const c=await Q(e,1);return Object.assign(c,s)}async function ge(e){const n=await e.exactly(2,!1);if(n[0]===$.SHA2_256&&n[1]===$.LENGTH){const c=await e.exactly(34,!0),o=G(c);return q.create(0,$.DAG_PB,o)}const t=_(await e.upTo(8),e);if(t!==1)throw new Error(`Unexpected CID version (${t})`);const a=_(await e.upTo(8),e),r=await e.exactly(me(await e.upTo(8)),!0),s=G(r);return q.create(t,a,s)}async function W(e){const n=e.pos;let t=_(await e.upTo(8),e);if(t===0)throw new Error("Invalid CAR section (zero length)");t+=e.pos-n;const a=await ge(e),r=t-Number(e.pos-n);return{cid:a,length:t,blockLength:r}}async function we(e){const{cid:n,blockLength:t}=await W(e);return{bytes:await e.exactly(t,!0),cid:n}}async function ve(e){const n=e.pos,{cid:t,length:a,blockLength:r}=await W(e),s={cid:t,length:a,blockLength:r,offset:n,blockOffset:e.pos};return e.seek(s.blockLength),s}function Ce(e){const n=(async()=>{const t=await Q(e);if(t.version===2){const a=e.pos-t.dataOffset;e=ke(e,t.dataSize-a)}return t})();return{header:()=>n,async*blocks(){for(await n;(await e.upTo(8)).length>0;)yield await we(e)},async*blocksIndex(){for(await n;(await e.upTo(8)).length>0;)yield await ve(e)}}}function Ee(e){let n=0;return{async upTo(t){return e.subarray(n,n+Math.min(t,e.length-n))},async exactly(t,a=!1){if(t>e.length-n)throw new Error("Unexpected end of data");const r=e.subarray(n,n+t);return a&&(n+=t),r},seek(t){n+=t},get pos(){return n}}}function Ie(e){let n=0,t=0,a=0,r=new Uint8Array(0);const s=async c=>{t=r.length-a;const o=[r.subarray(a)];for(;t<c;){const i=await e();if(i==null)break;t<0?i.length>t&&o.push(i.subarray(-t)):o.push(i),t+=i.length}r=new Uint8Array(o.reduce((i,f)=>i+f.length,0));let d=0;for(const i of o)r.set(i,d),d+=i.length;a=0};return{async upTo(c){return r.length-a<c&&await s(c),r.subarray(a,a+Math.min(r.length-a,c))},async exactly(c,o=!1){if(r.length-a<c&&await s(c),r.length-a<c)throw new Error("Unexpected end of data");const d=r.subarray(a,a+c);return o&&(n+=c,a+=c),d},seek(c){n+=c,a+=c},get pos(){return n}}}function Te(e){const n=e[Symbol.asyncIterator]();async function t(){const a=await n.next();return a.done?null:a.value}return Ie(t)}function ke(e,n){let t=0;return{async upTo(a){let r=await e.upTo(a);return r.length+t>n&&(r=r.subarray(0,n-t)),r},async exactly(a,r=!1){const s=await e.exactly(a,r);if(s.length+t>n)throw new Error("Unexpected end of data");return r&&(t+=a),s},seek(a){t+=a,e.seek(a)},get pos(){return e.pos}}}class be{constructor(n,t,a){this._version=n,this._roots=t,this._iterable=a,this._decoded=!1}get version(){return this._version}async getRoots(){return this._roots}}class O extends be{[Symbol.asyncIterator](){if(this._decoded)throw new Error("Cannot decode more than once");if(!this._iterable)throw new Error("Block iterable not found");return this._decoded=!0,this._iterable[Symbol.asyncIterator]()}static async fromBytes(n){const{version:t,roots:a,iterator:r}=await Ae(n);return new O(t,a,r)}static async fromIterable(n){const{version:t,roots:a,iterator:r}=await xe(n);return new O(t,a,r)}}async function Ae(e){if(!(e instanceof Uint8Array))throw new TypeError("fromBytes() requires a Uint8Array");return K(Ee(e))}async function xe(e){if(!e||typeof e[Symbol.asyncIterator]!="function")throw new TypeError("fromIterable() requires an async iterable");return K(Te(e))}async function K(e){const n=Ce(e),{version:t,roots:a}=await n.header();return{version:t,roots:a,iterator:n.blocks()}}async function*Re(e){const n=e.getReader();try{for(;;){const{done:t,value:a}=await n.read();if(t)return;yield a}}finally{n.releaseLock()}}async function He(e){const n=await O.fromIterable(Re(e.stream())),t=[],a=[],r={};let s=null;for await(const{cid:c,bytes:o}of n){s=c.toString();const d=await ce(o),{Links:i}=d;if(i.length===0){t.push(c.toString());continue}if(i.every(({Name:u})=>u==="")){a.push(c.toString());continue}const f=i.map(({Name:u,Tsize:y,Hash:g})=>({name:u,size:y,cid:g.toString()}));r[c.toString()]=f.map(u=>{const y=a.includes(u.cid)||t.includes(u.cid)?"file":"directory",g={type:y,title:u.name??`Unknown ${y}`,size:u.size??0,cid:u.cid};if(y==="directory"){const m=g.children=r[u.cid],w=m.map(({childCount:v=0})=>v);g.childCount=w.reduce((v,h)=>v+h,m.length)}return g})}if(!s)throw new Error("No nodes found.");return r[s]}async function Ve(e,n=[]){const t=fe();try{const o=await c(e,structuredClone(n));return console.info(`Mounted ${o} at /${n.join("/")}/.`),o}finally{await t.close()}async function a({dirCID:o,entryCID:d,name:i}){const f=t.session();await f.run(`
      MATCH (e:IPFS { cid: $entryCID })
      MERGE (d:IPFS:Directory { cid: $dirCID })
      MERGE (d)-[c:CONTAINS]->(e)
      SET c.path = $name
    `,{dirCID:o,entryCID:d,name:i}),await f.close()}async function r({cid:o,type:d,size:i}){const f=t.session();await f.run(`
      MERGE (e:IPFS:File { cid: $cid })
      SET e.mimetype = CASE WHEN $type IS NOT NULL THEN $type END
      SET e.size = $size
    `,{cid:o,type:d,size:i}),await f.close()}async function s({path:o,cid:d}){const i=t.session(),f=`
      MERGE (r:Mount:Root)
      RETURN elementId(r) as id
    `,{records:u}=await i.run(f);let y=u[0].get("id");for(;o.length>0;){const m=`
        MATCH (p:Mount)
        WHERE elementId(p) = $next
        MERGE (p)-[:CONTAINS {path: $elem}]->(n:Mount)
        RETURN elementId(n) as id
      `,{records:w}=await i.run(m,{next:y,elem:o.shift()});y=w[0].get("id")}await i.run(`
      MATCH (m:Mount)
      WHERE elementId(m) = $next
      MATCH (i:IPFS { cid: $cid })
      MERGE (m)-[:CONNECTS {order: 1}]->(i)
    `,{next:y,cid:d}),await i.close()}async function c(o,d=[]){if(!o.children)throw new Error(`Not A Directory: ${o.title}`);for(const i of o.children)if(!(!i.selected&&i.getSelectedNodes().length===0)){if(i.children)await c(i);else{const f=(()=>{var u;switch((u=i.title.split(".").at(-1))==null?void 0:u.toLowerCase()){case"svg":return"image/svg+xml";case"png":return"image/png";case"jpg":case"jpeg":return"image/jpeg";default:return null}})();await r({cid:i.data.cid,type:f,size:i.data.size})}if(o.data.cid)await a({dirCID:o.data.cid,entryCID:i.data.cid,name:i.title});else return await s({path:d,cid:i.data.cid}),i.data.cid}return o.data.cid}}var Ne=F('<form class="svelte-o04jkh"><input placeholder="/system/mount/point/"> <button>Neo4j Import</button></form>'),_e=F('<form class="svelte-o04jkh"><input type="file" required accept=".car"> <button>Read CAR</button></form> <!> <div id="fs-tree" class="svelte-o04jkh"></div>',1);function Fe(e,n){var g,m,w,v;J(n,!0);class t{constructor(){V(this,m,k());V(this,w,k(!((g=this.form)!=null&&g.checkValidity())));V(this,v,k(!1))}get form(){return C(I(this,m))}set form(l){b(I(this,m),N(l))}get disabled(){return C(I(this,w))}set disabled(l){b(I(this,w),N(l))}get generating(){return C(I(this,v))}set generating(l){b(I(this,v),N(l))}}m=new WeakMap,w=new WeakMap,v=new WeakMap;let a=k(void 0),r=new t,s=k("");const c=async h=>{var H,L;h.preventDefault();const l=((H=r.form)==null?void 0:H.querySelector('input[type="file"]'))??null,p=(L=l==null?void 0:l.files)==null?void 0:L[0];if(!p)throw new Error("No file selected.");const R=await He(p);de(R),b(a,N(ue({source:R,mount:"fs-tree"})))},o=async h=>{h.preventDefault();try{r.generating=!0;const l=C(s).split("/").filter(Boolean);if(!C(a))throw new Error("No tree to mount.");const p=await Ve(C(a).root,l);le({text:`Loaded: ipfs://${p.slice(0,5)}…${p.slice(-5)}`,duration:8e3,destination:`https://w3s.link/ipfs/${p}`,newWindow:!0,close:!0,gravity:"bottom",position:"center",stopOnFocus:!0,style:{background:"linear-gradient(to right, #00b09b, #96c93d)"}}).showToast()}finally{r.generating=!1}};var d=_e();ne(h=>{j.title="Upload a CAR"});var i=X(d),f=U(i);f.__change=()=>{var h;return r.disabled=!((h=r.form)!=null&&h.checkValidity())};var u=S(f,2);B(i),ie(i,h=>r.form=h,()=>r==null?void 0:r.form);var y=S(i,2);re(y,()=>!!C(a),h=>{var l=Ne(),p=U(l);ae(p);var R=S(p,2);B(l),P(()=>R.disabled=r.generating),z("submit",l,o),oe(p,()=>C(s),H=>b(s,H)),D(h,l)}),ee(2),P(()=>u.disabled=r.disabled),z("submit",i,c),D(e,d),Z()}te(["change"]);export{Fe as component};
