var $=Object.defineProperty;var _=e=>{throw TypeError(e)};var K=(e,t,r)=>t in e?$(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r;var m=(e,t,r)=>K(e,typeof t!="symbol"?t+"":t,r),A=(e,t,r)=>t.has(e)||_("Cannot "+r);var w=(e,t,r)=>(A(e,t,"read from private field"),r?r.call(e):t.get(e)),O=(e,t,r)=>t.has(e)?_("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(e):t.set(e,r),N=(e,t,r,a)=>(A(e,t,"write to private field"),a?a.call(e,r):t.set(e,r),r);import"../chunks/CWj6FrbW.js";import"../chunks/BviadKC5.js";import{p as M,f as E,X as x,d as g,b,c as D,$ as H,s as f,ai as W,l as I,r as u,a as q,t as U,G as z}from"../chunks/DyJcJ3Y7.js";import{d as F,s as B}from"../chunks/THFJsEQF.js";import{i as G}from"../chunks/CmfBeWXP.js";import{h as J}from"../chunks/BgZ3Q8g3.js";import{s as Y}from"../chunks/DU3eORWj.js";import{i as X}from"../chunks/Bjjg9L97.js";import{C as h}from"../chunks/C6cB8dNp.js";import{a as Q,e as V,g as R}from"../chunks/_6bbJwjk.js";import{t as Z}from"../chunks/D2JTxiFN.js";import{m as ee,W as te,P as T,c as re,q as oe}from"../chunks/WRHwwoH-.js";const y={async nodes({batchSize:e,status:t,rootId:r}){const o=R().session();try{const p=await o.run(`
        OPTIONAL MATCH (start) WHERE elementId(start) = $rootId
        MATCH (node)
        WHERE
          $rootId IS NULL OR
          (start IS NOT NULL AND ((start)-[*]->(node)))
        RETURN
          DISTINCT elementId(node) as id,
          labels(node) as labels,
          properties(node) as properties
        ORDER BY elementId(node)
      `,{rootId:r});return t==null||t(`Found ${p.records.length} node${p.records.length===1?"":"s"}`),Object.fromEntries(await Promise.all(Array.from(p.records).map(async i=>[i.get("id"),await v({type:"node",labels:i.get("labels"),properties:Object.fromEntries(Object.entries(i.get("properties")).map(([n,c])=>(n==="cid"&&typeof c=="string"&&(c=h.parse(c)),[n,c])))})])))}finally{await o.close()}},async relationships(e,{batchSize:t,status:r,rootId:a}){const s=R().session();try{const i=await s.run(`
        OPTIONAL MATCH (start) WHERE elementId(start) = $rootId
        MATCH (source)-[r]->(target)
        WHERE
          $rootId IS NULL OR
          (start IS NOT NULL AND ((start)-[*]->(source)))
        RETURN
          elementId(source) as sourceId,
          elementId(target) as targetId,
          type(r) as type,
          properties(r) as properties
        ORDER BY elementId(r)
      `,{rootId:a});return Array.from(i.records).map(n=>{const c=e[n.get("sourceId")],l=e[n.get("targetId")];if(!c)throw new Error(`No node for ${n.get("sourceId")}`);if(!l)throw new Error(`No node for ${n.get("targetId")}`);if(!c.equals(l))return{type:"relation",relationship:n.get("type"),source:c,target:l,properties:n.get("properties")}}).filter(Boolean)}finally{await s.close()}},async index(e,t,{status:r,rootId:a}){const o=new Set(t.map(i=>{var n;return((n=i.target)==null?void 0:n.toString())??(()=>{throw new Error(`Relation Mapping Error: ${JSON.stringify(i,null,2)}`)})()})),s=new Set(Object.values(e).map(i=>i.toString())),p=s.difference(o);return console.debug({allIds:s.values().map(i=>h.parse(i)),roots:p}),v({nodes:Array.from(s.values()).map(i=>h.parse(i)),relations:t,roots:Array.from(p.values()).map(i=>h.parse(i))})}};async function v(e){return await Q().block.put(V(e),{format:"dag-json"})}async function ae({status:e=null,batchSize:t=1e3,rootId:r=null}){const a={status:e,batchSize:t,rootId:r};try{e==null||e("Exporting nodes…");const o=await y.nodes(a);console.debug({nodes:o}),e==null||e("Adding relationships…");const s=await y.relationships(o,a);e==null||e("Writing to IPFS…");const p=await y.index(o,s,a);return e==null||e(`Graph serialized to IPFS.
  Root CID:  ${p} `),p}catch(o){throw console.error("Error serializing graph:",o),o}}var d;class se{constructor(){m(this,"networks",[ee]);m(this,"adapter",new te({projectId:T,networks:this.networks}));m(this,"metadata",{name:"Mïmis",description:"Collaborative filesystem",url:"https://mimis.dhappy.org",icons:["https://avatars.githubusercontent.com/u/179229932"]});O(this,d,null)}get appKit(){return w(this,d)||N(this,d,re({adapters:[this.adapter],networks:this.networks,metadata:this.metadata,projectId:T,features:{analytics:!0,swaps:!1,onramp:!1,connectMethodsOrder:["wallet","social","email"]}})),w(this,d)}async getProvider(t="eip155"){return await this.appKit.ready(),new Promise((r,a)=>{const o=this.appKit.getProvider(t);if(o)return r(o);this.appKit.subscribeProviders(s=>r(s[t])),this.appKit.subscribeEvents(s=>{s.data.event==="MODAL_CLOSE"&&(s.data.properties.connected||a(new Error("Modal closed without connection.")))}),this.appKit.open()})}async signMessage(t,{log:r}={}){const a=await this.getProvider();let{address:o}=this.appKit.getAccount();if(o||(o=await new Promise(s=>{this.appKit.subscribeAccount(({address:p})=>{p&&s(p)}),this.appKit.open()})),r==null||r({message:t,provider:a,address:o}),!o)throw new Error("Could not find address from provider.");return await a.request({method:"personal_sign",params:[t,o]})}}d=new WeakMap;const C=new se,ie=async(e,t)=>{const r=await ae({status:console.debug});console.debug({acct:await oe(C.adapter.wagmiConfig)});const a=await C.signMessage(r.toString(),{log:console.debug});console.debug({signature:a}),W(t,await v({index:r,signature:a}))};var ne=E('<link rel="icon" href="radioactive%20barrel.svg"/>'),pe=E('<hr/> <a class="button svelte-182wcux" target="_blank"><span class="svelte-182wcux">Browse <code> </code></span></a>',1),ce=E('<main class="svelte-182wcux"><button class="svelte-182wcux">Publish</button> <appkit-button></appkit-button> <!></main>',2);function Se(e,t){M(t,!1);let r=x(null);X();var a=ce();J(n=>{var c=ne();H.title="Mïmis: Serialize",b(n,c)});var o=g(a);o.__click=[ie,r];var s=f(o,2),p=f(s,2);{var i=n=>{var c=pe(),l=f(q(c),2),S=g(l),P=f(g(S)),k=g(P);u(P),u(S),u(l),U((j,L)=>{Y(l,"href",j),B(k,`ipfs://${L??""}`)},[()=>Z({cid:I(r).toString()}),()=>I(r).toString()],z),b(n,c)};G(p,n=>{I(r)&&n(i)})}u(a),b(e,a),D()}F(["click"]);export{Se as component};
