var K=Object.defineProperty;var A=t=>{throw TypeError(t)};var L=(t,r,e)=>r in t?K(t,r,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[r]=e;var m=(t,r,e)=>L(t,typeof r!="symbol"?r+"":r,e),O=(t,r,e)=>r.has(t)||A("Cannot "+e);var w=(t,r,e)=>(O(t,r,"read from private field"),e?e.call(t):r.get(t)),T=(t,r,e)=>r.has(t)?A("Cannot add the same private member more than once"):r instanceof WeakSet?r.add(t):r.set(t,e),_=(t,r,e,a)=>(O(t,r,"write to private field"),a?a.call(t,e):r.set(t,e),e);import"../chunks/CWj6FrbW.js";import"../chunks/DxqOjG3C.js";import{p as $,f as E,U as M,d as l,b,c as D,$ as H,s as f,ak as U,l as I,r as h,a as W,t as F}from"../chunks/DZGWyE00.js";import{d as q,s as z}from"../chunks/j-tIMm_a.js";import{i as B}from"../chunks/qJDjqx1W.js";import{h as G}from"../chunks/BJ8MXW2t.js";import{s as J}from"../chunks/D117-Z4F.js";import{i as Y}from"../chunks/D9nVkNGF.js";import{C as y}from"../chunks/BaF23LuM.js";import{a as Q,e as V,g as k,T as X}from"../chunks/48yNolhK.js";import{t as Z}from"../chunks/affk8B0K.js";import{m as tt,W as et,P as N,c as rt,G as st}from"../chunks/Dmo4G5XH.js";const v={async nodes({batchSize:t,log:r,rootId:e}){const s=k().session();try{const o=await s.run(`
        OPTIONAL MATCH (start) WHERE elementId(start) = $rootId
        MATCH (node)
        WHERE
          $rootId IS NULL OR
          (start IS NOT NULL AND ((start)-[*]->(node)))
        RETURN
          DISTINCT elementId(node) as id,
          labels(node) as labels,
          properties(node) as properties
        ORDER BY elementId(node)
      `,{rootId:e});return r==null||r(`Found ${o.records.length} node${o.records.length===1?"":"s"}`),Object.fromEntries(await Promise.all(Array.from(o.records).map(async i=>[i.get("id"),await g({type:"node",labels:i.get("labels"),properties:Object.fromEntries(Object.entries(i.get("properties")).map(([n,p])=>(n==="cid"&&typeof p=="string"&&(p=y.parse(p)),[n,p])))})])))}finally{await s.close()}},async relationships(t,{batchSize:r,log:e,rootId:a}){const c=k().session();try{const i=await c.run(`
        OPTIONAL MATCH (start) WHERE elementId(start) = $rootId
        MATCH (source)-[r]->(target)
        WHERE
          $rootId IS NULL OR
          (start IS NOT NULL AND ((start)-[*]->(source)))
        RETURN
          elementId(source) as sourceId,
          elementId(target) as targetId,
          type(r) as type,
          properties(r) as properties
        ORDER BY elementId(r)
      `,{rootId:a});return Array.from(i.records).map(n=>{const p=t[n.get("sourceId")],d=t[n.get("targetId")];if(!p)throw new Error(`No node for ${n.get("sourceId")}`);if(!d)throw new Error(`No node for ${n.get("targetId")}`);if(!p.equals(d))return{type:"relation",relationship:n.get("type"),source:p,target:d,properties:n.get("properties")}}).filter(Boolean)}finally{await c.close()}},async index(t,r,{log:e,rootId:a}){const s=new Set(r.map(i=>{var n;return((n=i.target)==null?void 0:n.toString())??(()=>{throw new Error(`Relation Mapping Error: ${JSON.stringify(i,null,2)}`)})()})),c=new Set(Object.values(t).map(i=>i.toString())),o=c.difference(s);return g({roots:Array.from(o.values()).map(i=>y.parse(i)),nodes:Array.from(c.values()).map(i=>y.parse(i)),relations:r})}};async function g(t){return await Q().block.put(V(t),{format:"dag-json"})}async function at({log:t=null,batchSize:r=1e3,rootId:e=null}){const a={log:t,batchSize:r,rootId:e};try{t==null||t("Exporting nodes…");const s=await v.nodes(a);t==null||t({nodes:s}),t==null||t("Adding relationships…");const c=await v.relationships(s,a);t==null||t("Writing to IPFS…");const o=await v.index(s,c,a);return t==null||t(`Graph serialized to IPFS.
  Index CID: "${o}"`),o}catch(s){throw console.error({"Graph Serializing Error":s}),s}}var u;class it{constructor(){m(this,"networks",[tt]);m(this,"adapter",new et({projectId:N,networks:this.networks}));m(this,"metadata",{name:"Mïmis",description:"Collaborative filesystem",url:"https://mimis.dhappy.org",icons:["https://avatars.githubusercontent.com/u/179229932"]});T(this,u,null)}get appKit(){return w(this,u)||_(this,u,rt({adapters:[this.adapter],networks:this.networks,metadata:this.metadata,projectId:N,features:{analytics:!0,swaps:!1,onramp:!1,connectMethodsOrder:["wallet","social","email"]}})),w(this,u)}async getProvider(r="eip155",{log:e}={}){await this.appKit.ready();const a=new Promise((s,c)=>{const o=this.appKit.getProvider(r);if(o)return e==null||e({"AppKit Provider":o}),s(o);this.appKit.subscribeProviders(i=>s(i[r])),this.appKit.subscribeEvents(i=>{i.data.event==="MODAL_CLOSE"&&(i.data.properties.connected||c(new Error("Modal closed without connection.")))}),this.appKit.open()});return e==null||e({"Promised Provider":a}),a}async signMessage(r,{log:e}={}){const a=await this.getProvider(void 0,{log:e});let{address:s}=this.appKit.getAccount();if(s||(s=await new Promise(c=>{this.appKit.subscribeAccount(({address:o})=>{o&&c(o)}),this.appKit.open()})),e==null||e({message:r,provider:a,address:s}),!s)throw new Error("Could not find address from provider.");return await a.request({method:"personal_sign",params:[r,s]})}}u=new WeakMap;const C=new it,ot=async(t,r)=>{try{const e=await at({status:console.debug});console.debug({acct:await st(C.adapter.wagmiConfig)});const a=await C.signMessage(e.toString(),{log:console.debug});console.debug({signature:a}),U(r,await g({index:e,signature:a}))}catch(e){console.debug({"Signing Error":e}),X({text:e.message,duration:16e3,close:!0,gravity:"bottom",position:"center",stopOnFocus:!0,style:{background:"linear-gradient(to right, #b09b00, #96003d)"}}).showToast()}};var nt=E('<link rel="icon" href="radioactive%20barrel.svg"/>'),ct=E('<hr/> <a class="button svelte-182wcux" target="_blank"><span class="svelte-182wcux">Browse <code> </code></span></a>',1),pt=E('<main class="svelte-182wcux"><button class="svelte-182wcux">Publish</button> <appkit-button></appkit-button> <!></main>',2);function Pt(t,r){$(r,!1);let e=M(null);Y();var a=pt();G(n=>{var p=nt();H.title="Mïmis: Serialize",b(n,p)});var s=l(a);s.__click=[ot,e];var c=f(s,2),o=f(c,2);{var i=n=>{var p=ct(),d=f(W(p),2),P=l(d),S=f(l(P)),R=l(S);h(S),h(P),h(d),F((x,j)=>{J(d,"href",x),z(R,`ipfs://${j??""}`)},[()=>Z({cid:I(e).toString()}),()=>I(e).toString()]),b(n,p)};B(o,n=>{I(e)&&n(i)})}h(a),b(t,a),D()}q(["click"]);export{Pt as component};
